<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>艾斯牛 Blog</title>
  <icon>https://www.gravatar.com/avatar/c64997c9d7912f88b4e2d0181ae88958</icon>
  <subtitle>一生志愿只要平凡快乐</subtitle>
  <link href="https://blog.halfsummer.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.halfsummer.xyz/"/>
  <updated>2023-03-13T17:11:01.902Z</updated>
  <id>https://blog.halfsummer.xyz/</id>
  
  <author>
    <name>aceniu</name>
    <email>123354319@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tomcat 学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/c1c5e0d7.html"/>
    <id>https://blog.halfsummer.xyz/posts/c1c5e0d7.html</id>
    <published>2023-03-13T23:19:24.000Z</published>
    <updated>2023-03-13T17:11:01.902Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Tomcat">Tomcat</h1><p>Tomcat最初是由Sun的软件架构师詹姆斯·邓肯·戴维森开发的。后来他帮助将其变为开源项目，并由Sun贡献给Apache软件基金会。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web 应用服务器。</p><p>目前企业中的 Tomcat 服务器，主流版本还是 7.x 和 8.x。</p><h2 id="1）安装">1）安装</h2><ol><li><p>下载 tomcat</p><p><a href="https://tomcat.apache.org/">官网</a></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230114002845365.png" alt="image-20230114002845365"></p></li><li><p>依赖安装</p><p>tomcat默认依赖jdk，需要按照工作需求安装指定版本的jdk。</p></li><li><p>安装 tomcat (apache-tomcat-8.5.84.tar.gz以下以此版本为例)</p><p>将安装包上传到服务器，解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -zxvf apache-tomcat-8.5.84.tar.gz -C /usr/local</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">名字太长了 建立软链接</span></span><br><span class="line">[root@localhost ~]# ln -s /usr/local/apache-tomcat-8.5.84.tar.gz /usr/local/tomcat8</span><br></pre></td></tr></table></figure></li><li><p>放开 8080 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>tomcat 控制命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/tomcat8/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 tomcat</span></span><br><span class="line">[root@localhost ~]# ./startup.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭 tomcat</span></span><br><span class="line">[root@localhost ~]# ./shutdown.sh</span><br></pre></td></tr></table></figure></li><li><p>配置开机自启动（可以不配，在服务中配置即可）</p><p>众所周知，在Linux中设置开机自启动的服务，需要在/etc/rcX.d下挂载。除此之外还需要在/etc/init.d下些启动脚本。其实很简单，先export出所需要的环境变量，例如JAVA_HOME，JRE_HOME, CATALINA_HOME, CATALINA_BASE什么的，然后再直接调用$CATALINA_HOME/bin/startup.sh就能成功启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/init.d/tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: Tomcat8 Start Stop Restart</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">processname: tomcat8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig: 345 99 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CATALINA_HOME=/usr/local/tomcat8</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">        start)</span><br><span class="line">                sh $CATALINA_HOME/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        stop)</span><br><span class="line">                sh $CATALINA_HOME/bin/shutdown.sh</span><br><span class="line">                ;;</span><br><span class="line">        restart)</span><br><span class="line">                sh $CATALINA_HOME/bin/shutdown.sh</span><br><span class="line">                sh $CATALINA_HOME/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo &#x27;please use : tomcat &#123;start | stop | restart&#125;&#x27;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# chmod 755 /etc/init.d/tomcat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时可以使用</span></span><br><span class="line">[root@localhost ~]# service start tomcat</span><br></pre></td></tr></table></figure><p>在 chkconfig 添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向chkconfig添加 tomcat 服务的管理</span></span><br><span class="line">[root@localhost ~]# chkconfig --add tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置tomcat服务自启动</span></span><br><span class="line">[root@localhost ~]# chkconfig tomcat on</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看tomcat的启动状态</span></span><br><span class="line">[root@localhost ~]# chkconfig --list | grep tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">状态如下：</span></span><br><span class="line">[root@localhost ~]# chkconfig –list | grep tomcat</span><br><span class="line"></span><br><span class="line">tomcat 0:off 1:off 2:on 3:on 4:on 5:on 6:off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭tomcat服务自启动：</span></span><br><span class="line">[root@localhost ~]# chkconfig tomcat off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除tomcat服务在chkconfig上的管理：</span></span><br><span class="line">[root@localhost ~]# chkconfig –del tomcat</span><br></pre></td></tr></table></figure></li></ol><h2 id="2）目录结构">2）目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(tomcat/) --&gt; B1(bin/)</span><br><span class="line">A--&gt; B2(conf/)</span><br><span class="line">A--&gt; B3(logs/)</span><br><span class="line">A--&gt; B4(webapps/)</span><br><span class="line">A--&gt; B5(lib/)</span><br><span class="line">A--&gt; B6(temp/)</span><br><span class="line">A--&gt; B7(work/)</span><br><span class="line">subgraph *存放管理脚本*</span><br><span class="line">B1 --&gt; |启动| b1-1(startup.sh)</span><br><span class="line">B1 --&gt; |关闭| b1-2(shutdown.sh)</span><br><span class="line">B1 --&gt; |tomcat核心脚本| b1-3(catalina.sh)</span><br><span class="line">end</span><br><span class="line">subgraph *配置文件*</span><br><span class="line">B2 --&gt; |主配置文件|b2-1(server.xml)</span><br><span class="line">B2 --&gt; |内置tomcat内置功能| b2-2(web.xml)</span><br><span class="line">B2 --&gt; |属性| b2-3(logging.properties)</span><br><span class="line">B2 --&gt; |管理端配置文件--&#x27;线上环境关闭&#x27;--| b2-4(tomcat-users.xml)</span><br><span class="line">end</span><br><span class="line">subgraph *日志*</span><br><span class="line">B3  --&gt; |主要日志|b3-1(catalina.out)</span><br><span class="line">B3  --&gt; |切割日志|b3-2(catalina.2023-01-14.log)</span><br><span class="line">B3  --&gt; |访问日志|b3-3(localhost_access_log.2023-01-14.txt)</span><br><span class="line">end</span><br><span class="line">    subgraph *站点目录*</span><br><span class="line">B4</span><br><span class="line">end</span><br><span class="line">subgraph 依赖</span><br><span class="line">B5</span><br><span class="line">end</span><br><span class="line">subgraph 临时目录</span><br><span class="line">B6</span><br><span class="line">end</span><br><span class="line">subgraph 运行代码的编译临时目录</span><br><span class="line">B7</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="3）基本使用">3）基本使用</h2><h3 id="3-1-部署app方式">3.1 部署app方式</h3><ol><li><p><strong>war包</strong></p><p>将打包好的war包上传到tomcat服务器的webapps目录,Tomcat服务器自动解压缩xxxx.war包。</p><p>检查一下tomcat服务器是否自动在conf目录下创建了Catalina/localhost目录，在看看localhost目录下是否有tomcat服务器自动创建的xxxx.xml文件。</p></li><li><p><strong>jar包</strong></p><p>默认java打包好后，自带了tomcat环境。</p><p>只需要执行：（前台运行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxxx.jar</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-查看日志">3.2 查看日志</h3><ol><li><p>进入logs文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd usr/local/tomcat8/logs/</span><br></pre></td></tr></table></figure></li><li><p>实时查看tomcat日志信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail -f catalina.out</span><br></pre></td></tr></table></figure><p>注意查看错误关键字： <code>error</code> <code>failed</code> <code>exception</code></p></li></ol><h3 id="3-3-添加服务">3.3 添加服务</h3><ul><li><p>systemctl 通过 <code> /usr/lib/systemd/system/xxxx.service</code> 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个配置文件</span></span><br><span class="line">[root@localhost ~]# vim /usr/lib/systemd/system/tomcat.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-----------------------</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Apache Tomcat 8# 注释、描述</span><br><span class="line">After=network-online.target remote-fs.target nss-lookup.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Environment=<span class="string">&quot;JAVA_HOME=/usr/lib/jvm/openJDK8/&quot;</span> <span class="comment"># yum 安装的jdk可以省略环境</span></span></span><br><span class="line">ExecStart=/usr/local/tomcat8/bin/startup.sh</span><br><span class="line">ExecStop=/usr/local/tomcat8/bin/shutdown.sh</span><br><span class="line">ExecReload=/usr/local/tomcat8/bin/shutdown.sh &amp;&amp; sleep 2 &amp;&amp; /usr/local/tomcat8/bin/startup.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">usually, tomcat service will be killed with exit_code 143.</span></span><br><span class="line">SuccessExitStatus=143</span><br><span class="line">PrivateTmp=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">User=root</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Group=root</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>重新载入 systemctl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl daemon-reload</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-管理端">3.4 管理端</h3><p><span style="color:red">**※ 注意！！！**生产环境中，监控时可以设置下内网访问下，通常处于关闭状态（存在安全隐患）。</span></p><p>当我们部署了tomcat之后 用浏览器打开ip:8080端口之后会看到如下界面在界面的又上角可以看到三个按钮Serve Status、Manager APP 和HostManager。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230114222425802.png" alt="image-20230114222425802"></p><p><span style="color:red"><strong>tomcat8.5之后对ip进行了限制，仅允许本地登入 解决方法：</strong></span></p><ol><li><p>编辑tomcat安装路径下的tomcat-users.xm文件。</p><p><code>vim /usr/local/tomcat/conf/tomcat-users.xml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot;</span><br><span class="line">              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span><br><span class="line">              version=&quot;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;role rolename=&quot;admin-gui&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;admin-script&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-script&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-jmx&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-status&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;niu&quot; password=&quot;niu&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-script,admin-gui&quot;/&gt;</span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure><ul><li><p>配置解释：前4个是开启前两个按钮(Serve Status、Manager APP)的角色，后面两个是开启第三个按钮(HostManager)的角色</p><p>manager-gui - 访问HTML界面。</p><p>manager-status - 只能访问“服务器状态”页面。</p><p>manager-script - 这个权限是指可以执行url命令后面会演示</p><p>manager-jmx - 访问JMX代理接口并访问“服务器状态”页面</p><p>admin-gui host-manager的web管理界面</p><p>admin-script host-manager的文本管理角色</p></li></ul></li><li><p>新建文件并添加如下内容，默认没有，这一步也是为了开启前两个按钮(Serve Status、Manager APP)配置。</p><p><code>vim /usr/local/tomcat8/conf/Catalina/localhost/manager.xml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot;&gt;</span><br><span class="line">    &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;^.*$&quot; /&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改如下原有文件，这一步是为了开启第二个按钮(Manager)配置。</p><p><code>vim /usr/local/tomcat8/webapps/manager/META-INF</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt;</span><br><span class="line">  &lt;CookieProcessor className=&quot;org.apache.tomcat.util.http.Rfc6265CookieProcessor&quot;</span><br><span class="line">                   sameSiteCookies=&quot;strict&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span><br><span class="line">         allow=&quot;^.*$&quot; /&gt;</span><br><span class="line">  &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改如下原有文件，这一步是为了开启第三个按钮(HostManager)配置。</p><p><code>vim /usr/local/tomcat8/webapps/host-manager/META-INF/context.xml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt;</span><br><span class="line">  &lt;CookieProcessor className=&quot;org.apache.tomcat.util.http.Rfc6265CookieProcessor&quot;</span><br><span class="line">                   sameSiteCookies=&quot;strict&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span><br><span class="line">         allow=&quot;^.*$&quot; /&gt;</span><br><span class="line">  &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl restart tomcat</span><br></pre></td></tr></table></figure><p>现在可以根据设置的账号密码进行使用。</p></li></ol><h2 id="4）配置">4）配置</h2><h3 id="4-1-主配置文件-server-xml">4.1 主配置文件 server.xml</h3><p><code>vim /usr/local/tomcat8/conf/server.xml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- port: 接收shutdown指令的端口，默认仅允许通过本机访问，默认为8005；</span><br><span class="line">     shutdown：发往此Server用于实现关闭tomcat实例的命令字符串，默认为SHUTDOWN；</span><br><span class="line">     使用方式：telnet localhost 8005， 输入SHUTDOWN即可关闭tomcat   </span><br><span class="line">  </span><br><span class="line">     如果你不配置这两个属性，Tomcat的这种关闭机制还是会运行的。你不想暴露这种关闭机制的</span><br><span class="line">     话，可以将端口设置成poer=-1，shutdown设置成一个复杂的字符串，比如shutdown=&quot;xscdeww#12&quot;</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">  &lt;!-- 默认配置的Listener --&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 应用于整个服务器的JNDI映射，此可以避免每个Web应用程序都需要在各自的web.xml创建，这在web应用程序        以WAR的形式存在时尤为有用。</span><br><span class="line">   --&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;!-- GlobalNamingResources 是管理端页面的配置，工作环境请注释</span><br><span class="line">   --&gt;  </span><br><span class="line">  &lt;GlobalNamingResources&gt;</span><br><span class="line">    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;</span><br><span class="line">              type=&quot;org.apache.catalina.UserDatabase&quot;</span><br><span class="line">              description=&quot;User database that can be updated and saved&quot;</span><br><span class="line">              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span><br><span class="line">              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;</span><br><span class="line">  &lt;/GlobalNamingResources&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Service是多个Connector和单个Container的组合。Container是一个抽象的概念，由Engine, Realm,        Valve和Hosts主组组成。</span><br><span class="line">       在server.xml配置文件中可以同时配置多个Service标签</span><br><span class="line">   --&gt;</span><br><span class="line">  &lt;Service name=&quot;Catalina&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--The connectors can use a shared executor, you can define one or more named thread         pools</span><br><span class="line">     --&gt; </span><br><span class="line">    &lt;!-- 默认情况下，每个连接器connector会使用自己创建的线程池，我们也可以配置多个线程池让连接器共享--&gt;</span><br><span class="line">    &lt;!-- 如果想让连接器connector组件使用这个线程池，需要在连接器组件中配置executor属性.</span><br><span class="line">         另外，Executor元素的配置应该放在Connector配置的前面，这样才会先加载Executor的配置。</span><br><span class="line">        </span><br><span class="line">         Executor的主要属性包括：</span><br><span class="line">          - name：该线程池的名称id</span><br><span class="line">          - maxThreads：线程池中最大活跃线程数，默认值200（Tomcat7和8都是）</span><br><span class="line">          - minSpareThreads：线程池中保持的最小线程数，最小值是25</span><br><span class="line">          - maxIdleTime：线程空闲的最大时间，当空闲超过该值时关闭线程（除非线程数小于</span><br><span class="line">                         minSpareThreads），单位是ms，默认值60000（1分钟）</span><br><span class="line">          - daemon：是否后台线程，默认值true</span><br><span class="line">          - threadPriority：线程优先级，默认值5</span><br><span class="line">          - namePrefix：线程名字的前缀，线程池中线程名字为：namePrefix+线程编号</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;</span><br><span class="line">              maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- A &quot;Connector&quot; represents an endpoint by which requests are received</span><br><span class="line">         and responses are returned. Documentation at :</span><br><span class="line">         Java HTTP Connector: /docs/config/http.html</span><br><span class="line">         Java AJP  Connector: /docs/config/ajp.html</span><br><span class="line">         APR (HTTP/AJP) Connector: /docs/apr.html</span><br><span class="line">         Define a non-SSL/TLS HTTP/1.1 Connector on port 8080</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- Connector是Tomcat中请求接收和响应返回的端点，Tomcat中支持HTTP、AJP和APR等协议。</span><br><span class="line">         下面的配置定义了一个支持Http协议的连接器，监听8080端口</span><br><span class="line"></span><br><span class="line">         Connector组件支持以下组件的配置：</span><br><span class="line">          - address：指定连接器监听的地址，默认为所有地址，即0.0.0.0；</span><br><span class="line">          - port：监听的端口，默认为0；</span><br><span class="line">          - protocol：连接器使用的协议，默认为HTTP/1.1，定义AJP协议时通常为AJP/1.3；</span><br><span class="line">          - connectionTimeout：等待客户端发送请求的超时时间，单位为毫秒，默认为60000，即1分钟；</span><br><span class="line">          - maxThreads：支持的最大并发连接数，默认为200；</span><br><span class="line">          - redirectPort：如果某连接器支持的协议是HTTP，当接收客户端发来的HTTPS请求时，</span><br><span class="line">                          则转发至此属性定义的端口；</span><br><span class="line">          - enableLookups：是否通过request.getRemoteHost()进行DNS查询以获取客户端的主机名；</span><br><span class="line">                           默认为true；</span><br><span class="line">          - acceptCount：设置等待队列的最大长度；</span><br><span class="line">          - executor：指定共享的线程池组件；</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; </span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot;</span><br><span class="line">               executor=&quot;tomcatThreadPool&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 下面是进行支持Https的配置 --&gt;</span><br><span class="line">    &lt;!-- Define an SSL/TLS HTTP/1.1 Connector on port 8443</span><br><span class="line">         This connector uses the NIO implementation. The default</span><br><span class="line">         SSLImplementation will depend on the presence of the APR/native</span><br><span class="line">         library and the useOpenSSL attribute of the</span><br><span class="line">         AprLifecycleListener.</span><br><span class="line">         Either JSSE or OpenSSL style configuration may be used regardless of</span><br><span class="line">         the SSLImplementation selected. JSSE style configuration is used below.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt;</span><br><span class="line">        &lt;SSLHostConfig&gt;</span><br><span class="line">            &lt;Certificate certificateKeystoreFile=&quot;conf/localhost-rsa.jks&quot;</span><br><span class="line">                         type=&quot;RSA&quot; /&gt;</span><br><span class="line">        &lt;/SSLHostConfig&gt;</span><br><span class="line">    &lt;/Connector&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- Define an SSL/TLS HTTP/1.1 Connector on port 8443 with HTTP/2</span><br><span class="line">         This connector uses the APR/native implementation which always uses</span><br><span class="line">         OpenSSL for TLS.</span><br><span class="line">         Either JSSE or OpenSSL style configuration may be used. OpenSSL style</span><br><span class="line">         configuration is used below.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span><br><span class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; &gt;</span><br><span class="line">        &lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt;</span><br><span class="line">        &lt;SSLHostConfig&gt;</span><br><span class="line">            &lt;Certificate certificateKeyFile=&quot;conf/localhost-rsa-key.pem&quot;</span><br><span class="line">                         certificateFile=&quot;conf/localhost-rsa-cert.pem&quot;</span><br><span class="line">                         certificateChainFile=&quot;conf/localhost-rsa-chain.pem&quot;</span><br><span class="line">                         type=&quot;RSA&quot; /&gt;</span><br><span class="line">        &lt;/SSLHostConfig&gt;</span><br><span class="line">    &lt;/Connector&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector protocol=&quot;AJP/1.3&quot;</span><br><span class="line">               address=&quot;::1&quot;</span><br><span class="line">               port=&quot;8009&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    &lt;!-- Tomcat内部有4个级别的容器，分别是Engine、Host、Context和Wrapper。Engine代表全局Servlet引          擎，每个Service组件只能包含一个Engine容器组件，但Engine组件可以包含若干Host容器组件 </span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;!-- An Engine represents the entry point (within Catalina) that processes</span><br><span class="line">         every request.  The Engine implementation for Tomcat stand alone</span><br><span class="line">         analyzes the HTTP headers included with the request, and passes them</span><br><span class="line">         on to the appropriate Host (virtual host).</span><br><span class="line">         Documentation at /docs/config/engine.html --&gt;</span><br><span class="line">      </span><br><span class="line">    &lt;!-- You should set jvmRoute to support load-balancing via AJP ie :</span><br><span class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;jvm1&quot;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--For clustering, please take a look at documentation at:</span><br><span class="line">          /docs/cluster-howto.html  (simple how to)</span><br><span class="line">          /docs/config/cluster.html (reference documentation) --&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;</span><br><span class="line">      --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords</span><br><span class="line">           via a brute-force attack --&gt;</span><br><span class="line">      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;!-- This Realm uses the UserDatabase configured in the global JNDI</span><br><span class="line">             resources under the key &quot;UserDatabase&quot;.  Any edits</span><br><span class="line">             that are performed against this UserDatabase are immediately</span><br><span class="line">             available for use by the Realm.  --&gt;</span><br><span class="line">        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName=&quot;UserDatabase&quot;/&gt;</span><br><span class="line">      &lt;/Realm&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 配置虚拟主机，可以配置多个--&gt;</span><br><span class="line">      &lt;!-- 一个Host下面可以有多个Context，也就是可以部署多个Webapp应用,一个webapp对应一个Context,用不同的ContextPath区分 </span><br><span class="line">      --&gt;</span><br><span class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</span><br><span class="line">            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- SingleSignOn valve, share authentication between web applications</span><br><span class="line">             Documentation at: /docs/config/valve.html --&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Access log processes all example.</span><br><span class="line">             Documentation at: /docs/config/valve.html</span><br><span class="line">             Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;</span><br><span class="line">        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Host下面也可以配置Context相关的配置 --&gt;</span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-访问日志配置">4.2 访问日志配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tomcat 默认&lt;value&gt;</span><br><span class="line">&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>具体的日志产生样式说明如下(从官方文档中摘录)：<br>%a - 远端IP地址<br>%A - 本地IP地址<br>%b - 发送的字节数，不包括HTTP头，如果为0，使用&quot;－&quot;<br>%B - 发送的字节数，不包括HTTP头<br>%h - 远端主机名(如果resolveHost=false，远端的IP地址）<br>%H - 请求协议<br>%l - 从identd返回的远端逻辑用户名（总是返回 ‘-’）<br>%m - 请求的方法（GET，POST，等）<br>%p - 收到请求的本地端口号<br>%q - 查询字符串(如果存在，以 ‘?‘开始)<br>%r - 请求的第一行，包含了请求的方法和URI<br>%s - 响应的状态码<br>%S - 用户的session ID<br>%t - 日志和时间，使用通常的Log格式<br>%u - 认证以后的远端用户（如果存在的话，否则为’-’）<br>%U - 请求的URI路径<br>%v - 本地服务器的名称<br>%D - 处理请求的时间，以毫秒为单位<br>%T - 处理请求的时间，以秒为单位另外还可以将cookie, 客户端请求中带的HTTP头(incoming header), 会话(session)或是ServletRequest中的数据都写到Tomcat的访问日志中，你可以用下面的语法来引用。<br>%{xxx}i – 记录客户端请求中带的HTTP头xxx(incoming headers)<br>%{xxx}c – 记录特定的cookie xxx<br>%{xxx}r – 记录ServletRequest中的xxx属性(attribute)<br>%{xxx}s – 记录HttpSession中的xxx属性(attribute)</p></blockquote><h4 id="span-style-color-red-※-工作环境-优化-日志记录-※-span"><span style="color:red;">※&lt;工作环境&gt; 优化-日志记录 ※</span></h4><ul><li><p>这里设置的是 localhost_access_log.Y-M-D.txt 的格式。</p><p><code>vim /usr/local/tomcat8/conf/server.xml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b &amp;quot;%&#123;Referer&#125;i&amp;quot; &amp;quot;%&#123;User-Agent&#125;i&amp;quot; &amp;quot;%&#123;X-Forwarded-For&#125;i&amp;quot; %T&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li><code>&amp;quot;</code> 为双引号</li></ul></li></ul><h3 id="4-3-虚拟主机">4.3 虚拟主机</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;Tomcat&quot;&gt;Tomcat&lt;/h1&gt;
&lt;p&gt;Tomcat最初是由Sun的软件架构师詹姆斯·邓肯·戴维森开发的。后来他帮助将其变为开源项目，并由Sun贡献给Apache软</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx 学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/c1020521.html"/>
    <id>https://blog.halfsummer.xyz/posts/c1020521.html</id>
    <published>2023-03-13T23:16:34.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Nginx">Nginx</h1><h2 id="1）概述">1）概述</h2><ul><li><p>Nginx 四个发行版</p><ol><li><p>Nginx 开源版</p><p><a href="https://nginx.org">https://nginx.org</a></p></li><li><p>Nginx 商业版</p><p><a href="https://www.nginx.com/">https://www.nginx.com/</a></p></li><li><p>Openresty</p><p><a href="https://openresty.org/">https://openresty.org/</a></p></li><li><p>Tengine</p><p><a href="https://tengine.taobao.org/">https://tengine.taobao.org/</a></p></li></ol></li></ul><h2 id="2）安装">2）安装</h2><h3 id="2-1-yum安装">2.1 yum安装</h3><ol><li><p>添加yum源并执行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加yum源</span></span><br><span class="line">[root@localhost ~]# rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看yum源</span></span><br><span class="line">[root@localhost ~]# yum repolist</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有nginx版本</span></span><br><span class="line">[root@localhost ~]# yum list nginx --showduplicates</span><br></pre></td></tr></table></figure></li><li><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本安装（举例）</span></span><br><span class="line">[root@localhost ~]# yum -y install nginx-1.18.0-2.el7.ngx</span><br></pre></td></tr></table></figure></li><li><p>服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">[root@localhost ~]# systemctl enable nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">[root@localhost ~]# systemctl start nginx</span><br></pre></td></tr></table></figure></li><li><p>防火墙放行端口：(22端口记得放开)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放行80端口</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新载入防火墙</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-编译安装">2.2 编译安装</h3><ol><li><p>安装依赖</p><p>a.安装 c语言编译器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提示</span></span><br><span class="line">checking for OS</span><br><span class="line">+ Linux 3.10.0-693.el7.x86_64 x86_64</span><br><span class="line">checking for C compiler ... not found</span><br><span class="line">./configure: error: C compiler cc is not found</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y gcc</span><br></pre></td></tr></table></figure><p>b.安装perl库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure: error: the HTTP rewrite module requires the PCRE library.</span><br><span class="line">You can either disable the module by using --without-http_rewrite_module</span><br><span class="line">option, or install the PCRE library into the system, or build the PCRE library</span><br><span class="line">statically from the source with nginx by using --with-pcre=&lt;path&gt; option.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><p>c.安装zlib库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure: error: the HTTP gzip module requires the zlib library.</span><br><span class="line">You can either disable the module by using --without-http_gzip_module</span><br><span class="line">option, or install the zlib library into the system, or build the zlib library</span><br><span class="line">statically from the source with nginx by using --with-zlib=&lt;path&gt; option.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></li><li><p>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# wget http://nginx.org/download/nginx-1.8.0.tar.gz</span><br><span class="line">[root@localhost ~]# tar -zxvf nginx-1.8.0.tar.gz &amp;&amp; cd nginx-1.8.0</span><br></pre></td></tr></table></figure></li><li><p>配置安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nginx-1.8.0]# ./configure --prefix=/usr/local/nginx</span><br><span class="line">[root@localhost nginx-1.8.0]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>创建服务脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - web server</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">ExecQuit=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>重新加载系统服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>防火墙放行端口：(22端口记得放开)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放行80端口</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新载入防火墙</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-Docker安装">2.3 Docker安装</h3><h2 id="3）控制命令">3）控制命令</h2><p>创建脚本服务前，需进入安装的目录 <code>/usr/local/nginx/sbin</code>去启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/nginx/sbin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">[root@localhost sbin]# ./nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">快速停止</span></span><br><span class="line">[root@localhost sbin]# ./nginx -s stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">优雅关闭，在退出前完成已经接受的连接请求</span></span><br><span class="line">[root@localhost sbin]# ./nginx -s quit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置</span></span><br><span class="line">[root@localhost sbin]# ./nginx -s reload</span><br></pre></td></tr></table></figure><p>配置服务后可以直接用systemctl控制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动nginx</span></span><br><span class="line">[root@localhost ~]# systemctl start nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">[root@localhost ~]# systemctl enable nginx</span><br></pre></td></tr></table></figure><h2 id="4）文件结构">4）文件结构</h2><ul><li><p>进入nginx的主目录下</p><ul><li>yum安装在 <code>/etc/nginx</code></li><li>编译安装一般设置在 <code>/usr/local/nginx</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Nginx] --&gt;  B1[conf];</span><br><span class="line">    A[Nginx] --&gt;  B2[html];</span><br><span class="line">    A[Nginx] --&gt;  B3[sbin];</span><br><span class="line">    subgraph 用来存放配置相关文件</span><br><span class="line">    B1 --&gt; |主配置文件|C1[nginx.conf]</span><br><span class="line">    B1 --&gt; C2[conf.d] --&gt; D1[default.conf]</span><br><span class="line">    end</span><br><span class="line">    subgraph 用来存放静态文件的默认目录</span><br><span class="line">    B2 --&gt; C4[html]</span><br><span class="line">    B2 --&gt; C5[css]</span><br><span class="line">    end</span><br><span class="line">    subgraph Nginx的主程序</span><br><span class="line">    B3 --&gt; C3[nginx]</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="5）基本运行原理">5）基本运行原理</h2><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230111210829971.png" alt="image-20230111210829971"></p><h2 id="6）基本配置">6）基本配置</h2><p><code>/etc/nginx/ngnix.conf</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="comment"># 为1时，表示开启一个业务进程。相当使用一个进程。</span></span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/<span class="literal">error</span>.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># 单个业务进程可接受连接数</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># 引入http mime类型</span></span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="comment"># 如果mime类型没匹配上，默认使用二进制流的方式传输。</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用linux的sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。</span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># 监听端口号</span></span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 匹配路径</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 文件根目录</span></span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="comment"># 默认页名称</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment"># 报错编码对应页面</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>servername</p><ul><li><p>我们可以在同一servername中匹配多个域名，以空格分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name www.xxx.com vlog.xyz.com;</span><br></pre></td></tr></table></figure></li><li><p>通配符匹配</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span> <span class="regexp">*.xxx.com</span> <span class="regexp">vlog.*</span>;</span><br></pre></td></tr></table></figure></li><li><p>正则匹配</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span> ~^[<span class="number">0</span>-<span class="number">9</span>]+\.mmban\.com$;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="7）反向代理">7）反向代理</h2><ul><li><p>概念</p><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230111230501485.png" alt="image-20230111230501485"></p></li><li><p>语法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> &lt;协议&gt;://&lt;地址 | 域名&gt;[:port];</span><br></pre></td></tr></table></figure></li><li><p>eg.</p><p><span style="color:red;"><strong>注意：反向代理时要把协议写全<code>https://</code></strong></span></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>https://baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">    <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>同宿主机下不同容器的代理</p><p>在容器中使用时应该进入容器中查看<code>cat /etc/hosts</code>下的地址（docker为容器创建的地址）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@docker_test conf.d]# docker exec -it tomcat /bin/bash</span><br><span class="line">root@d69eb116a23c:/usr/local/tomcat# cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.3      d69eb116a23c# 此地址就是docker为tomcat容器创建的地址</span><br></pre></td></tr></table></figure><p>改为<code>proxy_pass172.17.0.3:8080;</code>即可生效。</p></li></ul><p>​</p></li><li><p>基于反向代理的负载均衡</p><p>配置一组服务器 httpds 对应了 proxy_pass 里的字符，意思是给这组服务器取个别名</p><p><u>默认情况</u>下使用<span style="color:blue;">轮询</span>方式，逐一转发，这种方式适用于无状态请求。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> httpds &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.206.101:80</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.206.102:80</span>;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>https://httpds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>负载均衡策略</p><p>a.<strong>weight</strong> 权重</p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p><span style="color:grey;"><em>down、backup 其实实际运用中是很少使用的。</em></span></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> httpds &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.206.101:80</span> weight=<span class="number">5</span> down;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.206.102:80</span> weight=<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.206.103:80</span> weight=<span class="number">2</span> backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>down：表示此服务器下线，不参与负载均衡。（用于临时服务器有故障时，手动停止）</p></li><li><p>backup：表示只作为备用。</p></li></ol><p><em>b.ip_hash (不常用)</em></p><p><em>指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。</em></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver &#123;</span><br><span class="line">ip_hash;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.206.101:80</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.206.102:80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：</em></p><ol><li><em>在nginx版本1.3.1之前，不能在ip_hash中使用权重（weight）。</em></li><li><em>ip_hash不能与backup同时使用。</em></li><li><em>此策略适合有状态服务，比如session。当有服务器需要剔除，必须手动down掉。</em></li></ol><p><em>c.least_conn (不常用)</em></p><p><em>把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</em></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态服务器组</span></span><br><span class="line"><span class="section">upstream</span> dynamic_zuoyu &#123;</span><br><span class="line">least_conn; <span class="comment">#把请求转发给连接数较少的后端服务器</span></span><br><span class="line"><span class="attribute">server</span> localhost:<span class="number">8080</span> weight=<span class="number">2</span>; <span class="comment">#tomcat 7.0</span></span><br><span class="line"><span class="attribute">server</span> localhost:<span class="number">8081</span>; <span class="comment">#tomcat 8.0</span></span><br><span class="line"><span class="attribute">server</span> localhost:<span class="number">8082</span> backup; <span class="comment">#tomcat 8.5</span></span><br><span class="line"><span class="attribute">server</span> localhost:<span class="number">8083</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">20s</span>; <span class="comment">#tomcat 9.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意：此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</em></p><p><em>d.url_hash (不常用)</em></p><p><em>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</em></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line"><span class="attribute">hash</span> &amp;request_uri;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.200.146:9001</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.200.146:9002</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">192.168.200.146:9003</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">8083</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"><span class="section">location</span> /&#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>e.fair（第三方） (不常用)</em></p><p><em>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</em></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backserver &#123;</span><br><span class="line"><span class="attribute">server</span> server1;</span><br><span class="line"><span class="attribute">server</span> server2;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><span style="color:orange;"><strong>反向代理时遇到的问题</strong></span></p><ol><li><p>在部署 tomcat 时，Apache可能不能链接网络导致不能实现代理。</p><p>修改SElinux策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">错误</span></span><br><span class="line">*140 connect() to 127.0.0.1:8080 failed (13: Permission denied) while connecting to upstream, client: 192.168.128.1, server: 192.168.128.130, request: &quot;GET / HTTP/1.1&quot;, upstream: &quot;http://127.0.0.1:8080/&quot;, host: &quot;192.168.128.130&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决办法 也可以关闭SElinux</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-P 为写入配置文件</span></span><br><span class="line">setsebool -P httpd_can_network_connect 1</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="8）动静分离">8）动静分离</h2><ul><li><p>概念</p><p>在Web开发中，通常来说，动态资源其实就是指那些后台资源，而静态资源就是指HTML，JavaScript，CSS，img等文件。</p><p>一般来说，都需要将动态资源和静态资源分开，将静态资源部署在Nginx上，当一个请求来的时候，如果是静态资源的请求，就直接到nginx配置的静态资源目录下面获取资源，如果是动态资源的请求，nginx利用反向代理的原理，把请求转发给后台应用去处理，从而实现动静分离。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/a2de4b09c680cebff8e64030329f95d1.jpeg@wm_2,t_55m+5a625Y+3L+e+suWSjOaXtuS7ow==,fc_ffffff,ff_U2ltSGVp,sz_22,x_14,y_14" alt="img"></p></li><li><p>语法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> &lt;协议&gt;://&lt;ip&gt;[:port];</span><br></pre></td></tr></table></figure></li><li><p>eg.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置反向代理</span></span><br><span class="line"><span class="comment"># 把主页的html挂载在tomcat上</span></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:8080;<span class="comment"># tomcat 的服务端口8080</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动静分离</span></span><br><span class="line"><span class="comment"># 把 css、img、js 放到本地nginx上</span></span><br><span class="line"><span class="section">location</span> ~*/(css|img|js) &#123;</span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line"><span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="9）URL-Rewrite">9）URL Rewrite</h2><ul><li><p>概念</p><p>URL Rewrite即URL重写，就是把传入Web的请求重定向到其他URL的过程。URL Rewrite最常见的应用是URL伪静态化，是将动态页面显示为静态页面方式的一种技术。比如<code>http://www.123.com/news/index.asp?id=123</code> 使用UrlRewrite转换后可以显示为<code>http://www.123.com/news/123.html</code>。</p></li><li><p>语法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rewrite</span> &lt;regex&gt; &lt;replacement&gt; [flag];</span><br></pre></td></tr></table></figure><ul><li><p>flag标记说明：</p><p>last #本条规则匹配完成后，继续向下匹配新的location URI规则。<br><strong>break #本条规则匹配完成即终止，不再匹配后面的任何规则。</strong><br>redirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址。<br>permanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址。</p></li></ul></li><li><p>eg.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/([0-9]+).html$</span> /index.jsp?pageNum=<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:8080;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​</p><h2 id="10）防盗链">10）防盗链</h2><ul><li><p>概念</p><p>盗链是指服务提供商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面（如广告），直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。</p></li><li><p>refer模块防盗</p><p>Nginx 用于实现防盗链功能的模块为 refer 模块,其依据的原理是: 如果网站盗用了你的图片，那么用户在点击或者查看这个盗链内容时，发送 http 请求的头部中的 referer 字段将为该盗版网站的 url。这样我们通过获取这个头部信息，知道 http 发起请求的页面，然后判断这个地址是否是我们的合法页面，不是则判断为盗链。</p><ul><li><p>语法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> 域名<span class="number">1</span>[ 域名<span class="number">2</span>][ 域名...];</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>valid_referers 指令，它后面可以带上多个参数，表示多个 referer 头都是有效的。它的参数形式有:</p><ul><li>none: 允许缺失 referer 头部的请求访问。</li><li>blocked: 有 referer 这个字段，但是其值被防火墙或者是代理给删除了。</li><li>server_names: 若 referer 中的站点域名和 server_names 中的某个域名匹配，则允许访问。</li><li>任意字符或者正则表达式。</li></ul></li></ul></li><li><p>secure_link模块防盗 <a href="https://zhuanlan.zhihu.com/p/463197529">参考文献</a></p><p>前面这种简单检查 referer 头部值的防盗链方法过于脆弱，盗用者很容易通过伪造 referer 的值轻而易举跳过防盗措施。在 Nginx 中有一种更为高级的防盗方式，即基于 secure_link 模块，该模块能够检查请求链接的权限以及是否过期，多用于下载服务器防盗链。这个模块默认未编译进 Nginx，需要在源码编译时候使用 --with-secure_link_module 添加。</p><p>该模块的通过验证 URL 中的哈希值的方式防盗链。它的防盗过程如下：</p><ul><li><p>由服务器或者 Nginx 生成安全的加密后的 URL, 返回给客户端。</p></li><li><p>客户端使用安全的 URL 访问 Nginx，获取图片等资源，由 Nginx 的 secure_link 变量判断是否验证通过。</p></li><li><p>eg.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* .(gif|jpg|png|swf|flv|mp4)$</span>  &#123;</span><br><span class="line">    <span class="attribute">secure_link</span> <span class="variable">$arg_md5</span>,<span class="variable">$arg_expires</span>;</span><br><span class="line">    <span class="attribute">secure_link_md5</span> <span class="string">&quot;<span class="variable">$secure_link_expires</span><span class="variable">$uri</span><span class="variable">$remote_addr</span> secret&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 空字符串，校验不通过</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$secure_link</span> = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间过期</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$secure_link</span> = <span class="string">&quot;0&quot;</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">410</span> <span class="string">&quot;URL过期，请重新生成&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">root</span> /root/test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="11）高可用性">11）高可用性</h2><p><strong>Keepalived</strong></p><ul><li><p>概念</p><p>**“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。Nginx配合Keepalived可以实现高可用，实现双机热备+自动切换。**这种操作在现在的集群系统中，比较的常见，通过keepalived和redis实现热备份的；和mysql实现的，类似的案例挺多。</p></li><li><p>安装</p><ul><li><p>yum安装</p><ol><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y keepalived</span><br></pre></td></tr></table></figure></li></ol></li><li><p>编译安装</p><ol><li><p>下载并上传到服务器：</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.keepalived.org%2Fdownload.html">https://www.keepalived.org/download.html</a></p></li><li><p>按实际版本解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -zxvf keepalived-2.0.18.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure: error:</span><br><span class="line">!!! OpenSSL is not properly installed on your system. !!!</span><br><span class="line">!!! Can not include OpenSSL headers files. !!!</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install openssl-devel</span><br></pre></td></tr></table></figure></li><li><p>安装三部曲</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到解压的文件中</span></span><br><span class="line">[root@localhost ~]# ./configure</span><br><span class="line">[root@localhost ~]# make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>eg. 主从模式</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/12b5b907846745f29ad5b466dc86b01a.png" alt="在这里插入图片描述"></p><blockquote><p>试验场景说明：</p><p>1）在两台服务器上分别安装 nginx 和 keepalived</p><p>2）本次主要配置 nginx 高可用(主从模式)，只考虑 nginx 存活及访问问题</p><p>3）实际访问时使用 keepalived 虚拟 IP进行访问</p></blockquote><ol><li><p>准备测试机器</p><table><thead><tr><th><strong>主机</strong></th><th><strong>ip</strong></th><th><strong>环境</strong></th></tr></thead><tbody><tr><td>Nginx01 (maste)</td><td>192.168.169.151</td><td>CentOS Linux release 7.9.2009 (Core)<br/>keepalived-1.3.5<br/>nginx/1.8.1</td></tr><tr><td>Nginx02 (backup)</td><td>192.168.169.152</td><td>CentOS Linux release 7.9.2009 (Core)<br/>keepalived-1.3.5<br/>nginx/1.8.1</td></tr><tr><td>web</td><td>192.168.169.150</td><td>tomcat</td></tr></tbody></table></li><li><p>两台机器上都安装keepalived</p></li><li><p>修改主机(master)配置文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 Keepalived 配置文件，将原本的 keepalived.conf 文件备份，新建 keepalived.conf 文件加入如下内容</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line"><span class="comment"># 注意：这个是 master(主机) 的配置文件</span></span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived<span class="comment"># 这一行为注释</span></span><br><span class="line">global_defs &#123; </span><br><span class="line">router_id nginx01<span class="comment"># router_id 机器标识，通常使用 hostname，相对具有唯一性，和备机区分开，不能使用同一个标识</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;<span class="comment"># 定义一个检测脚本，在global_defs之外配置</span></span><br><span class="line">  script <span class="string">&quot;/etc/keepalived/check_nginx.sh&quot;</span><span class="comment"># 自己写的监测脚本</span></span><br><span class="line">  interval <span class="number">2</span><span class="comment"># 每2s监测一次</span></span><br><span class="line">  weight <span class="number">10</span><span class="comment"># 该参数用于指定当监测失效时，该设备的优先级会减少的值，该值为负表示减少</span></span><br><span class="line">  fall <span class="number">2</span>        <span class="comment"># 尝试两次都成功才成功</span></span><br><span class="line">  rise <span class="number">2</span>        <span class="comment"># 尝试两次都失败才失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;<span class="comment"># 定义一个vrrp_install实例，名称为VI_1</span></span><br><span class="line">state MASTER<span class="comment"># 表示该实例的角色状态，有MASTER和BACKUP两种主备状态</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ens33</span># 对外提供服务的网络接口，注意修改为自己的网卡名称，如 <span class="title">ens33</span>,<span class="title">eth0</span>,<span class="title">eth1</span></span></span><br><span class="line"><span class="class"><span class="title">virtual_router_id</span> 51# 虚拟路由<span class="title">ID</span>标识，主备服务器配置中相同实例的<span class="title">ID</span>必须一致</span></span><br><span class="line"><span class="class"><span class="title">priority</span> 150# <span class="title">priority</span>表示实例优先级，数字越大，优先级越高。<span class="title">master</span> 的优先级必须大于 <span class="title">backup</span></span></span><br><span class="line"><span class="class"><span class="title">advert_int</span> 1# 设定 <span class="title">master</span> 与 <span class="title">backup</span> 负载均衡器之间同步检查的时间间隔，默认是秒</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">authentication</span> </span>&#123;<span class="comment"># 权限认证配置</span></span><br><span class="line">auth_type PASS<span class="comment"># 主要有 PASS 和 AH 两种</span></span><br><span class="line">auth_pass <span class="number">1111</span><span class="comment"># 验证密码，同一个 vrrp_instance 下 MASTER 和 BACKUP 密码必须相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line"><span class="number">192.168</span>.<span class="number">169.200</span><span class="comment"># 虚拟IP地址；可以配置多个IP，每个IP占一行。注意，这里的IP就是在工作中访问 zabbix server 需要和域名绑定的ip</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">track_script &#123;<span class="comment"># 调用自定义的脚本</span></span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">notify_master /etc/keepalived/to_master.sh<span class="comment"># 指定当切换到 master 时，执行的脚本，即切换到 master 时要将 backup 的 server 关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>主机切换脚本 <code>to_master.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/keepalived/to_master.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定当切换到 master 时，执行的脚本，即切换到 master 时要将 backup 的 server 关掉</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sshpass -p 0 ssh -o StrictHostKeyChecking=no root@192.168.169.152 &quot;nginx -s stop&quot;</span><br><span class="line"></span><br><span class="line">nginx</span><br></pre></td></tr></table></figure></li></ul></li><li><p>备用机配置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：这个是 master(备机) 的配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/keepalived/keepalived.conf</span></span><br><span class="line"></span><br><span class="line">! Configuration File <span class="keyword">for</span> keepalived<span class="comment"># 这一行为注释</span></span><br><span class="line">global_defs &#123; </span><br><span class="line">router_id nginx02<span class="comment"># router_id 机器标识，通常使用 hostname，相对具有唯一性，和主机区分开，不能使用同一个标识</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_nginx &#123;<span class="comment"># 定义一个检测脚本，在global_defs之外配置</span></span><br><span class="line">  script <span class="string">&quot;/etc/keepalived/check_nginx.sh&quot;</span><span class="comment"># 自己写的监测脚本</span></span><br><span class="line">  interval <span class="number">2</span><span class="comment"># 每2s监测一次</span></span><br><span class="line">  weight <span class="number">10</span><span class="comment"># 该参数用于指定当监测失效时，该设备的优先级会减少的值，该值为负表示减少</span></span><br><span class="line">  fall <span class="number">2</span>        <span class="comment"># 尝试两次都成功才成功</span></span><br><span class="line">  rise <span class="number">2</span>        <span class="comment"># 尝试两次都失败才失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;<span class="comment"># 定义一个vrrp_install实例，名称为VI_1</span></span><br><span class="line">state BACKUP<span class="comment"># 表示该实例的角色状态，有MASTER和BACKUP两种主备状态</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ens33</span># 对外提供服务的网络接口，注意修改为自己的网卡名称，如 <span class="title">ens33</span>,<span class="title">eth0</span>,<span class="title">eth1</span></span></span><br><span class="line"><span class="class"><span class="title">virtual_router_id</span> 51# 虚拟路由<span class="title">ID</span>标识，主备服务器配置中相同实例的<span class="title">ID</span>必须一致</span></span><br><span class="line"><span class="class"><span class="title">priority</span> 149# <span class="title">priority</span>表示实例优先级，数字越大，优先级越高。<span class="title">master</span> 的优先级必须大于 <span class="title">backup</span></span></span><br><span class="line"><span class="class"><span class="title">advert_int</span> 1# 设定 <span class="title">master</span> 与 <span class="title">backup</span> 负载均衡器之间同步检查的时间间隔，默认是秒</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">authentication</span> </span>&#123;<span class="comment"># 权限认证配置</span></span><br><span class="line">auth_type PASS<span class="comment"># 主要有 PASS 和 AH 两种</span></span><br><span class="line">auth_pass <span class="number">1111</span><span class="comment"># 验证密码，同一个 vrrp_instance 下 MASTER 和 BACKUP 密码必须相同</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_ipaddress &#123;</span><br><span class="line"><span class="number">192.168</span>.<span class="number">169.200</span><span class="comment"># 虚拟IP地址；可以配置多个IP，每个IP占一行。注意，这里的IP就是在工作中访问 zabbix server 需要和域名绑定的ip</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">track_script &#123;<span class="comment"># 调用自定义的脚本</span></span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">notify_master /etc/keepalived/to_backup.sh<span class="comment"># 指定当切换到 backup 时，执行的脚本，切换到 backup 时将 master 的 server 关掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>备机切换脚本 <code>to_backup.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/keepalived/to_backup.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定当切换到 backup 时，执行的脚本，切换到 backup 时将 master 的 server 关掉</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sshpass -p 0 ssh -o StrictHostKeyChecking=no root@192.168.169.151 &quot;nginx -s stop&quot;</span><br><span class="line"></span><br><span class="line">nginx</span><br></pre></td></tr></table></figure></li></ul></li><li><p>服务器检查脚本（主从上都需添加）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/keepalived/chk_nginx.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span> </span><br><span class="line"></span><br><span class="line">A=`ps -C nginx --no-header |wc -l` </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断nginx是否宕机，如果宕机了，尝试重启</span> </span><br><span class="line">if [ $A -eq 0 ];then </span><br><span class="line">  /usr/local/nginx/sbin/nginx </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">等待一小会再次检查nginx，如果没有启动成功，则停止keepalived，使其启动备用机</span> </span><br><span class="line">  sleep 3 </span><br><span class="line">  if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then </span><br><span class="line">    killall keepalived </span><br><span class="line">  fi </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加运行权限</span></span><br><span class="line">[root@localhost ~]# chmod +x /etc/keepalived/chk_nginx.sh</span><br></pre></td></tr></table></figure></li><li><p>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl restart keepalived</span><br><span class="line">[root@localhost ~]# systemctl enable keepalived</span><br></pre></td></tr></table></figure></li><li><p>修改主备 nginx 配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span>  <span class="number">192.168.169.200</span>;<span class="comment"># 这里是使用虚拟 IP 访问</span></span><br><span class="line"></span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span>  http://192.168.169.150:8080;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="12）Https-证书配置">12）Https 证书配置</h2><ul><li><p>概念</p><p>SSL 证书，也称为 SSL 服务器证书，是遵守 SSL 协议的一种数字证书，由全球信任的证书颁发机构 (CA) 验证服务器身份后颁发，将 SSL 证书安装在网站服务器上，会激活挂锁和 https 协议。SSL 证书解决了网民登录网站的信任问题，网民可以通过 SSL 证书轻松识别网站的是否受到保护、是否安全的。</p></li><li><p>配置</p><ol><li><p>申请、下载证书</p><p>（申请略）</p><p>下载后的证书包含：</p><ul><li>pem：证书文件。PEM文件的扩展名为CRT格式。</li><li>key：证书的密钥文件。申请证书时如果未选择自动创建CRS，则下载的证书文件压缩包中不会包含.key文件，需要您将自己手动常见的私钥文件拷贝到cert目录下。</li></ul></li><li><p>上传证书到ssl目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd usr/local/nginx/conf</span><br><span class="line">[root@localhost ~]# mkdir cert</span><br></pre></td></tr></table></figure></li><li><p>更改nginx.conf设置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">localhost</span> ~]<span class="comment"># vi nginx.conf</span></span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost; <span class="comment">#localhost修改为证书绑定的域名</span></span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$&#123;server_name&#125;</span><span class="variable">$1</span> <span class="literal">permanent</span>; <span class="comment">#设置http自动转发https</span></span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;<span class="comment">#设置SSL功能</span></span><br><span class="line">    <span class="attribute">server_name</span> localhost;  <span class="comment">#localhost修改为证书绑定的域名</span></span><br><span class="line">    <span class="attribute">root</span> html;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> cert/xxxx.pem;   <span class="comment">#证书的文件名</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> cert/domain name.key;   <span class="comment">#证书的密钥文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl restart nginx</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>p51 <a href="https://www.bilibili.com/video/BV1yS4y1N76R?p=51&amp;vd_source=dbe149b93870e38dfa3d70bb07d82b6e">https://www.bilibili.com/video/BV1yS4y1N76R?p=51&amp;vd_source=dbe149b93870e38dfa3d70bb07d82b6e</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;Nginx&quot;&gt;Nginx&lt;/h1&gt;
&lt;h2 id=&quot;1）概述&quot;&gt;1）概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Nginx 四个发行版&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;N</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis 学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/fa17c65a.html"/>
    <id>https://blog.halfsummer.xyz/posts/fa17c65a.html</id>
    <published>2023-03-13T23:16:24.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Redis">Redis</h1><h2 id="一、Redis-入门">一、Redis 入门</h2><p>redis是一个key-value存储系统（键值数据库）。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><h3 id="1-认识NoSQL">1.认识NoSQL</h3><h4 id="1-1-什么是NoSQL">1.1 什么是NoSQL</h4><ul><li>NoSQL最常见的解释是&quot;<code>non-relational</code>&quot;， 很多人也说它是&quot;<em><strong>Not Only SQL</strong></em>&quot;</li><li>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li><li>区别于关系数据库，它们不保证关系数据的ACID特性</li><li>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li><li>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</li></ul><h4 id="1-2-NoSQL与SQL-的差异">1.2 NoSQL与SQL 的差异</h4><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230122163012631.png" alt="image-20230122163012631"></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">SQL</th><th style="text-align:center">NoSQL</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">结构化</td><td style="text-align:center">非结构化</td></tr><tr><td style="text-align:center">数据关联</td><td style="text-align:center">关联的</td><td style="text-align:center">无关联的</td></tr><tr><td style="text-align:center">查询方式</td><td style="text-align:center">SQL查询</td><td style="text-align:center">非SQL</td></tr><tr><td style="text-align:center">事务特性</td><td style="text-align:center">ACID</td><td style="text-align:center">BASE</td></tr><tr><td style="text-align:center">存储方式</td><td style="text-align:center">磁盘</td><td style="text-align:center">内存</td></tr><tr><td style="text-align:center">扩展性</td><td style="text-align:center">垂直</td><td style="text-align:center">水平</td></tr><tr><td style="text-align:center">使用场景</td><td style="text-align:center">1）数据结构固定 <br />2）相关业务对数据安全性、一致性要求较高</td><td style="text-align:center">1）数据结构不固定 <br />2）对一致性、安全性要求不高 <br />3）对性能要求</td></tr></tbody></table><h3 id="2-认识Redis">2.认识Redis</h3><blockquote><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p></blockquote><p><strong>Redis 的特征：</strong></p><ul><li>键值（<code>key-value</code>）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h3 id="3-安装Redis">3.安装Redis</h3><h4 id="3-1-前置准备">3.1 前置准备</h4><blockquote><p>本次安装Redis是基于Linux系统下安装的，因此需要一台Linux服务器或者虚拟机。</p><p>请提前开放<code>6379</code>端口，避免后续出现的莫名其妙的错误！</p></blockquote><p>官网 <a href="https://redis.io/">https://redis.io/</a></p><h4 id="3-2-安装Redis依赖">3.2 安装Redis依赖</h4><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h4 id="3-3-安装Redis">3.3 安装Redis</h4><p>把<code>redis-6.2.6.tar.gz</code>压缩包放入<code>/usr/local/</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/</span><br><span class="line">tar -zxvf redis-6.2.6.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>(小知识:<code>make PREFIX=/usr/local/redis-6.2.6/bin install</code>.这里多了一个关键字 <strong><code>PREFIX=</code></strong> 这个关键字的作用是编译的时候用于指定程序存放的路径，假设不添加该关键字Linux会将可执行文件存放在/usr/local/bin目录。)</p><p><strong>安装成功后打开/usr/local/bin目录（该目录为Redis默认的安装目录）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]<span class="comment"># cd /usr/local/bin</span></span><br><span class="line">[root@loaclhost bin]<span class="comment"># ls</span></span><br><span class="line">redis-benchmark  redis-check-aof  redis-check-rdb  redis-cli  redis-sentinel  redis-server</span><br></pre></td></tr></table></figure><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行Redis命令</p><h3 id="4-配置Redis">4.配置Redis</h3><p><strong>备份并格式化配置文件：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis配置简化</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /usr/local/redis-6.2.6/redis.conf /usr/local/redis-6.2.6/redis.conf.bak</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed  -i  &#x27;/^#/d; /^$/d&#x27; /usr/local/redis-6.2.6/redis.conf      #把配置文件中#和空格删除掉</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir /mydata/redis</span></span><br></pre></td></tr></table></figure><p><strong>Redis配置更改：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /usr/local/redis-6.2.6/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0<span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问。生产环境,尽量不要监听所有网卡ip(0.0.0.0)</span></span><br><span class="line">port 6379<span class="comment"># 监听的端口</span></span><br><span class="line"><span class="built_in">dir</span> /mydata/redis<span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line">pidfile <span class="string">&quot;redis.pid&quot;</span></span><br><span class="line">logfile <span class="string">&quot;redis.log&quot;</span><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">daemonize <span class="built_in">yes</span><span class="comment"># 守护进程，修改为yes后即可后台运行 </span></span><br><span class="line">databases 16<span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="comment">#maxmemory 512mb# 设置redis能够使用的最大内存</span></span><br><span class="line">requirepass 000588<span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br></pre></td></tr></table></figure><p>Redis启动的系统参数调整:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整最大文件打开数（文件句柄)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/security/limits.conf</span></span><br><span class="line">* - nofile 65535        退出终端重新登录生效</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内核参数修改</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line">net.core.somaxconn = 10240          <span class="comment">#调大somaxconn参数</span></span><br><span class="line">vm.overcommit_memory = 1           <span class="comment">#这个如果没修改，可能会引起redis的数据丢失，参数很重要</span></span><br><span class="line"><span class="comment"># 然后运行sysctl -p 刷新生效</span></span><br></pre></td></tr></table></figure><h3 id="5-启动Redis">5.启动Redis</h3><h4 id="5-1前台启动（不推荐）">5.1前台启动（不推荐）</h4><blockquote><p><strong>这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</strong></p></blockquote><p><strong>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20220524191137983.png" alt="image-20220524191137983"></p><h4 id="5-2后台启动（不推荐）">5.2后台启动（不推荐）</h4><blockquote><p><strong>如果要让Redis以后台方式启动，则必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下</strong></p></blockquote><ul><li><p><strong>启动Redis</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于配置文件启动</span></span><br><span class="line">redis-server /usr/local/redis-6.2.6/redis.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>停止Redis服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="comment"># 通过kill命令直接杀死进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 redis进程<span class="built_in">id</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -a 来指定密码</span></span><br><span class="line">redis-cli -a 132537 shutdown</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-3开机自启（推荐）">5.3开机自启（推荐）</h4><ul><li><p><strong>新建一个系统服务文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p><strong>重载系统服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p><strong>服务命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> redis</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、Redis-客户端">二、Redis 客户端</h2><h3 id="1-命令行客户端">1.命令行客户端</h3><ul><li><strong>Redis安装完成后就自带了命令行客户端：<code>redis-cli</code>，使用方式如下：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p><strong>其中常见的<code>options</code>有：</strong></p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 000588</code>：指定redis的访问密码（如何未指定-a可以交互时使用<code>auth 000588</code>）</li></ul><p><strong>其中的<code>commonds</code>就是Redis的操作命令，例如：</strong></p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20220524201258092.png" alt="image-20220524201258092"></p><h3 id="2-图形化客户端">2.图形化客户端</h3><p><a href="https://github.com/qishibo/AnotherRedisDesktopManager">AnotherRedisDesktopManager</a></p><h2 id="三、Redis-常见命令">三、Redis 常见命令</h2><p><a href="http://www.redis.cn/commands.html">Redis的中文文档</a>  <a href="https://www.runoob.com/redis/redis-keys.html">菜鸟教程官网</a></p><h3 id="1-Redis数据结构介绍">1.Redis数据结构介绍</h3><p><strong>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</strong></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20220524205926164.png" alt="image-20220524205926164"></p><h3 id="2-通用命令">2.通用命令</h3><p><strong>通用指令是部分数据类型的，都可以使用的指令，常见的有如下表格所示</strong></p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">KEYS</td><td style="text-align:center">查看符合模板的所有key，不建议在生产环境设备上使用</td></tr><tr><td style="text-align:center">DEL</td><td style="text-align:center">删除一个指定的key</td></tr><tr><td style="text-align:center">EXISTS</td><td style="text-align:center">判断key是否存在</td></tr><tr><td style="text-align:center">EXPIRE</td><td style="text-align:center">给一个key设置有效期，有效期到期时该key会被自动删除</td></tr><tr><td style="text-align:center">TTL</td><td style="text-align:center">查看一个KEY的剩余有效期</td></tr></tbody></table><p><strong>可以通过<code>help [command] </code>查看命令的具体用法</strong></p><h3 id="3-String类型">3.String类型</h3><p><strong>String类型，也就是字符串类型，是Redis中最简单的存储类型。</strong></p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过<strong>512m</strong>.</p><ul><li><p><strong>String的常见命令有如下表格所示</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">SET</td><td style="text-align:center">添加或者修改已经存在的一个String类型的键值对</td></tr><tr><td style="text-align:center">GET</td><td style="text-align:center">根据key获取String类型的value</td></tr><tr><td style="text-align:center">MSET</td><td style="text-align:center">批量添加多个String类型的键值对</td></tr><tr><td style="text-align:center">MGET</td><td style="text-align:center">根据多个key获取多个String类型的value</td></tr><tr><td style="text-align:center">INCR</td><td style="text-align:center">让一个整型的key自增1</td></tr><tr><td style="text-align:center">INCRBY</td><td style="text-align:center">让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td></tr><tr><td style="text-align:center">INCRBYFLOAT</td><td style="text-align:center">让一个浮点类型的数字自增并指定步长</td></tr><tr><td style="text-align:center">SETNX</td><td style="text-align:center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td></tr><tr><td style="text-align:center"><strong>SETEX</strong></td><td style="text-align:center">添加一个String类型的键值对，并且指定有效期</td></tr></tbody></table></li><li><p><strong>key的结构</strong></p><p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 <code>niurou</code>，有<code>user</code>和<code>product</code>两种不同类型的数据，我们可以这样定义key：</p><ul><li><strong>user</strong>相关的key：<code>niurou:user:1</code></li><li><strong>product</strong>相关的key：<code>niurou:product:1</code></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th style="text-align:center">KEY</th><th style="text-align:center">VALUE</th></tr></thead><tbody><tr><td style="text-align:center">niurou:user:1</td><td style="text-align:center">{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td style="text-align:center">niurou:product:1</td><td style="text-align:center">{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table></li></ul><p>​<img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230123013931744.png" alt="image-20230123013931744"></p><h3 id="4-Hash类型">4.Hash类型</h3><p><strong>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的<code>HashMap</code>结构。</strong></p><ul><li><p><strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</strong></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230123012220605.png" alt="image-20230123012220605"></p></li><li><p><strong>Hash的常见命令有：</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">HSET key field value</td><td style="text-align:center">添加或者修改hash类型key的field的值</td></tr><tr><td style="text-align:center">HGET key field</td><td style="text-align:center">获取一个hash类型key的field的值</td></tr><tr><td style="text-align:center">HMSET</td><td style="text-align:center">hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td></tr><tr><td style="text-align:center">HMGET</td><td style="text-align:center">批量获取多个hash类型key的field的值</td></tr><tr><td style="text-align:center">HGETALL</td><td style="text-align:center">获取一个hash类型的key中的所有的field和value</td></tr><tr><td style="text-align:center">HKEYS</td><td style="text-align:center">获取一个hash类型的key中的所有的field</td></tr><tr><td style="text-align:center">HVALS</td><td style="text-align:center">获取一个hash类型的key中的所有的value</td></tr><tr><td style="text-align:center">HINCRBY</td><td style="text-align:center">让一个hash类型key的字段值自增并指定步长</td></tr><tr><td style="text-align:center">HSETNX</td><td style="text-align:center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr></tbody></table><p>hset 命令:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset niurou:user:3 age 21</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>图形化界面：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230123014206566.png" alt="image-20230123014206566"></p></li></ul><h3 id="5-List类型">5.List类型</h3><p><strong>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</strong></p><p><strong>特征也与<code>LinkedList</code>类似：</strong></p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有:</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">LPUSH key element …</td><td style="text-align:center">向列表左侧插入一个或多个元素</td></tr><tr><td style="text-align:center">LPOP key</td><td style="text-align:center">移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td style="text-align:center"><strong>RPUSH key element …</strong></td><td style="text-align:center">向列表右侧插入一个或多个元素</td></tr><tr><td style="text-align:center">RPOP key</td><td style="text-align:center">移除并返回列表右侧的第一个元素</td></tr><tr><td style="text-align:center">LRANGE key star end</td><td style="text-align:center">返回一段角标范围内的所有元素</td></tr><tr><td style="text-align:center">BLPOP和BRPOP</td><td style="text-align:center">与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr></tbody></table><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/new.gif" alt="new"></p><p><strong>思考：</strong></p><ul><li><strong>如何利用List结构模拟一个栈?</strong><ul><li>先进后出，入口和出口在同一边</li></ul></li><li><strong>如何利用List结构模拟一个队列?</strong><ul><li>先进先出，入口和出口在不同边</li></ul></li><li><strong>如何利用List结构模拟一个阻塞队列?</strong><ul><li>入口和出口在不同边</li><li>出队时采用BLPOP或BRPOP</li></ul></li></ul><h3 id="6-Set类型">6.Set类型</h3><p><strong>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，</strong></p><p><strong>因此具备与HashSet类似的特征：</strong></p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p><strong>Set的常见命令有：</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">SADD key member …</td><td style="text-align:center">向set中添加一个或多个元素</td></tr><tr><td style="text-align:center">SREM key member …</td><td style="text-align:center">移除set中的指定元素</td></tr><tr><td style="text-align:center">SCARD key</td><td style="text-align:center">返回set中元素的个数</td></tr><tr><td style="text-align:center">SISMEMBER key member</td><td style="text-align:center">判断一个元素是否存在于set中</td></tr><tr><td style="text-align:center">SMEMBERS</td><td style="text-align:center">获取set中的所有元素</td></tr><tr><td style="text-align:center">SINTER key1 key2 …</td><td style="text-align:center">求key1与key2的交集</td></tr><tr><td style="text-align:center">SDIFF key1 key2 …</td><td style="text-align:center">求key1与key2的差集</td></tr><tr><td style="text-align:center">SUNION key1 key2 …</td><td style="text-align:center">求key1和key2的并集</td></tr></tbody></table><p><strong>交集、差集、并集图示</strong></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20220525112632214.png" alt="image-20220525112632214"></p><h3 id="7-SortedSet类型">7.SortedSet类型</h3><p><strong>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</strong></p><p><strong>SortedSet具备下列特性：</strong></p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p><strong>SortedSet的常见命令有：</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ZADD key score member</td><td style="text-align:center">添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td style="text-align:center">ZREM key member</td><td style="text-align:center">删除sorted set中的一个指定元素</td></tr><tr><td style="text-align:center">ZSCORE key member</td><td style="text-align:center">获取sorted set中的指定元素的score值</td></tr><tr><td style="text-align:center">ZRANK key member</td><td style="text-align:center">获取sorted set 中的指定元素的排名</td></tr><tr><td style="text-align:center">ZCARD key</td><td style="text-align:center">获取sorted set中的元素个数</td></tr><tr><td style="text-align:center">ZCOUNT key min max</td><td style="text-align:center">统计score值在给定范围内的所有元素的个数</td></tr><tr><td style="text-align:center">ZINCRBY key increment member</td><td style="text-align:center">让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td style="text-align:center">ZRANGE key min max</td><td style="text-align:center">按照score排序后，获取指定排名范围内的元素</td></tr><tr><td style="text-align:center">ZRANGEBYSCORE key min max</td><td style="text-align:center">按照score排序后，获取指定score范围内的元素</td></tr><tr><td style="text-align:center">ZDIFF、ZINTER、ZUNION</td><td style="text-align:center">求差集、交集、并集</td></tr></tbody></table><p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加<code>REV</code>即可</strong></p><h2 id="四、切换数据库">四、切换数据库</h2><p>redis有16个数据库(0-15)，默认使用第一个<code>数据库 0</code>，不同的数据库可以存不同数据。</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">select 编号</td><td style="text-align:center">使用第三个数据库</td></tr><tr><td style="text-align:center">dbsize</td><td style="text-align:center">查看数据库大小</td></tr><tr><td style="text-align:center">flushdb</td><td style="text-align:center">清除当前数据库</td></tr><tr><td style="text-align:center">flushall</td><td style="text-align:center">清除全部数据库</td></tr></tbody></table><h2 id="五、Redis-运维">五、Redis 运维</h2><h3 id="1-Redis端口与进程">1.Redis端口与进程</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># netstat -anput |grep 6379</span></span><br><span class="line">tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      17820/redis-server  </span><br><span class="line">[root@localhost ~]<span class="comment"># ps -ef |grep redis</span></span><br><span class="line">root      17820      1  0 12:17 ?        00:00:00 /usr/local/bin/redis-server 0.0.0.0:6379</span><br></pre></td></tr></table></figure><h3 id="2-Redis日志">2.Redis日志</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tail -f /mydata/redis/redis.log </span></span><br><span class="line">17820:C 08 Nov 2022 12:17:25.366 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">17820:C 08 Nov 2022 12:17:25.366 <span class="comment"># Redis version=6.2.1, bits=64, commit=00000000, modified=0, pid=17820, just started</span></span><br><span class="line">17820:C 08 Nov 2022 12:17:25.366 <span class="comment"># Configuration loaded</span></span><br><span class="line">17820:M 08 Nov 2022 12:17:25.367 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">17820:M 08 Nov 2022 12:17:25.367 * monotonic clock: POSIX clock_gettime</span><br><span class="line">17820:M 08 Nov 2022 12:17:25.368 * Running mode=standalone, port=6379.</span><br><span class="line">17820:M 08 Nov 2022 12:17:25.368 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">17820:M 08 Nov 2022 12:17:25.368 <span class="comment"># Server initialized</span></span><br><span class="line">17820:M 08 Nov 2022 12:17:25.368 <span class="comment"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span></span><br><span class="line">17820:M 08 Nov 2022 12:17:25.368 * Ready to accept connections</span><br></pre></td></tr></table></figure><h3 id="3-查看key">3.查看key</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;RANDOMKEY<span class="comment">#随机获取一个key</span></span><br><span class="line">&gt;KEYS *<span class="comment">#查看所有key，注意阻塞,如果key量特别大时候，容易卡死阻塞，上千万上百万时候容易阻塞</span></span><br><span class="line">&gt;SCAN 0<span class="comment">#建议使用,每次获取11个key，可以循环获取，直到获取所有key。从编号0开始，中间会有一个编号提示（类似索引编号),按编号提示依次循环获取，直到编号为0即表示获取完所有的key</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用Shell批量写入数据并获取</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> -w 50);<span class="keyword">do</span> redis-cli -a 000588 <span class="built_in">set</span> name<span class="variable">$&#123;i&#125;</span> <span class="built_in">test</span><span class="variable">$&#123;i&#125;</span>; redis-cli -a redispwd get name<span class="variable">$&#123;i&#125;</span>; <span class="keyword">done</span> 2&gt;/dev/null</span><br></pre></td></tr></table></figure><h3 id="4-监控命令">4.监控命令</h3><h4 id="1-监控Redis状态">1.<strong>监控Redis状态</strong></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># redis-cli -a redispwd --stat</span></span><br><span class="line">------- data ------ --------------------- load -------------------- - child -</span><br><span class="line">keys       mem      clients blocked requests            connections          </span><br><span class="line">5          875.34K  2       0       2690 (+0)           55          </span><br><span class="line">5          875.34K  2       0       2691 (+1)           55  </span><br><span class="line"><span class="comment">#显示多少个key(是把所有数据库的key都加起来)  内存占用多少   客户端有多少   redis的requests请求数是多少   connections是多少连接</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># redis-cli -a redispwd monitor                                 #监控数据操作</span></span><br><span class="line"><span class="comment">#交互式阻塞状态，当有对数据进行操作时候会记录</span></span><br><span class="line"><span class="comment">#操作的命令，增加，删除数据等都会监控到</span></span><br></pre></td></tr></table></figure><h4 id="2-监控数据操作">2.<strong>监控数据操作</strong></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># redis-cli -a redispwd monitor</span></span><br><span class="line"><span class="comment">#交互式阻塞状态，当有对数据进行操作时候会记录</span></span><br><span class="line"><span class="comment">#操作的命令，增加，删除数据等都会监控到</span></span><br></pre></td></tr></table></figure><h4 id="3-监控系统可通过info获取数据">3.<strong>监控系统可通过info获取数据</strong></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># redis-cli -a redispwd info</span></span><br><span class="line"><span class="comment"># Server    ＃Redis 服务器的信息</span></span><br><span class="line">redis_version:2.8.13    ＃redis版本</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:ba7e0c54ae404843</span><br><span class="line">redis_mode:standalone   ＃redis运行模式</span><br><span class="line">os:Linux 2.6.32-504.16.2.el6.x86_64 x86_64  ＃操作系统版本</span><br><span class="line">arch_bits:64    ＃操作系统架构</span><br><span class="line">multiplexing_api:epoll  ＃Redis 所使用的事件处理机制</span><br><span class="line">gcc_version:4.4.7   ＃gcc版本</span><br><span class="line">process_id:5221     ＃当前运行进程ID</span><br><span class="line">run_id:62765912921734d0b192e4c7dec5bdeb92cf5af7 ＃ Redis 服务器的随机标识符（用于 Sentinel 和集群）</span><br><span class="line">tcp_port:6382       ＃当前监听端口</span><br><span class="line">uptime_in_seconds:267366    ＃运行时间，单位是秒</span><br><span class="line">uptime_in_days:3            ＃运行时间，单位是天</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:12856621  ＃以分钟为单位进行自增的时钟，用于 LRU 管理</span><br><span class="line">config_file:/opt/codis/gopath/src/github.com/wandoulabs/codis/sample/./redis_conf/6382.conf ＃使用的配置文件的绝对路径</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients   ＃记录了已连接客户端的信息</span></span><br><span class="line">connected_clients:3     ＃已经连接的客户端数量，只包括直接连接的客户端，不包括连接到从节点的客户端</span><br><span class="line">client_longest_output_list:0    ＃ 当前连接的客户端当中，最长的输出列表</span><br><span class="line">client_biggest_input_buf:0      ＃ 当前连接的客户端当中，最大输入缓存</span><br><span class="line">blocked_clients:0               ＃ 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory                    ＃记录了服务器的内存信息</span></span><br><span class="line">used_memory:20195844128     ＃当前redis已经分配的内存数量，单位byte</span><br><span class="line">used_memory_human:18.81G    ＃当前redis已经分配的内存数量，常用方便读取的单位</span><br><span class="line">used_memory_rss:20550877184 ＃从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</span><br><span class="line">used_memory_peak:21053144288    <span class="comment">#内存使用峰值</span></span><br><span class="line">used_memory_peak_human:19.61G   ＃内存使用峰值的友好读取数量</span><br><span class="line">used_memory_lua:33792           ＃Lua 引擎所使用的内存大小，单位byte</span><br><span class="line">mem_fragmentation_ratio:1.02    <span class="comment"># used_memory_rss 和 used_memory 之间的比率,即20550877184／20195844128=1.0175795106约为1.02。这个比值比1高一点点比较理想，比值太高说明有大量碎片，小于1时说明部分redis内存已经被操作系统交换到swap了，可能会影响响应时间。</span></span><br><span class="line">//当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。查看 used_memory_peak 的值可以验证这种情况是否发生。</span><br><span class="line">mem_allocator:jemalloc-3.6.0    ＃在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence               ＃ RDB 持久化和 AOF 持久化有关的信息</span></span><br><span class="line">loading:0                   ＃ 一个标志值，记录了服务器是否正在载入持久化文件</span><br><span class="line">rdb_changes_since_last_save:13652713    ＃最后一次持久化到现在的时间，单位秒</span><br><span class="line">rdb_bgsave_in_progress:0    ＃一个标志值，表示是否正在创建RDB文件</span><br><span class="line">rdb_last_save_time:1455590116   ＃最后一次创建RDB文件的UNIX时间戳，可以使用data -d @1455590116查看具体时间，如[t@bjb0541 ~]$ <span class="built_in">date</span> -d @1455590116   Tue Feb 16 10:35:16 CST 2016</span><br><span class="line">rdb_last_bgsave_status:ok       ＃最近一次创建RDB成功还是失败</span><br><span class="line">rdb_last_bgsave_time_sec:202    ＃最近一次创建RDB的耗时，单位秒</span><br><span class="line">rdb_current_bgsave_time_sec:-1  ＃如果服务器当前正在写入RDB，这个时间就是已经操作耗费的时间。</span><br><span class="line">aof_enabled:0                   ＃是否启用了aof</span><br><span class="line">aof_rewrite_in_progress:0       <span class="comment">#一个标记，当前是否正在创建AOF</span></span><br><span class="line">aof_rewrite_scheduled:0         ＃一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作。</span><br><span class="line">aof_last_rewrite_time_sec:-1    ＃最近一次AOF的耗费的时间</span><br><span class="line">aof_current_rewrite_time_sec:-1 ＃如果当前正在写AOF，已经操作的时候值</span><br><span class="line">aof_last_bgrewrite_status:ok    ＃最近一次AOF后台的成功或失败</span><br><span class="line">aof_last_write_status:ok        ＃最近一次的AOF的成功或失败</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats                     ＃状态</span></span><br><span class="line">total_connections_received:88378    ＃已经接收的请求数</span><br><span class="line">total_commands_processed:35467619   ＃已经执行的命令数</span><br><span class="line">instantaneous_ops_per_sec:165       ＃每秒执行的操作数</span><br><span class="line">rejected_connections:0              ＃因为最大客户端数量限制而被拒绝的连接请求数量</span><br><span class="line">sync_full:5                         ＃完全同步次数（我猜测的）</span><br><span class="line">sync_partial_ok:0                   </span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:120                    ＃因为过期而被删除的键数</span><br><span class="line">evicted_keys:0                      ＃因为最大内存容量限制而被驱逐（evict）的键数量</span><br><span class="line">keyspace_hits:15287495              ＃查找命中的次数</span><br><span class="line">keyspace_misses:0                   ＃查找失败的次数</span><br><span class="line">pubsub_channels:0                   ＃订阅的频道数</span><br><span class="line">pubsub_patterns:0                   ＃订阅的模式数</span><br><span class="line">latest_fork_usec:23562              ＃最近一次FOCK所用的时间</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication                   ＃主从复制信息</span></span><br><span class="line">role:slave                      ＃主机角色</span><br><span class="line">master_host:192.168.171.139     ＃主服务器IP</span><br><span class="line">master_port:6381                ＃主服务器端口</span><br><span class="line">master_link_status:up           ＃主服务器状态，UP正常，DOWN已经断开</span><br><span class="line">master_last_io_seconds_ago:0    ＃距离最近一次与主服务器进行通信已经过去了多少秒。</span><br><span class="line">master_sync_in_progress:0       ＃标记值，表示当前是否正在进行主从复制。</span><br><span class="line">slave_repl_offset:83184763601   </span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0              ＃已连接的从服务器数量</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:281559737</span><br><span class="line">repl_backlog_histlen:1048576</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU                           ＃CPU信息</span></span><br><span class="line">used_cpu_sys:1939.74            ＃耗费系统CPU</span><br><span class="line">used_cpu_user:4148.13           ＃耗费用户CPU</span><br><span class="line">used_cpu_sys_children:101.03    ＃后台进程耗费的系统CPU</span><br><span class="line">used_cpu_user_children:900.62   ＃后台进程耗费的用户CPU</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line">cluster_enabled:1 <span class="comment">#是否启用集群</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace  ＃部分记录了数据库相关的统计信息，比如数据库的键数量、设置有过期时间的key的数量等。对于每个数据库，这个部分都会添加一行以下格式的信息：</span></span><br><span class="line">db0:keys=16839997,expires=16061394,avg_ttl=560458485 </span><br></pre></td></tr></table></figure><h3 id="5-Redis配置动态更新和写入">5.Redis配置动态更新和写入</h3><p><code>config</code> <strong>查看或设置配置项</strong></p><ol><li><p><strong>Redis更新配置的两种方式:</strong><br>a.重启更新，需要修改配置文件，然后重启<br>b.实时更新，不需要重启</p></li><li><p><strong>静态更新的方法：（以修改密码为例）：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /usr/local/redis-6.2.6/redis.conf</span></span><br><span class="line">requirepass new_redispwd</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl restart redis</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态更新的方法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;config get requirepass<span class="comment">#查询密码</span></span><br><span class="line">&gt;config <span class="built_in">set</span> requirepass new_redispwd<span class="comment">#动态修改密码</span></span><br><span class="line">&gt;config rewrite<span class="comment">#动态更新只能临时设定密码，要执行`config rewrite`才能把动态更新的内容写入配置文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="6-Redis多用户管理">6.Redis多用户管理</h3><p>老版本没有用户名，只有密码。Redis6已经有用户名，<strong>默认用户名<code>default</code></strong>。</p><p>1.<strong>列出所有用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ACL LIST<span class="comment">#列出所有用户，默认用户是default</span></span><br><span class="line">1) <span class="string">&quot;user default on #d8dd7b3fa6948180c03593f628b145d5a15cf5bb8009feb0a8ee1a6121008b99 ~* &amp;* +@all&quot;</span></span><br></pre></td></tr></table></figure><p>2.<strong>查看用户的相关信息</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ACL GETUSER default<span class="comment">#查看default用户的相关信息， default对所有key，所有命令均有权限，最高权限，是默认用户</span></span><br><span class="line"> 1) <span class="string">&quot;flags&quot;</span></span><br><span class="line"> 2) 1) <span class="string">&quot;on&quot;</span></span><br><span class="line">    2) <span class="string">&quot;allkeys&quot;</span><span class="comment">#所有的key都有权限</span></span><br><span class="line">    3) <span class="string">&quot;allchannels&quot;</span></span><br><span class="line">    4) <span class="string">&quot;allcommands&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;passwords&quot;</span></span><br><span class="line"> 4) 1) <span class="string">&quot;d8dd7b3fa6948180c03593f628b145d5a15cf5bb8009feb0a8ee1a6121008b99&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;commands&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;+@all&quot;</span><span class="comment">#所有的命令都有权限</span></span><br><span class="line"> 7) <span class="string">&quot;keys&quot;</span></span><br><span class="line"> 8) 1) <span class="string">&quot;*&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;channels&quot;</span></span><br><span class="line">10) 1) <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p>3.<strong>查看能赋予用户的所有的权限</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; ACL CAT                               <span class="comment">#查看所有的权限</span></span><br><span class="line"> 1) <span class="string">&quot;keyspace&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;read&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;write&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;set&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;sortedset&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;list&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;hash&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;string&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;bitmap&quot;</span></span><br><span class="line">10) <span class="string">&quot;hyperloglog&quot;</span></span><br><span class="line">11) <span class="string">&quot;geo&quot;</span></span><br><span class="line">12) <span class="string">&quot;stream&quot;</span></span><br><span class="line">13) <span class="string">&quot;pubsub&quot;</span></span><br><span class="line">14) <span class="string">&quot;admin&quot;</span></span><br><span class="line">15) <span class="string">&quot;fast&quot;</span></span><br><span class="line">16) <span class="string">&quot;slow&quot;</span></span><br><span class="line">17) <span class="string">&quot;blocking&quot;</span></span><br><span class="line">18) <span class="string">&quot;dangerous&quot;</span></span><br><span class="line">19) <span class="string">&quot;connection&quot;</span></span><br><span class="line">20) <span class="string">&quot;transaction&quot;</span></span><br><span class="line">21) <span class="string">&quot;scripting&quot;</span></span><br></pre></td></tr></table></figure><p>4.<strong>创建用户并给用户授权</strong></p><p>创建用户赋给所有权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ACL SETUSER test1 on &gt;test1pwd ~* +@all<span class="comment">#用户名:test1  密码:test1pwd,赋予所有权限（超级用户）</span></span><br><span class="line">&gt; ACL GETUSER test1<span class="comment">#查看test1用户的所有权限</span></span><br><span class="line"></span><br><span class="line">&gt; ACL SETUSER test2 on &gt;test2pwd ~* +@all -config<span class="comment">#用户名:test2  密码:test2pwd，赋予除config以外所有权限</span></span><br></pre></td></tr></table></figure><p>案例：创建test用户只给一个get命令权限、读权限、并且只能get是name开头的key: name*</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用default默认用户登录redis：</span></span><br><span class="line"><span class="comment"># redis-cli -a redispwd</span></span><br><span class="line">&gt; <span class="built_in">set</span> name1 n1</span><br><span class="line">&gt; <span class="built_in">set</span> name2 n2</span><br><span class="line">&gt; <span class="built_in">set</span> name3 n3</span><br><span class="line">&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">&gt; ACL SETUSER <span class="built_in">test</span> on &gt;testpwd ~name* +get                <span class="comment">#创建test用户，密码：testpwd   赋给get命令的权限，只对name开头的有get权限</span></span><br><span class="line">&gt; ACL SETUSER <span class="built_in">test</span> on &gt;testpwd ~name* +@<span class="built_in">read</span>             <span class="comment">#给test用户增加read权限，设置只对name开头的key有read权限</span></span><br><span class="line">&gt; ACL getuser <span class="built_in">test</span>                                        <span class="comment">#查看test用户的相关信息</span></span><br><span class="line"></span><br><span class="line">&gt; ACL SETUSER t1 on &gt;t1pwd ~* +get                        <span class="comment">#对所有key都有get权限</span></span><br><span class="line">&gt; ACL SETUSER t1 on &gt;t1pwd ~* +@<span class="built_in">read</span>                      <span class="comment">#对所有key都有read权限</span></span><br><span class="line">&gt; ACL getuser t1</span><br><span class="line"></span><br><span class="line"><span class="comment">#认证登录，验证权限:</span></span><br><span class="line">&gt; auth <span class="built_in">test</span> testpwd</span><br><span class="line"><span class="comment"># redis-cli --user test --pass testpwd</span></span><br><span class="line"></span><br><span class="line">&gt; get name1</span><br><span class="line"><span class="string">&quot;n1&quot;</span></span><br><span class="line">&gt; get name2</span><br><span class="line"><span class="string">&quot;n2&quot;</span></span><br><span class="line">&gt; get k1</span><br><span class="line">(error) NOPERM this user has no permissions to access one of the keys used as arguments</span><br><span class="line">&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">(error) NOPERM this user has no permissions to run the <span class="string">&#x27;set&#x27;</span> <span class="built_in">command</span> or its subcommand</span><br></pre></td></tr></table></figure><p>5.<strong>删除用户</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; ACL DELUSER <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="7-Redis慢日志">7.Redis慢日志</h3><p>redis慢日志是用于记录某些命令在执行时超过了预设定的时间，只要超过了一定的时间，redis就会将该条命令记录到redis-slowlog中。</p><p><strong>如果有人反馈redis慢，如何进行排查？</strong></p><ul><li>系统资源情况</li><li>查看慢日志情况</li></ul><p><strong>案例</strong></p><p>1.查看慢日志的配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; CONFIG GET slow*                     <span class="comment">#查看慢日志的配置                  </span></span><br><span class="line">1) <span class="string">&quot;slowlog-max-len&quot;</span></span><br><span class="line">2) <span class="string">&quot;128&quot;</span>                                      <span class="comment">#最多记录128个</span></span><br><span class="line">3) <span class="string">&quot;slowlog-log-slower-than&quot;</span></span><br><span class="line">4) <span class="string">&quot;10000&quot;</span>                                  <span class="comment">#默认超过10毫秒就会记录</span></span><br></pre></td></tr></table></figure><p>2.<strong>设置慢日志的时间是1毫秒，查询超过1毫秒就为慢日志</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; config <span class="built_in">set</span> slowlog-log-slower-than 1000     <span class="comment">#设置慢日志的时间是1毫秒,查询超过1毫秒就为慢日志</span></span><br><span class="line">&gt; CONFIG GET slow*                                 <span class="comment">#查看</span></span><br><span class="line">1) <span class="string">&quot;slowlog-max-len&quot;</span></span><br><span class="line">2) <span class="string">&quot;128&quot;</span></span><br><span class="line">3) <span class="string">&quot;slowlog-log-slower-than&quot;</span></span><br><span class="line">4) <span class="string">&quot;1000&quot;</span>                                               <span class="comment">#1毫秒为慢日志</span></span><br></pre></td></tr></table></figure><p>3.使用Shell批量写入数据并获取，多写入些数据，方便我们查询数据大的时候产生慢日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for i in $(seq -w 100000);do redis-cli -a redispwd set name$&#123;i&#125; test$&#123;i&#125;; redis-cli -a redispwd get name$&#123;i&#125;; done 2&gt;/dev/null</span></span><br></pre></td></tr></table></figure><p>4.产生慢日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; KEYS *                        <span class="comment">#查询一次，当操作时间大于1毫秒，就会产生一条慢日志</span></span><br><span class="line">&gt; KEYS * </span><br><span class="line">&gt; KEYS * </span><br><span class="line">....可以多查询几次，多获取几条慢日志</span><br></pre></td></tr></table></figure><p>5.查询慢日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SLOWLOG get<span class="comment">#默认获取最近10条</span></span><br><span class="line">&gt; SLOWLOG get 5<span class="comment">#获取5条</span></span><br><span class="line">&gt; SLOWLOG len<span class="comment">#慢日志量，查看慢日志的条数</span></span><br><span class="line">&gt; SLOWLOG reset<span class="comment">#清空慢日志</span></span><br></pre></td></tr></table></figure><p>6.Slowlog各字段意思</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG get</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 115<span class="comment">#慢日志的id，从0开始，第115个id</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 1668215297<span class="comment">#时间戳，慢日志产生的时间点，可以通过 date -d @1668215297   获取慢日志产生的时间</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 69284<span class="comment">#慢日志运行的时间69毫秒</span></span><br><span class="line">   4) 1) <span class="string">&quot;keys&quot;</span><span class="comment">#产生慢日志的命令，一般是当数据量太多时候，运行keys *命令会比较慢</span></span><br><span class="line">      2) <span class="string">&quot;*&quot;</span></span><br><span class="line">   5) <span class="string">&quot;127.0.0.1:60014&quot;</span></span><br><span class="line">   6) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="8-Redis-key生存时间">8.Redis key生存时间</h3><ul><li>概念</li></ul><p>​<strong>生存时间（Time To Live，TTL）</strong>：在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键</p><p>​<strong>过期时间（expire time）</strong>：是一个UNIX<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&amp;spm=1001.2101.3001.7020">时间戳</a>，当键的过期时间来临时，服务器就会自动从数据库中删除这个键</p><ul><li><p>语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置生存时间</span><br><span class="line">EXPIRE &lt;key&gt; &lt;ttl&gt;：用于将键key的生存时间设置为ttl秒</span><br><span class="line">PEXPIRE &lt;key&gt; &lt;ttl&gt;：用于将键key的生存时间设置为ttl毫秒</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置过期时间</span><br><span class="line">EXPIREAT &lt;key&gt; &lt;timestamp&gt;：用于将键key的过期时间设置为timestamp所指定的秒数时间戳</span><br><span class="line">PEXPIREAT &lt;key&gt; &lt;timestamp&gt;：用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳</span><br></pre></td></tr></table></figure><p>EXPIRE、PEXPIRE、EXPIREAT这几个命令的<strong>内部最终使用的都是PEXPIREAT</strong></p></li><li><p>eg.</p><p>给Redis的key设置有效期,<strong>-1表示永久,-2代表Redis回收了</strong>（key已经自动删除)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> name test1<span class="comment">#默认设置的key是永久有效的</span></span><br><span class="line">&gt; get name</span><br><span class="line"><span class="string">&quot;test1&quot;</span></span><br><span class="line">&gt; ttl name                      <span class="comment">#查看key的状态，生命周期，-1表示永久有效</span></span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">&gt; expire name 20<span class="comment">#方法1: 给key设置有效期，单位:秒，设置有效期是20s       </span></span><br><span class="line">&gt; <span class="built_in">set</span> name2 test02 EX 20<span class="comment">#方法2: 再创建key时候直接给key设置有效期:20s</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-Redis禁用危险命令">9.Redis禁用危险命令</h3><ul><li><p>Redis 的危险命令主要有：</p><ul><li>flushdb，清空数据库</li><li>flushall，清空所有记录，数据库</li><li>config，客户端连接后可配置服务器</li><li>keys，客户端连接后可查看所有存在的键，当 redis key 很多时，非常危险，建议使用 scan 命令代替</li></ul><p>可以禁用以上命令来使服务器更加安全。禁用方法是：在配置文件 <code>redis.conf</code> 中 <code>SECURITY</code> 区域中，新增以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command FLUSHDB &quot;&quot;</span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br></pre></td></tr></table></figure><p>如果想要保留命令，但是不能轻易使用，可以重命名命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rename-command FLUSHALL XXXXXXXXXXXXXX</span><br><span class="line">rename-command FLUSHDB XXXXXXXXXXXXXX</span><br><span class="line">rename-command CONFIG XXXXXXXXXXXXXX</span><br><span class="line">rename-command KEYS XXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure><p><code>XXXXXXXXXXXXXX</code> 用新命令代替</p><p>配置完后重启 Redis 服务生效。如果禁用 <code>FLUSHALL</code> 命令，需要设置配置文件中 <code>appendonly no</code>，否则服务无法启动。</p></li></ul><h3 id="10-压测工具">10.压测工具</h3><p>Redis 自带了一个叫 redis-benchmark 的工具来模拟 N 个客户端同时发出 M 个请求。（类似于 Apache ab 程序）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-benchmark --<span class="built_in">help</span></span><br><span class="line">-c &lt;clients&gt;       Number of parallel connections (default 50)<span class="comment">#默认的并发是50个</span></span><br><span class="line">-n &lt;requests&gt;      Total number of requests (default 100000)<span class="comment">#默认有10万个请求</span></span><br></pre></td></tr></table></figure><p>压测工具，基本对redis里的每一个命令都会进行测试一遍</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-benchmark -a redispwd<span class="comment">#用默认的并发50个，一共10万个请求对redis进行压测</span></span><br><span class="line">&gt; redis-benchmark -a redispwd | <span class="built_in">tee</span> /tmp/a.log<span class="comment">#将测试的结果输出到一个log文件</span></span><br></pre></td></tr></table></figure><ul><li><p>参数</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-h <hostname></td><td>指定服务器主机名 (默认 127.0.0.1)</td></tr><tr><td>-p <port></td><td>指定服务器端口 (默认 6379)</td></tr><tr><td>-s <socket></td><td>指定服务器 socket</td></tr><tr><td>-a <password> Redis 认证密码</td><td></td></tr><tr><td>-c <clients></td><td>指定并发连接数 (默认 50)</td></tr><tr><td>-n <requests></td><td>指定请求数 (默认 100000)</td></tr><tr><td>-d <size></td><td>以字节的形式指定 SET/GET 值的数据大小 (默认 2)</td></tr><tr><td>–dbnum <db></td><td>选择指定的数据库号 (默认 0)</td></tr><tr><td>-k <boolean></td><td>1=keep alive 0=reconnect (默认 1)</td></tr><tr><td>-r <keyspacelen></td><td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td></tr><tr><td>-P <numreq></td><td>通过管道传输 <numreq> 请求 (no pipeline)</td></tr><tr><td>-q</td><td>退出，仅显示 query/sec 值</td></tr><tr><td>–csv</td><td>以 CSV 格式输出</td></tr><tr><td>-l</td><td>生成循环，永久执行测试</td></tr><tr><td>-t <tests></td><td>仅运行以逗号分隔的测试命令列表</td></tr><tr><td>-I</td><td>Idle 模式，仅打开 N 个 idle 连接并等待</td></tr></tbody></table></li></ul><p>日常输出的一个简介</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /tmp/a.log</span></span><br><span class="line">PING_INLINE:                                                                      测试PING</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.10 seconds                          一共处理了10万个PING请求，在1.1秒中完成</span><br><span class="line">  50 parallel clients                                                               50个并发</span><br><span class="line">  3 bytes payload                                                                 每个请求数据量是3个字节</span><br><span class="line">  ......</span><br><span class="line">100.000% &lt;= 2.527 milliseconds (cumulative count 100000)    测试PING的一个延时，&lt;2.5毫秒的有100%</span><br><span class="line"></span><br><span class="line">SET:                                                                                   测试SET命令</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.07 seconds                         一共执行了10万次SET操作，在1.07秒中完成</span><br><span class="line">  50 parallel clients                                                              50个并发</span><br><span class="line">  3 bytes payload                                                                每个请求数据量是3个字节  </span><br><span class="line">  ......</span><br><span class="line">23.353% &lt;= 0.207 milliseconds (cumulative count 23353)       %23.353的命令执行时间小于0.207毫秒</span><br><span class="line">69.820% &lt;= 0.303 milliseconds (cumulative count 69820)       %69.820的命令执行时间小于0.303毫秒</span><br><span class="line">100.000% &lt;= 2.183 milliseconds (cumulative count 100000)    %100的命令执行时间小于2.183毫秒</span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 93370.68 requests per second             redis每秒可以处理93370.68次<span class="built_in">set</span>请求</span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.302     0.072     0.247     0.599     1.111     2.183</span><br><span class="line"></span><br><span class="line">GET:                                                                                 测试GET命令</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 1.12 seconds                        一共执行了10万次GET操作，在1.12秒中完成</span><br><span class="line">  50 parallel clients                                                              50个并发</span><br><span class="line">  3 bytes payload                                                                每个请求数据量是3个字节 </span><br><span class="line">  ......</span><br><span class="line">50.000% &lt;= 0.255 milliseconds (cumulative count 52277)        %50的命令执行时间小于0.255毫秒</span><br><span class="line">75.000% &lt;= 0.375 milliseconds (cumulative count 75710)        %75的命令执行时间小于0.375毫秒</span><br><span class="line">100.000% &lt;= 2.447 milliseconds (cumulative count 100000)     %100的命令执行时间小于2.447毫秒</span><br><span class="line">Summary:</span><br><span class="line">  throughput summary: 89445.44 requests per second               redis每秒可以处理89445.44次get请求    </span><br><span class="line">  latency summary (msec):</span><br><span class="line">          avg       min       p50       p95       p99       max</span><br><span class="line">        0.326     0.048     0.255     0.687     1.311     2.447</span><br></pre></td></tr></table></figure><h2 id="六、Redis持久化">六、Redis持久化</h2><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）</p><ul><li>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</li><li>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</li></ul><p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p><p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p><h3 id="1-RDB持久化">1.RDB持久化</h3><p>RDB（Redis DataBase）持久化是把当前Redis中全部数据生成快照保存在硬盘上。RDB持久化可以手动触发，也可以自动触发。</p><ul><li><p><strong>开启、关闭 RDB</strong></p><p>通过修改配置文件开、关RDB持久化: （推荐）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim redis.conf</span></span><br><span class="line"><span class="comment"># 时间策略</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># 文件保存路径</span></span><br><span class="line"><span class="built_in">dir</span> /mydata/redis</span><br><span class="line"><span class="comment"># 如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 是否压缩</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>如果是关闭RDB,添加<code>save &quot;&quot;</code>并注释完相应配置后要删除 <code>/mydata/redis/dump.rdb</code> ，在重启服务。</p><p>也可以：(使用<code>config</code>关闭 (用rewrite发现貌似不能写入配置文件)(不推荐)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;config <span class="built_in">set</span> save <span class="string">&quot;&quot;</span>                       <span class="comment">#关闭rdb快照持久化存储,测试的不好使</span></span><br><span class="line">&gt;config rewrite                            <span class="comment">#写入配置文件，永久设置                           </span></span><br><span class="line">&gt;config <span class="built_in">set</span> rdbcompression no      <span class="comment">#rdb文件需不需要压缩，当磁盘空间比较大时候，可以设置不用压缩</span></span><br></pre></td></tr></table></figure></li><li><p><strong>手动触发</strong></p><p><code>save</code>和<code>bgsave</code>命令都可以手动触发RDB持久化。</p></li><li><p><strong>save命令</strong></p><p>执行<code>save</code>命令会手动触发RDB持久化，但是<code>save</code>命令会阻塞Redis服务，直到RDB持久化完成。当Redis服务储存大量数据时，会造成较长时间的阻塞，不建议使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>执行后，Redis的日志中记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* DB saved on disk</span><br></pre></td></tr></table></figure></li><li><p><strong>bgsave命令</strong></p><p>执行bgsave命令也会手动触发RDB持久化，和save命令不同是：Redis服务一般不会阻塞。Redis进程会执行fork操作创建子进程，RDB持久化由子进程负责，不会阻塞Redis服务进程。Redis服务的阻塞只发生在fork阶段，一般情况时间很短。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; bgsave</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><p>执行后，Redis的日志中记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* Background saving started by pid 2645</span><br><span class="line">* DB saved on disk</span><br><span class="line">* RDB: 0 MB of memory used by copy-on-write</span><br><span class="line">* Background saving terminated with success</span><br></pre></td></tr></table></figure><p><code>bgsave</code>命令的具体流程:</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1f9d0b79e335393d7825fca8637cafe1.png" alt="img"></p><blockquote><p>图片中的 5 个步骤所进行的操作如下：</p><ol><li><p>Redis 父进程首先判断：当前是否在执行 save，或 bgsave/bgrewriteaof 的子进程，如果在执行则 bgsave 命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。</p></li><li><p>父进程执行 fork 操作创建子进程，这个过程中父进程是阻塞的，Redis 不能执行来自客户端的任何命令</p></li><li><p>父进程 fork 后，bgsave 命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令</p></li><li><p>子进程创建 RDB 文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换</p></li><li><p>子进程发送信号给父进程表示完成，父进程更新统计信息</p></li></ol></blockquote></li><li><p><strong>RDB 文件格式</strong></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/89aa18a36a490ad5dfd8df5e5587501c.png" alt="img"></p><blockquote><p>其中各个字段的含义说明如下：</p><ol><li><p>REDIS：常量，保存着”REDIS”5 个字符。</p></li><li><p>db_version：RDB 文件的版本号，注意不是 Redis 的版本号。</p></li><li><p>SELECTDB 0 pairs：表示一个完整的数据库(0 号数据库)，同理 SELECTDB 3 pairs 表示完整的 3 号数据库；只有当数据库中有键值对时，RDB 文件中才会有该数据库的信息(上图所示的 Redis 中只有 0 号和 3 号数据库有键值对)；如果 Redis 中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB 是一个常量，代表后面跟着的是数据库号码；0 和 3 是数据库号码；pairs 则存储了具体的键值对信息，包括 key、value 值，及其数据类型、内部编码、过期时间、压缩信息等等。</p></li><li><p>EOF：常量，标志 RDB 文件正文内容结束。</p></li><li><p>check_sum：前面所有内容的校验和；Redis 在载入 RBD 文件时，会计算前面的校验和并与 check_sum 值比较，判断文件是否损坏。</p></li></ol></blockquote></li><li><p><strong>启动时加载</strong></p><p>RDB 文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于 AOF 的优先级更高，因此当 AOF 开启时，Redis 会优先载入 AOF 文件来恢复数据；只有当 AOF 关闭时，才会在 Redis 服务器启动时检测 RDB 文件，并自动载入。<strong>服务器载入 RDB 文件期间处于阻塞状态，直到载入完成为止。</strong></p><p>Redis 载入 RDB 文件时，会对 RDB 文件进行校验，如果文件损坏，则日志中会打印错误，Redis 启动失败。</p></li><li><p><strong>关闭 RDB</strong></p><p>使用<code>config</code>关闭 (用rewrite发现貌似不能写入配置文件)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;config <span class="built_in">set</span> save <span class="string">&quot;&quot;</span>                       <span class="comment">#关闭rdb快照持久化存储,测试的不好使</span></span><br><span class="line">&gt;config rewrite                            <span class="comment">#写入配置文件，永久设置                           </span></span><br><span class="line">&gt;config <span class="built_in">set</span> rdbcompression no      <span class="comment">#rdb文件需不需要压缩，当磁盘空间比较大时候，可以设置不用压缩</span></span><br></pre></td></tr></table></figure><p>通过修改配置文件关闭rdb持久化: （推荐）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/redis.conf</span></span><br><span class="line">save <span class="string">&quot;&quot;</span>                                      <span class="comment">#添加</span></span><br><span class="line"><span class="comment">#注释下面的：</span></span><br><span class="line"><span class="comment">#save 3600 1</span></span><br><span class="line"><span class="comment">#save 300 100</span></span><br><span class="line"><span class="comment">#save 60 10000</span></span><br></pre></td></tr></table></figure><p>执行完后要删除 <code>/mydata/redis/dump.rdb</code> ，在重启服务。</p></li></ul><h3 id="2-AOF持久化">2.AOF持久化</h3><p>RDB 持久化是将进程数据写入文件，而 AOF 持久化(即 Append Only File 持久化)，则是将 Redis 执行的每次写命令记录到单独的日志文件中；当 Redis 重启时再次执行 AOF 文件中的命令来恢复数据。</p><p>与 RDB 相比，AOF 的实时性更好，因此已成为主流的持久化方案。</p><ul><li><p><strong>开启、关闭AOF</strong></p><p>修改配置文件<code>redis.conf</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改配置文件，把no改为 yes</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#确定存储文件名是否正确</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment">#重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb <span class="comment">#表示触发AOF重写的最小文件体积,大于或等于64MB自动触发。</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>AOF 的执行流程包括：</p><ul><li>命令追加(append)：将 Redis 的写命令追加到缓冲区 aof_buf；</li><li>文件写入(write)和文件同步(sync)：根据不同的同步策略将 aof_buf 中的内容同步到硬盘；</li><li>文件重写(rewrite)：定期重写 AOF 文件，达到压缩的目的。</li></ul></blockquote><ul><li><p><strong>命令追加(append)</strong></p><p>Redis 先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘 IO 成为 Redis 负载的瓶颈。</p><p>命令追加的格式是 Redis 命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点。在 AOF 文件中，除了用于指定数据库的 select 命令是由 Redis 添加的，其他都是客户端发送来的写命令。</p></li><li><p><strong>文件写入(write)和文件同步(sync)</strong></p><p>Redis 提供了多种 AOF 缓存区的同步文件策略，策略涉及到操作系统的 write 函数和 fsync 函数，说明如下：</p><p>为了提高文件写入效率，在现代操作系统中，当用户调用 write 函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了 fsync、fdatasync 等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。</p><p>AOF 缓存区的同步文件策略由参数 appendfsync 控制，各个值的含义如下：</p><ul><li>always：命令写入 aof_buf 后立即调用系统 fsync 操作同步到 AOF 文件，fsync 完成后线程返回。这种情况下，每次有写命令都要同步到 AOF 文件，硬盘 IO 成为性能瓶颈，Redis 只能支持大约几百 TPS 写入，严重降低了 Redis 的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低 SSD 的寿命。</li><li>no：命令写入 aof_buf 后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</li><li>everysec：命令写入 aof_buf 后调用系统 write 操作，write 完成后线程返回；fsync 同步文件操作由专门的线程每秒调用一次。<strong>everysec 是前述两种策略的折中，是性能和数据安全性的平衡，因此是 Redis 的默认配置，也是我们推荐的配置。</strong></li></ul></li><li><p><strong>文件重写(rewrite)</strong></p><p>随着时间流逝，Redis 服务器执行的写命令越来越多，AOF 文件也会越来越大；过大的 AOF 文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。</p><p>文件重写是指定期重写 AOF 文件，减小 AOF 文件的体积。需要注意的是，<strong>AOF 重写是把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件；不会对旧的 AOF 文件进行任何读取、写入操作!</strong></p><p>关于文件重写需要注意的另一点是：对于 AOF 持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在 Redis 启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。</p><p>文件重写之所以能够压缩 AOF 文件，原因在于：</p><ul><li>过期的数据不再写入文件</li><li>无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等</li><li>多条命令可以合并为一个：如 sadd myset v1, sadd myset v2, sadd myset v3 可以合并为 sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于 list、set、hash、zset 类型的 key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在 redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD 中定义，不可更改，3.0 版本中值是 64。</li></ul><p>通过上述内容可以看出，由于重写后 AOF 执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。</p><ul><li><p>文件重写的触发</p><p>文件重写的触发，分为手动触发和自动触发：</p><p><strong>手动触发</strong>：直接调用 <code>bgrewriteaof</code> 命令，该命令的执行与 bgsave 有些类似：都是 fork 子进程进行具体的工作，且都只有在 fork 时阻塞。</p><p><strong>自动触发</strong>：根据 <code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 参数，以及 <code>aof_current_size</code> 和 <code>aof_base_size</code> 状态确定触发时机。</p><ul><li><code>auto-aof-rewrite-min-size</code>：执行 AOF 重写时，文件的最小体积，默认值为 64MB。</li><li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小(即 aof_current_size)和上一次重写时 AOF 大小(aof_base_size)的比值。</li></ul><p>只有当 <code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 两个参数同时满足时，才会自动触发 AOF 重写，即 bgrewriteaof 操作。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/890fafa81323d9958582d5902d413e70.png" alt="img"></p><blockquote><p>关于文件重写的流程，有两点需要特别注意：(1)重写由父进程 fork 子进程进行；(2)重写期间 Redis 执行的写命令，需要追加到新的 AOF 文件中，为此 Redis 引入了 aof_rewrite_buf 缓存。</p><p>对照上图，文件重写的流程如下：</p><ol><li><p>Redis 父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof 的子进程，如果存在则 bgrewriteaof 命令直接返回，如果存在 bgsave 命令则等 bgsave 执行完成后再执行。</p></li><li><p>父进程执行 fork 操作创建子进程，这个过程中父进程是阻塞的。</p></li></ol><p>3.1) 父进程 fork 后，bgrewriteaof 命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。<strong>Redis 的所有写命令依然写入 AOF 缓冲区，并根据 appendfsync 策略同步到硬盘，保证原有 AOF 机制的正确。</strong></p><p>3.2) 由于 fork 操作使用写时复制技术，子进程只能共享 fork 操作时的内存数据。<strong>由于父进程依然在响应命令，因此 Redis 使用 AOF 重写缓冲区(图中的 aof_rewrite_buf)保存这部分数据，防止新 AOF 文件生成期间丢失这部分数据。也就是说，bgrewriteaof 执行期间，Redis 的写命令同时追加到 aof_buf 和 aof_rewirte_buf 两个缓冲区。</strong></p><ol start="4"><li>子进程根据内存快照，按照命令合并规则写入到新的 AOF 文件。</li></ol><p>5.1) 子进程写完新的 AOF 文件后，向父进程发信号，父进程更新统计信息，具体可以通过 info persistence 查看。</p><p>5.2) 父进程把 AOF 重写缓冲区的数据写入到新的 AOF 文件，这样就保证了新 AOF 文件所保存的数据库状态和服务器当前状态一致。</p><p>5.3) 使用新的 AOF 文件替换老文件，完成 AOF 重写。</p></blockquote></li></ul></li></ul><p>​注意：自动触发重写在业务高峰压力大，如果采用自动触发重写，有可能会影响业务，可选择在压力小的时候脚本运行BGREWRITEAOF</p><ul><li><p><strong>启动时加载</strong></p><p>前面提到过，当 AOF 开启时，Redis 启动时会优先载入 AOF 文件来恢复数据；只有当 AOF 关闭时，才会载入 RDB 文件恢复数据。</p><p>当 AOF 开启，但 AOF 文件不存在时，即使 RDB 文件存在也不会加载(更早的一些版本可能会加载，但 3.0 不会)</p></li><li><p><strong>文件校验</strong></p><p>与载入 RDB 文件类似，Redis 载入 AOF 文件时，会对 AOF 文件进行校验，如果文件损坏，则日志中会打印错误，Redis 启动失败。但如果是 AOF 文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且 aof-load-truncated 参数开启，则日志中会输出警告，Redis 忽略掉 AOF 文件的尾部，启动成功。aof-load-truncated 参数默认是开启的。</p></li><li><p><strong>AOF策略配置</strong></p><p>在上述介绍写入机制的过程中，如果遇到宕机前，缓存内的数据未能写入到磁盘中，那么数据仍然会有丢失的风险。服务器宕机时，丢失命令的数量，取决于命令被写入磁盘的时间，越早地把命令写入到磁盘中，发生意外时丢失的数据就会越少，否则越多。</p><p>Redis 为数据的安全性考虑，同样为 AOF 持久化提供了策略配置，打开 Redis 配置文件，如下图所示：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1609113Z8-0.gif" alt="Redis AOF持久化"></p><blockquote><p>上述配置策略说明如下：</p><ul><li>Always：服务器每写入一个命令，就调用一次 fsync 函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，也不会丢失任何已经成功执行的命令数据，但是其执行速度较慢；</li><li>Everysec（默认）：服务器每一秒调用一次 fsync 函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，最多只丢失一秒钟内的执行的命令数据，通常都使用它作为 AOF 配置策略；</li><li>No：服务器不主动调用 fsync 函数，由操作系统决定何时将缓冲区里面的命令写入到硬盘。这种模式下，服务器遭遇意外停机时，丢失命令的数量是不确定的，所以这种策略，不确定性较大，不安全。</li></ul></blockquote><p>由于是 fsync 是磁盘 IO 操作，所以它很慢！如果 Redis 执行一条指令就要 fsync 一次（Always），那么 Redis 高性能将严重受到影响。</p><p>在生产环境的服务器中，Redis 通常是每隔 1s 左右执行一次 fsync 操作（ Everysec），这样既保持了高性能，也让数据尽可能的少丢失。最后一种策略（No），让操作系统来决定何时将数据同步到磁盘，这种策略存在许多不确定性，所以不建议使用。</p><p>从三种策略的运行速度来看，Always 的速度最慢，而 Everysec 和 No 都很快。</p></li></ul><h3 id="3-AOF和RDB对比">3.AOF和RDB对比</h3><table><thead><tr><th>RDB持久化</th><th>AOF持久化</th></tr></thead><tbody><tr><td>全量备份，一次保存整个数据库。</td><td>增量备份，一次只保存一个修改数据库的命令。</td></tr><tr><td>每次执行持久化操作的间隔时间较长。</td><td>保存的间隔默认为一秒钟（Everysec）</td></tr><tr><td>数据保存为二进制格式，其还原速度快。</td><td>使用文本格式还原数据，所以数据还原速度一般。</td></tr><tr><td>执行 SAVE 命令时会阻塞服务器，但手动或者自动触发的 BGSAVE 不会阻塞服务器</td><td>AOF持久化无论何时都不会阻塞服务器。</td></tr></tbody></table><ul><li><p>RDB 和 AOF 各有优缺点：</p><ul><li><p><strong>RDB 持久化</strong></p><p>优点：RDB 文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比 AOF 快很多。当然，与 AOF 相比，RDB 最重要的优点之一是对性能的影响相对较小。</p><p>缺点：RDB 文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此 AOF 持久化成为主流。此外，RDB 文件需要满足特定格式，兼容性差（如老版本的 Redis 不兼容新版本的 RDB 文件）。</p></li><li><p><strong>AOF 持久化</strong></p><p>与 RDB 持久化相对应，AOF 的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p></li></ul></li></ul><h3 id="4-持久化策略选择">4.持久化策略选择</h3><p>对于 RDB 持久化，一方面是 bgsave 在进行 fork 操作时 Redis 主进程会阻塞，另一方面，子进程向硬盘写数据也会带来 IO 压力；对于 AOF 持久化，向硬盘写数据的频率大大提高(everysec 策略下为秒级)，IO 压力更大，甚至可能造成 AOF 追加阻塞问题，此外，AOF 文件的重写与 RDB 的 bgsave 类似，会有 fork 时的阻塞和子进程的 IO 压力问题。相对来说，由于 AOF 向硬盘中写数据的频率更高，因此对 Redis 主进程性能的影响会更大。</p><p>在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用 RDB 或 AOF 的一种，或同时开启 RDB 和 AOF 持久化等。此外，持久化的选择必须与 Redis 的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机 master 和从机 slave 可以独立的选择持久化方案。</p><h2 id="七、Redis主从模式">七、Redis主从模式</h2><ul><li>如果服务器发生了宕机，由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的；</li><li>如果这台服务器的硬盘出现了故障，可能数据就都丢失了。</li></ul><p>要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/22c7fe97ce5d3c382b08d83a4d8a5b96.png" alt="图片"></p><p>Redis 提供了<strong>主从复制模式</strong>，来避免服务器之间的数据不一致性。这个模式可以保证多台服务器的数据一致性，且主从服务器之间采用的是「读写分离」的方式。</p><p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2b7231b6aabb9a9a2e2390ab3a280b2d.png" alt="图片"></p><ul><li><p>主从复制配置方法</p><p>在从服务器中配置<code>redis.conf</code>文件新增</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;<span class="comment">#指定主redis的ip和端口 </span></span><br><span class="line">masterauth <span class="string">&quot;redispwd&quot;</span><span class="comment">#指定主redis的密码</span></span><br></pre></td></tr></table></figure></li><li><p>查看节点角色 <code>info Replication</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在主redis上登录查看：  （192.168.27.128）</span><br><span class="line">127.0.0.1:6379&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.27.129,port=6379,state=online,offset=3216,lag=1</span><br><span class="line">slave1:ip=192.168.27.130,port=6379,state=online,offset=3216,lag=1</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:915141a4f68f3c12235c59bfc120b6041c9148a5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:3216</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:3216</span><br><span class="line"></span><br><span class="line">在从1redis上登录查看：（192.168.27.129）</span><br><span class="line">127.0.0.1:6379&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.27.128</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:0</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:3300</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:915141a4f68f3c12235c59bfc120b6041c9148a5</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:3300</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:897</span><br><span class="line">repl_backlog_histlen:2404</span><br></pre></td></tr></table></figure></li></ul><h2 id="八、哨兵模式（高可用）">八、哨兵模式（高可用）</h2><ul><li><p>概述</p><p>主从切换技术：当主机宕机后，需要手动把一台从（slave）服务器切换为主服务器，这就需要人工干预，费时费力，还回造成一段时间内服务不可用，所以推荐哨兵架构（Sentinel）来解决这个问题。哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。<br><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/a9a46e8f72464c75947658754d17da33.png" alt="img"></p><p>这里哨兵模式有两个作用：通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器当哨兵监测到Redis主机宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他服务器，修改配置文件，让他们换主机</p><p>当一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此可以使用哨兵进行监控， <strong>各个哨兵之间还会进行监控</strong>，这就形成了多哨兵模式。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/389c08b11d914b629bc9452c50d2b938.png" alt="img"></p><p>上图所示，多个哨兵之间也存在互相监控，这就形成了多哨兵模式，现在对该模式的工作过程进行讲解，介绍如下：</p><ol><li>主观下线</li></ol><p>主观下线，适用于主服务器和从服务器。如果在规定的时间内(配置参数：down-after-milliseconds)，Sentinel 节点没有收到目标服务器的有效回复，则判定该服务器为“主观下线”。比如 Sentinel1 向主服务发送了<code>PING</code>命令，在规定时间内没收到主服务器<code>PONG</code>回复，则 Sentinel1 判定主服务器为“主观下线”。</p><ol start="2"><li>客观下线</li></ol><p>客观下线，只适用于主服务器。 Sentinel1 发现主服务器出现了故障，它会通过相应的命令，询问其它 Sentinel 节点对主服务器的状态判断。如果超过半数以上的 Sentinel 节点认为主服务器 down 掉，则 Sentinel1 节点判定主服务为“客观下线”。</p><ol start="3"><li>投票选举</li></ol><p>投票选举，所有 Sentinel 节点会通过投票机制，按照谁发现谁去处理的原则，选举 Sentinel1 为领头节点去做 Failover（故障转移）操作。Sentinel1 节点则按照一定的规则在所有从节点中选择一个最优的作为主服务器，然后通过发布订功能通知其余的从节点（slave）更改配置文件，跟随新上任的主服务器（master）。至此就完成了主从切换的操作。</p><p>对上对述过程做简单总结：</p><p>Sentinel 负责监控主从节点的“健康”状态。当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接 Redis 集群时，会首先连接 Sentinel，通过 Sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 Sentinel 要地址，Sentinel 会将最新的主节点地址告诉客户端。因此应用程序无需重启即可自动完成主从节点切换。</p></li><li><p>配置文件详解</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel监听端口，默认是26379，可以修改。</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;sentinel.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line"><span class="built_in">dir</span> /mydata/redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line"><span class="comment"># 告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，</span></span><br><span class="line"><span class="comment"># master-name只能包含英文字母，数字，和“.-_”这三个字符</span></span><br><span class="line"><span class="comment"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效。</span></span><br><span class="line"><span class="comment"># 需要注意的是master-ip 要写真实的ip地址而不要用回环地址（127.0.0.1）。</span></span><br><span class="line">sentinel monitor mymaster 192.168.0.5 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line"><span class="comment">#设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</span></span><br><span class="line">sentinel auth-pass mymaster 000588</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span></span><br><span class="line"><span class="comment"># 这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为30秒</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </span></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line"><span class="comment"># failover-timeout 可以用在以下这些方面： </span></span><br><span class="line"><span class="comment">#  1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#  2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span></span><br><span class="line"><span class="comment">#  3.当想要取消一个正在进行的failover所需要的时间。  </span></span><br><span class="line"><span class="comment">#  4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。</span></span><br><span class="line">sentinel failover-timeout mymaster1 20000</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </span></span><br><span class="line"><span class="comment"># sentinel的notification-script和reconfig-script是用来配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment"># 若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment"># 若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment"># 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment"># 一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span></span><br><span class="line"><span class="comment"># sentinel notification-script mymaster /var/redis/notify.sh</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment">#       &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”, &lt;role&gt;是“leader”或者“observer”中的一个。 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的。这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span></span><br></pre></td></tr></table></figure></li><li><p>启动哨兵</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /etc/sentinel.conf      <span class="comment"># 指定配置文件启动</span></span><br><span class="line">ps -ef | grep sentinel                 <span class="comment"># 查看进程</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="九、集群搭建">九、集群搭建</h2><p>要让集群正常运作至少需要3个master节点，为了高可用，每个master节点至少要有一个slave节点，所以我们就用3个master节点+3个slave节点来搭建集群。</p><p>参考：<a href="https://baijiahao.baidu.com/s?id=1730440988136689035&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1730440988136689035&amp;wfr=spider&amp;for=pc</a></p><ul><li><p>搭建集群</p><p>修改redis.conf文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启集群模式</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 每一个节点需要有一个配置文件，需要6份。每个节点处于集群的角色都需要告知其他所有节点，彼此知道，这个文件用于存储集</span></span><br><span class="line">cluster-config-file nodes-6379.conf </span><br><span class="line"><span class="comment"># 超时时间，超时则认为master宕机，随后主备切换</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment"># 开启AOF</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;Redis&quot;&gt;Redis&lt;/h1&gt;
&lt;h2 id=&quot;一、Redis-入门&quot;&gt;一、Redis 入门&lt;/h2&gt;
&lt;p&gt;redis是一个key-value存储系统（键值数据库）</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL 学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/520fef84.html"/>
    <id>https://blog.halfsummer.xyz/posts/520fef84.html</id>
    <published>2023-03-13T23:15:45.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a href="https://blog.51cto.com/liuyj/5536362">https://blog.51cto.com/liuyj/5536362</a></p><h1 id="MySQL">MySQL</h1><h2 id="1）数据库知识点">1）数据库知识点</h2><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-20_11-13-21.png" alt="Snipaste_2022-12-20_11-13-21"></p><h2 id="2）数据库相关概念">2）数据库相关概念</h2><table><thead><tr><th>名称</th><th>全程</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织的进行存储</td><td>DataBase（BD）</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System（DBMS）</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准</td><td>Structured Query Language（SQL）</td></tr></tbody></table><h2 id="3）MySQL数据库版本">3）MySQL数据库版本</h2><ul><li>社区版（MySQL Community Server）</li><li>商业版（MySQL Enterprise Edition）</li></ul><h2 id="4）概述">4）概述</h2><ul><li><p><strong>关系型数据库（RDBMS）</strong></p><p>概念：建立在关系模型基础上，由多张互相连接的二维表组成的数据库。</p><p>特点：</p><ol><li>使用表存储数据，格式统一，便于维护。</li><li>使用SQL语言操作，标准统一，使用方便。</li></ol></li><li><p>数据模型</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-20_20-52-27.png" alt="Snipaste_2022-12-20_20-52-27"></p></li></ul><h2 id="5）MySQL-下载、安装与卸载">5）MySQL 下载、安装与卸载</h2><h3 id="5-1-Linux">5.1 Linux</h3><ul><li><p>基于CentOS 7.6</p><ol><li><p>安装前检查（注意：此步骤至关重要！！）</p><p>（1）更新 yum</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y upgrade</span><br></pre></td></tr></table></figure><p>（2）需要删除mariadb,会与MySQL冲突</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要删除mariadb,会与MySQL冲突</span></span><br><span class="line"><span class="comment"># 查询版本</span></span><br><span class="line">rpm -qa | grep mariadb</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">rpm -e mariadb-libs... --nodeps</span><br></pre></td></tr></table></figure><p>（3）检查MySQL残留，有则删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"><span class="comment"># 如果有，则执行</span></span><br><span class="line">yum remove mysql-....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有则继续</span></span><br><span class="line">find / -name mysql</span><br><span class="line"><span class="comment"># 或 </span></span><br><span class="line">whereis mysql</span><br><span class="line"><span class="built_in">rm</span> -rf ...删除上面查找到的文件和文件夹</span><br><span class="line"><span class="built_in">rm</span> -rf /etc/my.cnf</span><br><span class="line"><span class="built_in">rm</span> -rf /var/log/mysql*</span><br></pre></td></tr></table></figure><p>（4）检查服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld</span><br><span class="line"><span class="comment"># 如果是激活状态</span></span><br><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure></li><li><p>安装 MySQL</p><p>方法一：yum 安装</p><p>（1）配置Mysql 8.0安装源</p><p>查询最新版本的的方法 <a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-27_11-30-44.png" alt="Snipaste_2022-12-27_11-30-44"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 红框处修改命令中相应版本</span></span><br><span class="line">rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-7.noarch.rpm</span><br></pre></td></tr></table></figure><p>（2）yum安装MySQL</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql-server --nogpgcheck</span><br><span class="line"><span class="comment"># --nogpgcheck 是跳过公钥检查安装</span></span><br></pre></td></tr></table></figure><p>（3）启动服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><p>（4）查看临时密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;A temporary password&quot;</span> /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>方法二：编译安装（未整理）</p></li><li><p>卸载</p><p>一、yum 卸载</p><p>（1）卸载所有查询到的安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep -i mysql</span><br></pre></td></tr></table></figure><p>（2）删除所有查找到的目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure><p>（3）删除日志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /var/log/mysqld.log</span><br></pre></td></tr></table></figure></li><li><p>其他问题</p><p>（1）问题1：安装MySQL时提示：mysql-community-client-5.7.39-1.el7.x86_64.rpm 的<code>公钥</code>尚未安装。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2023130556677825144.png" alt="2023130556677825144"></p><p>解决方案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></pre></td></tr></table></figure><p>（2）问题2：查看内存不足或者缓存空间为0时可能启动不了服务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看错误信息</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到mysql的配置都在my.cnf</span></span><br><span class="line">$ whereis my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑my.cnf</span></span><br><span class="line">$ vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 添加或修改</span></span><br><span class="line">innodb_buffer_pool_size = 64M</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果不能启用服务请检查swap分区是否为0</span></span><br><span class="line">free -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配 1G空间给swap</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=1024</span><br><span class="line">mkswap /swapfile</span><br><span class="line">swapon /swapfile</span><br><span class="line"><span class="comment"># 添加这行 /swapfile swap swap defaults 0 0 到 /etc/fstab</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="5-2-MacOS（未整理）">5.2 MacOS（未整理）</h3><h3 id="5-3-Windows（未整理）">5.3 Windows（未整理）</h3><h3 id="5-4-Docker">5.4 Docker</h3><h2 id="基础">基础</h2><h3 id="1）SQL">1）SQL</h3><ul><li><p>SQL通用语法</p><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释：<ol><li>单行注释： <code>--</code>注释内容 或 <code>#</code> 注释内容（MySQL特有）</li><li>多行注释：<code>/* 注释内容*/</code></li></ol></li></ol></li><li><p><strong>SQL分类</strong></p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象（数据库、表、字段）</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据库操作语言，用来对数据库表中的数据进行增、删、改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中标的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table></li></ul><h3 id="2）DDL数据定义语言">2）DDL数据定义语言</h3><h4 id="2-1-数据库操作">2.1 数据库操作</h4><ul><li><p>查询数据库</p><p>查询所有数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p>查询当前使用的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELSECT DATABASE();</span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</span><br></pre></td></tr></table></figure><blockquote><p>[DEFAULT CHARSET 字符集]： <code>DEFAULT CHARSET utf8mb4</code></p></blockquote></li><li><p>删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>使用数据库（切换至）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-表操作">2.2 表操作</h4><ul><li><p>查询表</p><p>查询当前数据库内所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>查询表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br><span class="line"># 或者</span><br><span class="line">DESCRIBE 表名;</span><br></pre></td></tr></table></figure><p>查询指定表的建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure></li><li><p>创建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型[COMMENT &#x27;字段1注释&#x27;],</span><br><span class="line">字段2 字段2类型[COMMENT &#x27;字段2注释&#x27;],</span><br><span class="line">...</span><br><span class="line">字段n 字段n类型[COMMENT &#x27;字段n注释&#x27;],</span><br><span class="line">)[COMMENT &#x27;表注释&#x27;];</span><br></pre></td></tr></table></figure><blockquote><p><strong>数据类型:</strong></p><ol><li><p>数值类型</p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 Bytes</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 Bytes</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 Bytes</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 Bytes</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 Bytes</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 Bytes</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 Bytes</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table><p>注意：</p><ol><li><p>如果是无符号的范围可以加上 <code>UNSIGNED</code> （例：<code>age TINYINY UNSIGNED</code>）</p></li><li><p>浮点数共四个字节，小数为1位 （例：<code>score DOUBLE(4,1)</code>）</p></li></ol></li><li><p>日期和时间类型</p><table><thead><tr><th>类型</th><th>大小( bytes)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td>YYYY-MM-DD hh:mm:ss</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC<br />结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYY-MM-DD hh:mm:ss</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></li><li><p>字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>'变长’字符串会根据使用量来计算使用的空间，'定长’字符串会用空格来替代未使用的空间。但是两种方式当写入的数据超过指定的空间时都会报错。</p></li></ol></blockquote></li><li><p>修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure></li><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure><p>删除指定表，并重新创建该表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-字段操作">2.3 字段操作</h4><ul><li><p>添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT &#x27;注释&#x27;] [约束];</span><br></pre></td></tr></table></figure></li><li><p>修改</p><p>修改数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><p>修改字段名和字段类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT &#x27;注释&#x27;] [约束];</span><br></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3）DML数据操纵语言">3）DML数据操纵语言</h3><ul><li><p>添加数据</p><p>给指定字段添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2,....) VALUES (值1, 值2,...);</span><br></pre></td></tr></table></figure><p>给全部字段添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 VALUES (值1, 值2,...);</span><br></pre></td></tr></table></figure><p>批量添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段名1, 字段名2,....) VALUES (值1, 值2,...), (值1, 值2,...), ...;</span><br><span class="line">INSERT INTO 表名 VALUES (值1, 值2,...), (值1, 值2,...), ...;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期数据应该包含在引号中。</li><li>插入的数据大小，应该在字段规定的范围内。</li></ol></blockquote></li><li><p>修改数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 字段名1 = 值1,字段名2 = 值2,... [WHERE 条件];</span><br></pre></td></tr></table></figure></li><li><p>删除数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure></li></ul><h3 id="4）DQL数据查询语言">4）DQL数据查询语言</h3><p>1.编写与执行（#）顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表# 4</span><br><span class="line">FROM 表名列表# 1</span><br><span class="line">WHERE 条件列表# 2</span><br><span class="line">GROUP BY 分组字段列表# 3</span><br><span class="line">HAVING 分组后条件列表</span><br><span class="line">ORDER BY 排序字段列表# 5</span><br><span class="line">LIMIT 分页参数# 6</span><br></pre></td></tr></table></figure><p>2.查询方式</p><ul><li><p>基础查询</p><p>查询多个字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1, 字段2,... FROM 表名;</span><br><span class="line">SELECT * FROM 表名;    # 开发中尽量不使用*</span><br></pre></td></tr></table></figure><p>设置别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 [AS &#x27;别名1&#x27;], 字段2 [AS &#x27;别名2&#x27;],... FROM 表名;</span><br><span class="line">SELECT 字段1 [&#x27;别名1&#x27;], 字段2 [&#x27;别名2&#x27;],... FROM 表名;    # 同上</span><br></pre></td></tr></table></figure><p>去除重复记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure></li><li><p>条件查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure><blockquote><p><strong>运算符:</strong></p><ol><li><p>比较运算符</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN…AND…</td><td>在某个范围之内（含最小、最大值）</td></tr><tr><td>IN(…,…,…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table></li><li><p>逻辑运算符</p><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或</td><td></td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table></li></ol><hr><p>==条件查询中需要注意的例子==</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># BETWEEN 最小值 AND 最大值 （最小、最大值的顺序固定不能变）</span><br><span class="line">SELECT * FROM table1 Where age BETWEEN 14 AND 20;</span><br><span class="line"></span><br><span class="line"># 查询年龄为 15，,20，,30的人</span><br><span class="line">SELECT * FROM table1 Where age IN(15, 20, 30);</span><br><span class="line"></span><br><span class="line"># 查询名字为两个字的人</span><br><span class="line">SELECT * FROM table1 Where name LIKE &#x27;__&#x27;;</span><br><span class="line"></span><br><span class="line"># 查询身份证号最后一位为X的人</span><br><span class="line">SELECT * FROM table1 Where idcard LIKE &#x27;%X&#x27;;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>分组查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];</span><br></pre></td></tr></table></figure><blockquote><p>WHERE与HAVING区别:</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><hr><p>==eg.==</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 根据性别分组，统计男性员工和女性员工数量</span><br><span class="line">SELECT gender, COUNT(*) GROUP BY gender;</span><br><span class="line"></span><br><span class="line"># 根据性别分组，统计男性员工和女性员工的平均年龄</span><br><span class="line">SELECT gender, AVG(age) GROUP BY gender;</span><br><span class="line"></span><br><span class="line"># 查询年龄小于45的员工，并根据工作地址分组，获取员工数量大于等于3的工作地址</span><br><span class="line">SELECT workaddress, COUNT(*) WHERE age &lt;= 45 GROUP BY workaddress HAVING COUNT(*) &gt;= 3;</span><br></pre></td></tr></table></figure><p>注意：</p><p>执行顺序：where &gt; 聚合函数 &gt; having</p><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</p></blockquote></li><li><p>排序查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段1 排序方式2,...;</span><br></pre></td></tr></table></figure><blockquote><p>排序方式</p><ul><li><code>ASC</code> 升序（默认）</li><li><code>DESC</code> 降序</li></ul></blockquote></li><li><p>分页查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><strong>起始索引从0开始</strong>，起始索引等于（查询页码-1）*每页显示记录数。</li><li>分页查询是数据库的方言，<strong>不同的数据库有不同的实现</strong>，MySQL中是LIMIT。</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为<code>LIMIT 10</code>。</li></ol></blockquote></li></ul><p>3.聚合函数</p><p>将一列数据作为一个整体，进行纵向计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数(字段列表) FROM 表名;</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><blockquote><p>注意：null 不参与聚合函数的运算</p></blockquote><h3 id="5）DCL数据控制语言">5）DCL数据控制语言</h3><h4 id="5-1-管理用户">5.1 管理用户</h4><ul><li><p>查询用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM user;</span><br><span class="line"># 或者</span><br><span class="line">SELECT User FROM mysql.user;</span><br></pre></td></tr></table></figure></li><li><p>创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>修改用户密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;</span><br></pre></td></tr></table></figure></li><li><p>删除用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：</p><ul><li>主机名可以使用通配符<code>%</code>。</li><li>这类命令一般都是 DBA (Database Administrator 数据管理员) 使用。</li></ul></blockquote><h4 id="5-2-权限控制">5.2 权限控制</h4><ul><li><p>查询权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>授予权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># eg.</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">all</span> <span class="keyword">ON</span> database01.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;user01&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>撤销权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：</p><ul><li>多个权限之间，使用逗号分隔。</li><li>授权时，数据库名和表名可以使用<code>*</code>进行通配，代表所有。</li></ul><hr><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL,ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table></blockquote><h3 id="6）函数">6）函数</h3><p><strong>函数</strong>是指一段可以直接被另一端程序调用的程序或代码。（尽量不使用SQL去操作，提升性能。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 函数;</span><br></pre></td></tr></table></figure><h4 id="6-1-字符串函数">6.1 字符串函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…,Sn)</td><td>字符串拼接</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,strart,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><ul><li><p>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将id补充至5位（注意id需为varchar类型否则不能在前面添加0）</span><br><span class="line">UPDATE table1 SET id = LPAD(id,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-数值函数">6.2 数值函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><ul><li><p>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成6位随机验证码 随机数有可能生成小于6位的数字，所以用lapd左边补0</span><br><span class="line">select lpad(round(rand(),6) * 1000000,6,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-3-日期函数">6.3 日期函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日份</td></tr><tr><td>DATE_ADD(date,INTERVAL expr type)</td><td>返回一个日期/时间值加上一个事件间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间 date1 和 结束时间 date2 之间的天数</td></tr></tbody></table><h4 id="6-4-流程函数">6.4 流程函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(vaule, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(vaule1, vaule2)</td><td>如果value1不为空，则返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [val1] THEN [res1] … ELSE [default] END</td><td>如果val1为true，返回res1，否则返回default默认值</td></tr><tr><td>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td><td>如果expr等于val1，返回res1，否则返回default默认值</td></tr></tbody></table><h3 id="7）约束">7）约束</h3><p>约束是作用于表中字段上的规则，用于限制储存在表中的数据。</p><p>目的：保证数据库中数据的正确、有效性和完整性。</p><p>约束分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>自增约束</td><td>会在新记录插入表中时，生成一个唯一的数字</td><td>AUTO_INCREMENT</td></tr><tr><td><font style="color:red;">外键约束</font></td><td><font style="color:red;">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</font></td><td><font style="color:red;">FOREIGN KEY</font></td></tr></tbody></table><p>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># id唯一且自增 </span><br><span class="line">CREATE TABLE user(id int PRIMARY KEY AUTO_INCREMENT);</span><br><span class="line"># name不为空且不重复</span><br><span class="line">ALTER TABLE user ADD name VARCHAR(10) NOT NULL UNIQUE;</span><br></pre></td></tr></table></figure><ul><li><p><strong>外键约束</strong>（大厂一般不使用外键约束）</p><p>概念：</p><p>外键的主要作用是保证数据的一致性和完整性，并且减少数据冗余。主要体现在以下两个方面：</p><p>1.阻止执行</p><p>◆ 从表插入新行，其外键值不是主表的主键值便阻止插入。<br>◆ 从表修改外键值，新值不是主表的主键值便阻止修改。<br>◆ 主表删除行，其主键值在从表里存在便阻止删除(要想删除，必须先删除从表的相关行)。<br>◆ 主表修改主键值，旧值在从表里存在便阻止修改(要想修改，必须先删除从表的相关行)。<br>2.级联执行</p><p>◆ 主表删除行，连带从表的相关行一起删除。<br>◆ 主表修改主键值，连带从表相关行的外键值一起修改。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-23_20-24-38.png" alt="Snipaste_2022-12-23_20-24-38"></p><p>注意：目前上述的两张表，在数据库层面，并未建立外键关联，所以是无法保证数据的一致性和完整性的。</p><ul><li><p>添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY(外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名);</span><br></pre></td></tr></table></figure></li><li><p>删除外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br></pre></td></tr></table></figure></li><li><p>删除/更新行为</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与RESTRICT一致）。</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。（与NO ACTION一致）。</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求外键允许取null）。</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值（innodb不支持）</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>eg.</p><p>1.创建两张表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student</span><br><span class="line">(</span><br><span class="line">id int (11) primary key auto_increment,</span><br><span class="line">name char(255),</span><br><span class="line">    sex char(255),</span><br><span class="line">age int(11)</span><br><span class="line">)charset utf8;</span><br><span class="line"> </span><br><span class="line">CREATE TABLE student_score</span><br><span class="line">(</span><br><span class="line">id int (11) primary key auto_increment,</span><br><span class="line">class char(255),</span><br><span class="line">    score char(255),</span><br><span class="line">student_id int(11)</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure><p>2.创建外键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student_score </span><br><span class="line">ADD CONSTRAINT s_id FOREIGN KEY (student_id) REFERENCES student (id);</span><br></pre></td></tr></table></figure><p>3.验证外键的作用</p><p>（1）先向主表中添加数据，再向从表中添加数据（从表中的外键已在主表中存在），正常运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#向 student 表中添加数据</span><br><span class="line">INSERT INTO student(NAME, sex, age) VALUES(&#x27;小明&#x27;, &#x27;男&#x27;, &#x27;20&#x27;);</span><br><span class="line"></span><br><span class="line">#向 student_score 表中添加数据</span><br><span class="line">INSERT INTO student_score (class, score, student_id) VALUES(&#x27;语文&#x27;, &#x27;100&#x27;, 1),(&#x27;数学&#x27;, &#x27;99&#x27;, 1),(&#x27;英语&#x27;, &#x27;98&#x27;, 1);</span><br></pre></td></tr></table></figure><p>数据插入正常，无报错、警告信息。</p><p>（2）触发限制使用默认值 <code>RESTRICT</code> 的情况下</p><p>&lt;&lt;&lt;&lt;1&gt;从表插入新行，外键值不在主表中，被阻止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO student_score (class, score, student_id) VALUES(&#x27;语文&#x27;, &#x27;100&#x27;, 2);</span><br><span class="line">#[23000][1452] Cannot add or update a child row: a foreign key constraint fails (`test1`.`student_score`, CONSTRAINT `s_id` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`))</span><br></pre></td></tr></table></figure><p>&lt;&lt;&lt;&lt;2&gt;从表修改外键值，新值不是主表的主键值，阻止修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student_score</span><br><span class="line">SET student_id = 2 WHERE student_id = 1;</span><br><span class="line">#[23000][1452] Cannot add or update a child row: a foreign key constraint fails (`test1`.`student_score`, CONSTRAINT `s_id` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`))</span><br></pre></td></tr></table></figure><p>（3）主表删除行，其主键值在从表里存在便阻止删除(要想删除，必须先删除从表的相关行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM student WHERE id = 1;</span><br><span class="line">#[23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`test1`.`student_score`, CONSTRAINT `s_id` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`))</span><br></pre></td></tr></table></figure><p>（4）主表修改主键值，旧值在从表里存在便阻止修改(要想修改，必须先删除从表的相关行)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE student SET id = 2 WHERE id = 1;</span><br><span class="line">#[23000][1451] Cannot delete or update a parent row: a foreign key constraint fails (`test1`.`student_score`, CONSTRAINT `s_id` FOREIGN KEY (`student_id`) REFERENCES `student` (`id`))</span><br></pre></td></tr></table></figure></li></ul><h3 id="8）多表查询">8）多表查询</h3><h4 id="8-1-多表关系">8.1 多表关系</h4><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><p>1<strong>一对多(多对一)</strong></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-23_23-39-11.png" alt="Snipaste_2022-12-23_23-39-11"></p><p>2.<strong>多对多</strong></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-23_23-41-15.png" alt="Snipaste_2022-12-23_23-41-15"></p><p>SQL脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">create table student</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    name varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">    no   varchar(10) comment &#x27;学号&#x27;</span><br><span class="line">) comment &#x27;学生表&#x27;;</span><br><span class="line">insert into student</span><br><span class="line">values (null, &#x27;黛绮丝&#x27;, &#x27;2000100101&#x27;),</span><br><span class="line">       (null, &#x27;谢逊&#x27;, &#x27;2000100102&#x27;),</span><br><span class="line">       (null, &#x27;殷天正&#x27;, &#x27;2000100103&#x27;),</span><br><span class="line">       (null, &#x27;韦一笑&#x27;, &#x27;2000100104&#x27;);</span><br><span class="line">  </span><br><span class="line">create table course</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    name varchar(10) comment &#x27;课程名称&#x27;</span><br><span class="line">) comment &#x27;课程表&#x27;;</span><br><span class="line">insert into course</span><br><span class="line">values (null, &#x27;Java&#x27;),</span><br><span class="line">       (null, &#x27;PHP&#x27;),</span><br><span class="line">       (null, &#x27;MySQL&#x27;),</span><br><span class="line">       (null, &#x27;Hadoop&#x27;);</span><br><span class="line"> </span><br><span class="line">create table student_course</span><br><span class="line">(</span><br><span class="line">    id        int auto_increment comment &#x27;主键&#x27; primary key,</span><br><span class="line">    studentid int not null comment &#x27;学生ID&#x27;,</span><br><span class="line">    courseid  int not null comment &#x27;课程ID&#x27;,</span><br><span class="line">    constraint fk_courseid foreign key (courseid) references course (id),</span><br><span class="line">    constraint fk_studentid foreign key (studentid) references student (id)</span><br><span class="line">) comment &#x27;学生课程中间表&#x27;;</span><br><span class="line">insert into student_course</span><br><span class="line">values (null, 1, 1),</span><br><span class="line">       (null, 1, 2),</span><br><span class="line">       (null, 1, 3),</span><br><span class="line">       (null, 2, 2),</span><br><span class="line">       (null, 2, 3),</span><br><span class="line">       (null, 3, 4);</span><br></pre></td></tr></table></figure><p>3.<strong>一对一</strong></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-23_23-44-24.png" alt="Snipaste_2022-12-23_23-44-24"></p><p>SQL脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">create table tb_user</span><br><span class="line">(</span><br><span class="line">    id     int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    name   varchar(10) comment &#x27;姓名&#x27;,</span><br><span class="line">    age    int comment &#x27;年龄&#x27;,</span><br><span class="line">    gender char(1) comment &#x27;1: 男 , 2: 女&#x27;,</span><br><span class="line">    phone  char(11) comment &#x27;手机号&#x27;</span><br><span class="line">) comment &#x27;用户基本信息表&#x27;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">create table tb_user_edu</span><br><span class="line">(</span><br><span class="line">    id            int auto_increment primary key comment &#x27;主键ID&#x27;,</span><br><span class="line">    degree        varchar(20) comment &#x27;学历&#x27;,</span><br><span class="line">    major         varchar(50) comment &#x27;专业&#x27;,</span><br><span class="line">    primaryschool varchar(50) comment &#x27;小学&#x27;,</span><br><span class="line">    middleschool  varchar(50) comment &#x27;中学&#x27;,</span><br><span class="line">    university    varchar(50) comment &#x27;大学&#x27;,</span><br><span class="line">    userid        int unique comment &#x27;用户ID&#x27;,</span><br><span class="line">    constraint fk_userid foreign key (userid) references tb_user (id)</span><br><span class="line">) comment &#x27;用户教育信息表&#x27;;</span><br><span class="line"> </span><br><span class="line">insert into tb_user(id, name, age, gender, phone)</span><br><span class="line">values (null, &#x27;黄渤&#x27;, 45, &#x27;1&#x27;, &#x27;18800001111&#x27;),</span><br><span class="line">       (null, &#x27;冰冰&#x27;, 35, &#x27;2&#x27;, &#x27;18800002222&#x27;),</span><br><span class="line">       (null, &#x27;码云&#x27;, 55, &#x27;1&#x27;, &#x27;18800008888&#x27;),</span><br><span class="line">       (null, &#x27;李彦宏&#x27;, 50, &#x27;1&#x27;, &#x27;18800009999&#x27;);</span><br><span class="line">insert into tb_user_edu(id, degree, major, primaryschool, middleschool, university, userid)</span><br><span class="line">values (null, &#x27;本科&#x27;, &#x27;舞蹈&#x27;, &#x27;静安区第一小学&#x27;, &#x27;静安区第一中学&#x27;, &#x27;北京舞蹈学院&#x27;, 1),</span><br><span class="line">       (null, &#x27;硕士&#x27;, &#x27;表演&#x27;, &#x27;朝阳区第一小学&#x27;, &#x27;朝阳区第一中学&#x27;, &#x27;北京电影学院&#x27;, 2),</span><br><span class="line">       (null, &#x27;本科&#x27;, &#x27;英语&#x27;, &#x27;杭州市第一小学&#x27;, &#x27;杭州市第一中学&#x27;, &#x27;杭州师范大学&#x27;, 3),</span><br><span class="line">       (null, &#x27;本科&#x27;, &#x27;应用数学&#x27;, &#x27;阳泉第一小学&#x27;, &#x27;阳泉区第一中学&#x27;, &#x27;清华大学&#x27;, 4);</span><br></pre></td></tr></table></figure><h4 id="8-2-多表查询">8.2 多表查询</h4><p>1.数据准备</p><p>创建emp表与dept表并插入测试数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">-- 创建dept表，并插入数据</span><br><span class="line">create table dept</span><br><span class="line">(</span><br><span class="line">    id   int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">    name varchar(50) not null comment &#x27;部门名称&#x27;</span><br><span class="line">) comment &#x27;部门表&#x27; charset utf8;</span><br><span class="line">INSERT INTO dept (id, name)</span><br><span class="line">VALUES (1, &#x27;研发部&#x27;),</span><br><span class="line">       (2, &#x27;市场部&#x27;),</span><br><span class="line">       (3, &#x27;财务部&#x27;),</span><br><span class="line">       (4, &#x27;销售部&#x27;),</span><br><span class="line">       (5, &#x27;总经办&#x27;),</span><br><span class="line">       (6, &#x27;人事部&#x27;);</span><br><span class="line"></span><br><span class="line">-- 创建emp表，并插入数据</span><br><span class="line">create table emp</span><br><span class="line">(</span><br><span class="line">    id        int auto_increment comment &#x27;ID&#x27; primary key,</span><br><span class="line">    name      varchar(50) not null comment &#x27;姓名&#x27;,</span><br><span class="line">    age       int comment &#x27;年龄&#x27;,</span><br><span class="line">    job       varchar(20) comment &#x27;职位&#x27;,</span><br><span class="line">    salary    int comment &#x27;薪资&#x27;,</span><br><span class="line">    entrydate date comment &#x27;入职时间&#x27;,</span><br><span class="line">    managerid int comment &#x27;直属领导ID&#x27;,</span><br><span class="line">    dept_id   int comment &#x27;部门ID&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27; charset utf8;</span><br><span class="line"> </span><br><span class="line">-- 添加外键</span><br><span class="line">alter table emp</span><br><span class="line">    add constraint fk_emp_dept_id foreign key (dept_id) references dept (id);</span><br><span class="line">INSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)</span><br><span class="line">VALUES (1, &#x27;金庸&#x27;, 66, &#x27;总裁&#x27;, 20000, &#x27;2000-01-01&#x27;, null, 5),</span><br><span class="line">       (2, &#x27;张无忌&#x27;, 20, &#x27;项目经理&#x27;, 12500, &#x27;2005-12-05&#x27;, 1, 1),</span><br><span class="line">       (3, &#x27;杨逍&#x27;, 33, &#x27;开发&#x27;, 8400, &#x27;2000-11-03&#x27;, 2, 1),</span><br><span class="line">       (4, &#x27;韦一笑&#x27;, 48, &#x27;开发&#x27;, 11000, &#x27;2002-02-05&#x27;, 2, 1),</span><br><span class="line">       (5, &#x27;常遇春&#x27;, 43, &#x27;开发&#x27;, 10500, &#x27;2004-09-07&#x27;, 3, 1),</span><br><span class="line">       (6, &#x27;小昭&#x27;, 19, &#x27;程序员鼓励师&#x27;, 6600, &#x27;2004-10-12&#x27;, 2, 1),</span><br><span class="line">       (7, &#x27;灭绝&#x27;, 60, &#x27;财务总监&#x27;, 8500, &#x27;2002-09-12&#x27;, 1, 3),</span><br><span class="line">       (8, &#x27;周芷若&#x27;, 19, &#x27;会计&#x27;, 48000, &#x27;2006-06-02&#x27;, 7, 3),</span><br><span class="line">       (9, &#x27;丁敏君&#x27;, 23, &#x27;出纳&#x27;, 5250, &#x27;2009-05-13&#x27;, 7, 3),</span><br><span class="line">       (10, &#x27;赵敏&#x27;, 20, &#x27;市场部总监&#x27;, 12500, &#x27;2004-10-12&#x27;, 1, 2),</span><br><span class="line">       (11, &#x27;鹿杖客&#x27;, 56, &#x27;职员&#x27;, 3750, &#x27;2006-10-03&#x27;, 10, 2),</span><br><span class="line">       (12, &#x27;鹤笔翁&#x27;, 19, &#x27;职员&#x27;, 3750, &#x27;2007-05-09&#x27;, 10, 2),</span><br><span class="line">       (13, &#x27;方东白&#x27;, 19, &#x27;职员&#x27;, 5500, &#x27;2009-02-12&#x27;, 10, 2),</span><br><span class="line">       (14, &#x27;张三丰&#x27;, 88, &#x27;销售总监&#x27;, 14000, &#x27;2004-10-12&#x27;, 1, 4),</span><br><span class="line">       (15, &#x27;俞莲舟&#x27;, 38, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),</span><br><span class="line">       (16, &#x27;宋远桥&#x27;, 40, &#x27;销售&#x27;, 4600, &#x27;2004-10-12&#x27;, 14, 4),</span><br><span class="line">       (17, &#x27;陈友谅&#x27;, 42, null, 2000, &#x27;2011-10-12&#x27;, 1, null);</span><br></pre></td></tr></table></figure><p>2.概述</p><p>多表查询就是指从多张表中查询数据。原来查询单表数据，执行的SQL形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp;</span><br></pre></td></tr></table></figure><p>要执行多表查询，就只需要使用逗号分隔多张表即可:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp, dept; </span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130212342006.png" alt="image-20230130212342006"></p><p>（忽略一些数据）此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。</p><blockquote><p>《笛卡尔乘积》</p><p>笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-23_23-50-12.png" alt="Snipaste_2022-12-23_23-50-12"></p><p>在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/ffed86c8ebe3447686f5bccebbd44155.png" alt="img"></p><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp , dept where emp.dept_id = dept.id;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130212830125.png" alt="image-20230130212830125"></p><p>而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。</p></blockquote><h5 id="8-2-1-连接查询">8.2.1 连接查询</h5><ol><li><p>内连接：相当于查询A、B交集部分数据</p></li><li><p>外连接：</p><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p></li><li><p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p></li></ol><h6 id="1-内连接">1. 内连接</h6><p>相当于查询A、B交集部分数据</p><p>① 隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>, 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件...;</span><br></pre></td></tr></table></figure><p>② 显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><ul><li><p>eg.</p><ol><li><p>查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#表结构: emp , dept</span><br><span class="line">#连接条件: emp.dept_id = dept.id</span><br><span class="line"></span><br><span class="line">select emp.name, dept.name</span><br><span class="line">from emp,</span><br><span class="line">     dept</span><br><span class="line">where emp.dept_id = dept.id;</span><br><span class="line"># 为每一张表起别名,简化SQL编写</span><br><span class="line">select e.name,d.name from emp e , dept d where e.dept_id = d.id;</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130213622166.png" alt="image-20230130213622166"></p></li><li><p>查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select e.name, d.name</span><br><span class="line">from emp e</span><br><span class="line">         inner join dept d on e.dept_id = d.id;</span><br><span class="line"># 为每一张表起别名,简化SQL编写</span><br><span class="line">select e.name, d.name</span><br><span class="line">from emp e</span><br><span class="line">         join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。</p></blockquote></li></ol></li></ul><h6 id="2-外连接">2. 外连接</h6><p>① 左外连接：查询左表所有数据，以及两张表交集部分数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 相当于查询表<span class="number">1</span>（左表）的所有数据 包含表<span class="number">1</span>和表<span class="number">2</span>交集部分的数据</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><p>② 右外连接：查询右表所有数据，以及两张表交集部分数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [<span class="keyword">OUTER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure><ul><li><p>eg.</p><ol><li><p><strong>查询emp表的所有数据, 和对应的部门信息</strong></p><p>由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130214721226.png" alt="image-20230130214721226"></p></li><li><p><strong>查询dept表的所有数据, 和对应的员工信息(右外连接)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130214854779.png" alt="image-20230130214854779"></p></li></ol><blockquote><p>注意事项：</p><p>左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p></blockquote></li></ul><h6 id="3-自连接">3. 自连接</h6><p>当前表与自身的链接查询，自链接必须使用表别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表B 别名B ON 条件...;</span><br></pre></td></tr></table></figure><blockquote><p>对于自连接查询，可以是内连接查询，也可以是外连接查询</p><p>注意事项:</p><p>在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。</p></blockquote><ul><li><p>eg.</p><ol><li><p><strong>查询员工及其所属领导的名字</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.name, b.name from emp a, emp b where a.managerid = b.id;</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130220003537.png" alt="image-20230130220003537"></p></li><li><p><strong>查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.name &#x27;员工&#x27;, b.name &#x27;领导&#x27; from emp a left join emp b on a.managerid = b.id;</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130220032095.png" alt="image-20230130220032095"></p></li></ol></li></ul><h5 id="8-2-2-联合查询">8.2.2 联合查询</h5><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A ... </span><br><span class="line">UNION [ALL] </span><br><span class="line">SELECT 字段列表 FROM 表B ....;</span><br></pre></td></tr></table></figure><p>1.对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p><p>2.union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</p><ul><li><p>eg.</p><ol><li><p>将薪资低于 5000 的员工和年龄大于 50 岁的员工全部查询出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp WHERE salary &lt; 5000</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT * FROM emp WHERE age &gt; 50;</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130230029057.png" alt="image-20230130230029057"></p><blockquote><p>union all查询出来的结果，仅仅进行简单的合并，并未去重。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp WHERE salary &lt; 5000</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM emp WHERE age &gt; 50;</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230130230141485.png" alt="image-20230130230141485"></p><blockquote><p>union 联合查询，会对查询出来的结果进行去重处理。</p></blockquote></li></ol></li></ul><h5 id="8-2-3-子查询">8.2.3 子查询</h5><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 WHERE column = (SELECT column1 FROM t2);</span><br></pre></td></tr></table></figure><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><ul><li><p>根据子查询结果不同，分为：</p><ul><li><p><strong>标量子查询</strong>（子查询结果为单个值）</p><blockquote><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种查询称为标量子查询。</p><p>常用的操作符： <code>=</code> <code>&gt;</code> <code>≥</code> <code>&lt;</code> <code>≤</code> <code>&lt;&gt;</code></p></blockquote><ul><li><p>eg.</p><ol><li><p><strong>查询 “销售部” 的所有员工信息</strong></p><p>完成这个需求时，我们可以将需求分解为两步：</p><p>① 先查询 “销售部” 部门ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from dept where name = &#x27;销售部&#x27;;</span><br></pre></td></tr></table></figure><p>② 根据 “销售部” 部门ID, 查询员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where dept_id = (select id from dept where name = &#x27;销售部&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>查询在 “方东白” 入职之后的员工信息</strong></p><p>① 完成这个需求时，我们也可以将需求分解为两步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select entrydate from emp where name = &#x27;方东白&#x27;;</span><br></pre></td></tr></table></figure><p>② 查询指定入职日期之后入职的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where entrydate &gt; (select entrydate from emp where name = &#x27;方东白&#x27;);</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><strong>列子查询</strong>（子查询结果为一列）</p><blockquote><p>子查询返回的是一列（可以是多行的），这种查询称为列子查询。</p><p>常用操作符：<code>IN</code> <code>NOT IN</code> <code>ANY</code> <code>SOME</code> <code>ALL</code></p></blockquote><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><ul><li><p>eg.</p><ol><li><p><strong>查询 “销售部” 和 “市场部” 的所有员工信息</strong></p><p>完成这个需求时，我们可以将需求分解为两步：</p><p>① 查询 “销售部” 和 “市场部” 的部门ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM dept WHERE name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;;</span><br></pre></td></tr></table></figure><p>② 根据部门ID, 查询员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM emp WHERE dept_id in (SELECT id FROM dept WHERE name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>查询比 财务部 所有人工资都高的员工信息</strong></p><p>完成这个需求时，我们可以将需求分解为三步：</p><p>① 查询财务部的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM dept WHERE name = &#x27;财务部&#x27;;</span><br></pre></td></tr></table></figure><p>② 查询财务部所有人员的工资</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select salary</span><br><span class="line">from emp</span><br><span class="line">where dept_id = (select id from dept where name = &#x27;财务部&#x27;);</span><br></pre></td></tr></table></figure><p>③ 比财务部所有人工资都高的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where salary &gt; all (select salary from emp where dept_id = (select id from dept where name = &#x27;财务部&#x27;));</span><br></pre></td></tr></table></figure></li><li><p><strong>查询比研发部其中任意一人工资高的员工信息</strong></p><p>完成这个需求时，我们可以将需求分解为两步：</p><p>① 查询研发部所有人工资</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select salary</span><br><span class="line">from emp</span><br><span class="line">where dept_id = (select id from dept where name = &#x27;研发部&#x27;);</span><br></pre></td></tr></table></figure><p>② 比研发部其中任意一人工资高的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where salary &gt; any (select salary from emp where dept_id = (select id from dept where name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><strong>行子查询</strong>（子查询结果为一行）</p><blockquote><p>子查询返回的结果是一行（可以是多列），这种查询称为行子查询。</p><p>常用的操作符： <code>=</code> <code>&lt;&gt;</code> <code>IN</code> <code>NOT IN</code></p></blockquote><ul><li><p>eg.</p><ol><li><p><strong>查询与 “张无忌” 的薪资及直属领导相同的员工信息</strong></p><p>① 查询 “张无忌” 的薪资及直属领导</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select salary, managerid from emp where name = &#x27;张无忌&#x27;;</span><br></pre></td></tr></table></figure><p>② 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where (salary, managerid) = (select salary, managerid from emp where name = &#x27;张无忌&#x27;);</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><strong>表子查询</strong>（子查询结果为多行多列）</p><blockquote><p>子查询返回的结果是多行多列，这种查询称为表子查询。</p><p>常用的操作符：  <code>IN</code></p></blockquote><ul><li><p>eg.</p><ol><li><p><strong>查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</strong></p><p>① <strong>查询 “鹿杖客” , “宋远桥” 的职位和薪资</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select job, salary</span><br><span class="line">from emp</span><br><span class="line">where name = &#x27;鹿杖客&#x27;</span><br><span class="line">   or name = &#x27;宋远桥&#x27;;</span><br></pre></td></tr></table></figure><p>② <strong>查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from emp</span><br><span class="line">where (job, salary) in (select job, salary from emp where name = &#x27;鹿杖客&#x27; or name = &#x27;宋远桥&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</strong></p><p>① 入职日期是 “2006-01-01” 之后的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;;</span><br></pre></td></tr></table></figure><p>② 查询这部分员工, 对应的部门信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.*, d.*</span><br><span class="line">from (select * from emp where entrydate &gt; &#x27;2006-01-01&#x27;) e</span><br><span class="line">         left join dept d on e.dept_id = d.id;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul></li><li><p>根据子查询位置，分为:</p><ul><li>WHERE之后</li><li>FROM之后</li><li>SELECT之后</li></ul></li></ul><h3 id="9）事务">9）事务</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事物会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p><h4 id="9-1-事务的四大特性ACID">9.1 事务的四大特性ACID</h4><ul><li><p>原子性 (Atomicity):事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p></li><li><p>一致性 (Consistency):事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性 (Isolation):数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p></li><li><p>持久性 (Durability):事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><p><strong>注意：只有当前三条性质都满足了，才能保证事务的一致性</strong></p></li></ul><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2f0798cbce574f478c9f03ac813fff55.png" alt="在这里插入图片描述"></p><blockquote><p><strong>刷脏</strong>：Mysql为了保证存储效率，于是每次将要读写的文件是先存储在缓存池中，对于数据的操作是在缓存池中，而mysql将会定期的刷新到磁盘中。</p></blockquote><blockquote><p>1、如何保证原子性：</p><p>首先：对于A和B两操作要操作成功就一定需要更改到表的信息，如果如图所示A语句操作成功，而B语句操作时出现断电等其他情况终止了操作，所以此时两个事务没有操作成功，在没有提交事务之前，mysql会先记录跟新前的数据到undo log日志里面，当最终的因为操作不成功而发生事务回滚时，会从undo log日志里面先前存好的数据，重新对数据库的数据进行数据的回退。</p><p>undo log日志：（撤销回退的日志）主要存储数据库更新之前的数据，用于作备份</p><p>2、如何保证事务的持久性：</p><p>通过重做日志：redo log日志，对于用户将对发生了修改而为提交的数据存入了redo log日志中，当此时发生断电等其他异常时，可以根据redo log日志重新对数据做一个提交，做一个恢复。<br><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/e9263317bc3a4554b839a4efefbcf60d.png" alt="img"></p><p>3、隔离性：</p><blockquote><p>(1)事务的并发问题：</p><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据。</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了‘’幻影‘’。</td></tr></tbody></table><ol><li><p>脏读（读未提交）</p><p>事务A读取到了事务已经修改但未提交的数据，这种数据就叫脏数据，是不正确的</p></li></ol><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/0e5ac64c906c4d13b6dbdecda01b5910.png" alt="在这里插入图片描述"></p><ol start="2"><li><p>读已提交：（不可重复读）</p><p>不可重复读：对于事务A多次读取同一个数据时，由于其他是事务也在访问这个数据，进行修改且提交，对于事务A，读取同一个数据时，有可能导致数据不一致，叫不可重复读</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2b755a18343a4122a434c5d955804492.png" alt="在这里插入图片描述"></p></li><li><p>可重复读：（幻读）</p><p>幻读：原因：因为mysql数据库读取数据时，是将数据放入缓存中，当事务B对数据库进行操作：例如删除所有数据且提交时，事务A同样能访问到数据，这就产生了幻读。问题：解决了可重复读，但是会产生一种问题，错误的读取数据，对于其他事务添加的数据也将访问不到</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/86be832bbeb348ea8b736e6331ec58c0.png" alt="在这里插入图片描述"></p></li><li><p>串行化</p><p>串行化：事务A和事务B同时访问时，在事务A修改了数据，而没有提交数据时，此时事务B想增加或修改数据时，只能等待事务A的提交，事务B才能够执行。</p><p>问题：用户的体验十分的差，因为每次访问时都要等待其他事务的提交才能操作</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/03fed1e189d940fb912068ca894f4f6e.png" alt="在这里插入图片描述"></p></li></ol></blockquote><blockquote><p>(2)事务的隔离等级:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看事务的隔离级别</span><br><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br><span class="line"># 或者</span><br><span class="line">select @@global.tx_isolation,@@tx_isolation;</span><br><span class="line"></span><br><span class="line"># 设置事物隔离级别 （SESSION 为当前窗口）</span><br><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>隔离级别</th><th>中文</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><code>Read uncommitted</code></td><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td><code>Read committed</code></td><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td><code>Repeatable Read</code></td><td>可重复读(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td><code>Serializable</code></td><td>串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ol><li><p>读未提交：事物A和事物B，事物A未提交的数据，事物B可以读取到。 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别。 <strong>三种并发问题都没解决。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure></li><li><p>读已提交：事务A只能读取到事务B提交的数据，这种级别可以避免“脏数据” ，这种隔离级别会导致“不可重复读取” ，<strong>Oracle默认隔离级别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure></li><li><p>可重复读：- 事务A和事务B，事务A提交之后的数据，事务B读取不到 - 事务B是可重复读取数据 - 这种隔离级别高于读已提交 - 换句话说，对方提交之后的数据，我还是读取不到 - 这种隔离级别可以避免“不可重复读取”，达到可重复读取 - 比如1点和2点读到数据是同一个 - MySQL默认级别 - 虽然可以达到可重复读取，但是会导致“幻像读”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level repeatable read;</span><br></pre></td></tr></table></figure></li><li><p>串行化：事务A和事务B，事务A在操作数据库时，事务B只能排队等待 这种隔离级别很少使用，吞吐量太低，用户体验差 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行， 而不并发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level serializable;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>(3)隔离级别的一致性的关系：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/fe8bf94eb677468da203a783d44ade6a.png" alt="在这里插入图片描述"></p></blockquote></blockquote><h4 id="9-2-事务操作">9.2 事务操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前事务是否自动</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line"></span><br><span class="line"># 方法1</span><br><span class="line"># 查看/设置事务提交方式 1为自动提交 0为手动提交</span><br><span class="line">SET @@autocommit = 0;</span><br><span class="line"># 方法2</span><br><span class="line"># 开启事务</span><br><span class="line">START TRANSACTION 或 BEGIN;</span><br><span class="line"></span><br><span class="line"># 提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line"># 回滚事务</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><h2 id="进阶">进阶</h2><h3 id="1）存储引擎">1）存储引擎</h3><ol><li><p>MySQL体系结构</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/20200604182023796.png" alt="20200604182023796"></p><blockquote><ul><li><p>连接层</p><p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的完全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p></li><li><p>引擎层</p><p>存储引擎真正的负责了MySQL中数据的储存和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取核实的存储引擎。</p></li><li><p>存储层</p><p>主要是将数据存储在文件系统之上，并完成与储存引擎的交互。</p></li></ul></blockquote></li><li><p>存储引擎介绍</p><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询建表语句</span><br><span class="line">SHOW CREATE TABLE 表名;</span><br><span class="line"># ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br><span class="line"></span><br><span class="line"># 创建表时，指定存储引擎</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段1 字段1类型,</span><br><span class="line">....</span><br><span class="line">)ENGINE = 存储引擎 [COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"># 查看当前数据库支持的存储引擎</span><br><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure></li><li><p>存储引擎特性</p><p>1.采用的是插拔式的插件方式；<br>2.存储引擎是指定在表之上的，即一个库中的每一个表都可以指定选择存储引擎；<br>3.不管表采用什么样的存储引擎，都会在数据区，产生对应的一个.frm文件（表结构定义描述文件，下文有介绍。好像是在MySQL 8.0中，.frm 文件已经不存在了，此处以MySQL5.7介绍）<br><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-25_13-35-18.png" alt="Snipaste_2022-12-25_13-35-18"></p></li></ol><blockquote><p><strong>Tips：以下所有内容，基于 MySQL 5.7.28 版本介绍（CSV、Archive、Memory、InnoDB、MyISAM。其它引擎就不过多介绍）</strong></p></blockquote><h4 id="10-1-InnoDB存储引擎-5-5后默认-重要">10.1 InnoDB存储引擎(5.5后默认)(重要)</h4><p>10.1.1 InnoDB介绍</p><p>InnoDB特点总结：</p><p>​DML操作遵循ACID模型，支持事务；</p><p>​行级锁，提高并发访问性能；</p><p>​支持外键FOREIGN KEY约束，保证数据的完整性和正确性。</p><blockquote><p>在 MySQL 5.5 及以后版本后，MySQL 选择使用 InnoDB为默认存储引擎。在创建数据库表时，不指定存储引擎时，使用的就是 InnoDB。如需使用其他存储引擎，可以手动来指定。</p><p>特点：</p><ol><li>InnoDB 支持事务操作；（每一条SQL都默认封装成事务，自动提交，会影响速度）</li><li>InnoDB 支持外键；</li><li>InnoDB 是聚集索引（聚簇索引）；</li><li>InnoDB 不保存表的总条数；</li><li>InnoDB 5.7版本之前不支持全文检索；</li><li>InnoDB 支持表级锁、行级锁，默认为行级锁；</li><li>InnoDB 表必须有主键（如果我们没有明确去指定创建主键索引。它会帮我们隐藏的生成一个 6 byte 的 int 型的索引作为主键索引）；</li><li>InnoDB 文件存储方式为.frm文件存储表结构，ibd文件存储数据内容。</li></ol><blockquote><p>名词解释：</p><p>什么是聚集(簇)索引？</p><p>聚簇索引的特点是叶子节点包含了完整的记录行，而非聚簇索引的叶子节点只有所以字段和主键ID。</p><p>MySQL 索引采用 B+Tree（不熟悉？来跳转链接了解：MySQL 索引底层为什么选择B+Tree）。InnoDB 和 MyISAM 作为 MySQL 中 B+Tree 索引的两种重要体现形式。</p><p>InnoDB 推荐以主键作为索引来组织数据进行存储，它认为主键是一个非常重要的属性。InnoDB 表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键来构造一个B+树，叶子节点中存放的就是整张表的数据。</p><p>一般建表会用一个自增主键做聚簇索引，没有的话MySQL会默认创建，但是这个主键如果更改代价较高，故建表时要考虑自增ID不能频繁 update 这一点。</p><p>（估计你还看不懂，哈哈。那就看看这里你就懂了----&gt;MySQL一张表，比如有id(主键)，name，age等字段。我们可以建很多个索引，MySQL除了主键索引外，都是非聚簇索引。即只有我们创建的主键id索引，我们可以叫他id索引，它别名又叫做聚簇索引，（因为只有id索引，叶子节点包含了完整的记录行）理解成一个别名的即可。如果我们再创建一个name索引，它就叫做非聚簇索引，或者辅助索引。）【也可参考：MyISAM 和 InnoDB 的区别 文中介绍的聚簇索引】</p><p>我们日常工作中，根据实际情况自行添加的索引都是辅助索引，辅助索引就是一个为了需找主键索引的二级索引，现在找到主键索引再通过主键索引找数据；</p></blockquote></blockquote><p>InnoDB 支持的一些特性，我们在此无法验证，你只需要记住就好了。现在我们有一个<strong>db_store库</strong>，库中我们创建一个 employee 表，我们来看一下它在硬盘中的存储情况。</p><p>10.1.2 使用InnoDB存储引擎建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employee` (</span><br><span class="line">  `employeeID` int(11) NOT NULL,</span><br><span class="line">  `userName` varchar(16) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `phoneNum` varchar(32) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `createTime` datetime DEFAULT NULL,</span><br><span class="line">  `lastUpdate` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`employeeID`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;</span><br></pre></td></tr></table></figure><p>10.1.3 了解 InnoDB 硬盘存储方式</p><p>进入<code>/usr/local/mysql/data</code> 目录，再进入到 db_store 目录下，我们便能够很真实的看到数据库中的数据在硬盘中存储，它其实就是以两个文件（employee.frm、employee.ibd）的方式体现。(此处可以看到有employee 和 store 两个，说明 db_store 库下有两个表)</p><blockquote><p><strong>.frm 和 .ibd 格式文件介绍</strong></p><p><strong>.frm文件</strong>：保存的是表结构定义描述文件<br><strong>.ibd文件</strong>：保存的是employee表中的数据内容</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/20200605164659478.png" alt="在这里插入图片描述"></p></blockquote><h4 id="10-2-MyISAM存储引擎-早期默认">10.2 MyISAM存储引擎(早期默认)</h4><p>10.2.1 MyISAM介绍</p><p>MyISAM特点总结：</p><p>​不支持事务，不支持外键；</p><p>​支持表锁，不支持行锁；</p><p>​访问速度快。</p><blockquote><p>MyISAM 作为 MySQL 中 B+Tree 索引的另一种重要体现形式。</p><p>特点：</p><ol><li><p>MyISAM 是非聚集索引；</p></li><li><p>MyISAM 有一个变量专门来保存整个表的行数，查询count很快(注意不能加任何 where 条件)</p></li><li><p>MyISAM 支持全文索引；</p></li><li><p>MyISAM 可以被压缩后进行查询操作，节省空间容量；</p></li><li><p>MyISAM 支持表级锁，不支持行级锁；</p></li><li><p>MyISAM 中主键不是必须的；</p></li><li><p>MyISAM 文件存储方式为.frm文件存储表结构，.MYD文件存储数据内容，.MYI文件存储索引文件。</p></li></ol></blockquote><p>现在我们在<code>**db_store库**</code>，库中我们创建一个 employee_myisam 表，来看一下它在硬盘中的存储情况。</p><p>10.2.2 使用MyISAM存储引擎建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employee_myisam` (</span><br><span class="line">  `employeeID` int(11) NOT NULL,</span><br><span class="line">  `userName` varchar(16) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `phoneNum` varchar(32) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `createTime` datetime DEFAULT NULL,</span><br><span class="line">  `lastUpdate` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`employeeID`)</span><br><span class="line">) ENGINE=MyISAM CHARSET=utf8 COLLATE=utf8_bin;</span><br></pre></td></tr></table></figure><p>10.2.3 了解 MyIsam 硬盘存储方式</p><p>进入<code>/usr/local/mysql/data</code> 目录，再进入到 db_store 目录下，我们便能够很真实的看到数据库中的数据在硬盘中存储，它其实就是以**三个文件（xxx.frm、xxx.MYD、xxx.MYI）**的方式体现。</p><blockquote><p><strong>.frm | .MYD | .MYI 格式文件介绍</strong></p><p><strong>.frm文件</strong>：保存的是表结构定义描述文件<br><strong>.MYD文件</strong>：保存的是数据内容<br><strong>.MYI文件</strong>：保存的是索引内容</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/20200605171922206.png" alt="在这里插入图片描述"></p></blockquote><h4 id="10-MyISAM-和-InnoDB-的区别">10.- <a href="https://blog.csdn.net/lzb348110175/article/details/106575270">MyISAM 和 InnoDB 的区别</a></h4><h4 id="10-3-Memory存储引擎">10.3 Memory存储引擎</h4><p>表数据暂时存储在内存中，由于受硬件问题、断电的影响，只能将这些表作为临时表或缓存使用。</p><p>10.3.1 Memory介绍</p><p>特点：</p><p>​内存存放;</p><p>​hash索引（默认）。</p><blockquote><p>Memory存储引擎（在以往的版本中，又叫 Heap 存储引擎）。数据存储在内存中，在实际的应用场景中用到的很少，但是它与优化器查询有很大的关系，对临时表很有用。（不了解优化器查询？？请点击链接：不会MySQL调优？来来瞅瞅SQL的执行计划吧了解）</p><p>Memory中基于Hash索引，底层是 Hash 表，对于精确查询非常高效。即：在’='、'in’条件下高效，无法通过索引做区间查询。只能扫描全表。（范围查询、排序、组合索引效率不高）</p><p>特点：</p><ol><li>数据都是存储在内存中，IO效率比其他引擎高很多；（优点：效率高）</li><li>服务重启后数据会丢失，内存数据表默认只有16M（缺点：保证不了持久性）</li><li>支持 Hash索引，B Tree索引，默认为 Hash索引</li><li>不支持大数据存储类型，如 blog，text 等</li><li>表级锁</li></ol><blockquote><p>应用场景：</p><ol><li>等值查找热度较高数据；</li><li>查询结果在内存中进行计算，大多数都是采用这种存储引擎作为临时表存储需要计算的数据；</li></ol></blockquote></blockquote><p>工作中，使用内存管理这块，我们根本不需要考虑 Memory 这种存储引擎， Redis、Memcache 等它们不香吗？？Memory存储引擎更多的使用在 MySQL 优化器查询阶段。下面简单介绍一下：</p><p>在优化器查询阶段，会以生成一个 template 临时表的方式查询。它的内存数据表默认只有 16M，并不支持大数据类型的存储字段。在查询阶段，如果满足 Memory 存储引擎的所有条件，就会在优化器查询阶段使用 Memory 存储引擎。如果不满足条件，则会使用 MyISAM 引擎。</p><p>10.2.2 了解 Memory 硬盘存储方式</p><p>xxx.sdi：存储表结构信息</p><h4 id="10-4-Archive存储引擎">10.4 Archive存储引擎</h4><p>10.4.1 Archive介绍</p><blockquote><p>Archive存储引擎，是以<code>压缩协议</code>进行数据的存储</p><p><strong>特点：</strong></p><ol><li>只支持 insert 和 select 两种操作；<code>（缺点：不适用于对数据的处理操作）</code></li><li>只允许自增ID列建立索引<code>（缺点：还是不方便数据的处理）</code></li><li>支持行级锁</li><li>不支持事务</li><li>优点：数据占用磁盘少</li></ol><blockquote><p><strong>应用场景：</strong></p><ol><li>日志系统；</li><li>大量的设备数据采集；</li></ol></blockquote></blockquote><p>10.4.2 使用Archive存储引擎建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `users_archive` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `address` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=Archive;</span><br></pre></td></tr></table></figure><p>10.4.3 Archive对比InnoDB，使用函数批量存储1w条数据</p><p>Archive比InnoDB可以节省95%的容量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//批量添加函数:</span><br><span class="line">CREATE DEFINER=`root`@`%` PROCEDURE `users_archive_batchAdd`()</span><br><span class="line">begin</span><br><span class="line">    declare i int;</span><br><span class="line">    set i=1;</span><br><span class="line">    while i&lt;10000 do</span><br><span class="line">INSERT INTO users_archive(id,name,age,address) VALUES(i,concat(&#x27;James&#x27;,i),i,concat(&#x27;BeiJing&#x27;,i));</span><br><span class="line">        set i=i+1;</span><br><span class="line">     end while;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>10.4.3 查看数据所在硬盘位置</p><p>入到存储数据所在的硬盘下，便可以看到 users_archive 相关的表（<code>.frm</code> 为表结构文件；<code>.ARZ</code>为数据文件）</p><h4 id="10-5-CSV存储引擎">10.5 CSV存储引擎</h4><p>10.5.1 CSV介绍</p><blockquote><p>CSV存储引擎，数据是以CSV文件存储。</p><p>特点：</p><p>不能定义索引，列定义必须为NOT NULL，不能设置自增列；（缺点：不适用于大表或者数据查询、排序等处理操作）<br>CSV数据的存储需要用,逗号隔开，可直接编辑 CSV文件进行数据的编排（缺点：数据安全性低）可以对硬盘中保存的表文件数据进行直接编辑xxx.CSV文件，但是不能将该文件删除然后上传自己的同名.CSV文件(该文件中可能还有额外一些和表相关的数据)，我们只能对其中数据进行编辑操作。编辑之后，通过命令：flush table XXX表名的方式使其生效</p><blockquote><p><strong>应用场景：</strong></p><ol><li>数据的快速导入导出；</li><li>表格直接转换成CSV；</li></ol></blockquote></blockquote><p>10.5.2 使用CSV存储引擎建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `users_csv` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(255) NOT NULL,</span><br><span class="line">  `age` int(11) NOT NULL,</span><br><span class="line">  `address` varchar(255) NOT NULL</span><br><span class="line">) ENGINE=csv;</span><br></pre></td></tr></table></figure><p>10.5.3 查看数据所在硬盘位置</p><p>进入到存储数据所在的硬盘下，便可以看到 users_csv 相关的表（<code>.frm</code> 为表结构文件；<code>.CSV</code>为数据文件，<code>.CSM</code>不了解是干嘛的）</p><ol start="4"><li><p>存储引擎的选择</p><p>在选择存储引擎时，应该根据应用系统的特点选择核实的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB：是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常适合的。</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul></li></ol><h3 id="2）索引">2）索引</h3><p>索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><hr><h2 id="运维">运维</h2><h3 id="1）日志">1）日志</h3><h4 id="1-1-错误日志">1.1 错误日志</h4><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任故障导致无法正常使用时，建议首先查看此日志。</p><p>该日志是默认开启的，默认存放目录<code>/var/log/</code>，默认的日志文件名为 mysqld.log 。</p><ul><li><p>查看日志位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%log_error%&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>​<img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108172911709.png" alt="image-20230108172911709"></p><h4 id="1-2-二进制日志">1.2 二进制日志</h4><p>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和 DML (数据库操纵语言)语句，但不包括数据查询（SELECT、SHOW）语句。</p><ul><li><p>作用：</p><p>①灾难时的数据恢复；</p><p>②MySQL的主从复制；</p></li><li><p>查看日志位置：</p><p>在MySQL8版本中，默认二进制日志是开启着的，参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%log_bin%&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>​<img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108174925535.png" alt="image-20230108174925535"></p><ul><li><p>日志格式</p><ul><li><p>查看当前日志格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%binlog_format%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108175118768.png" alt="image-20230108175118768"></p></li></ul><ul><li><p>修改日志格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改参数</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><table><thead><tr><th>日志格式</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td style="text-align:left">基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中。</td></tr><tr><td>ROW</td><td style="text-align:left">基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td style="text-align:left">混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下回自动切换为ROW进行记录</td></tr></tbody></table></li></ul></li><li><p>日志查看</p><p>由于日志是以二进制方式存储的，不能直接读取，Linux 下需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [参数选项] logfilename</span><br><span class="line"></span><br><span class="line">参数选项：</span><br><span class="line">-d 指定数据库名称，只列出指定的数据库相关操作</span><br><span class="line">-o 忽略掉日志中的前n行命令</span><br><span class="line">-v 将行事件（数据变更）重构为SQL语句</span><br><span class="line">-vv 将行事件（数据变更）重构为SQL语句，并输出注释信息</span><br></pre></td></tr></table></figure></li><li><p>日志删除</p><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下方式清理日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reset master    # 删除全部binlog日志，删除之后，日志编号，将从binlog.000001开始</span><br><span class="line">purge master logs to &#x27;binlog.******&#x27;   # 删除 ****** 编号之前的所有日志</span><br><span class="line">purge master logs before &#x27;yyyy-mm-dd hh24:mi:ss&#x27;   # 删除日之味&quot;yyy-mm-dd hh24:mi:ss&quot;之前产生的所有日志</span><br></pre></td></tr></table></figure><p>也可以在MySQL的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。(默认单位为秒 30天)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%binlog_expire_logs_seconds%&#x27;;</span><br></pre></td></tr></table></figure></li></ul><p>​<img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108185211069.png" alt="image-20230108185211069"></p><h4 id="1-3-查询日志">1.3 查询日志</h4><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置一下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%general%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108185524882.png" alt="image-20230108185524882"></p><p>修改MySQL的配置文件<code>/etc/my.cnf</code>，添加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该选项用来开启查询日志，可选值：0或1,0代表关闭。</span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment"># 设置日志的文件名，如果没有指定，默认的文件名为 host_name.log</span></span><br><span class="line"><span class="comment"># general_log_file=mysql_query.log</span></span><br></pre></td></tr></table></figure><h4 id="1-4-慢查询日志">1.4 慢查询日志</h4><p>慢查询日志记录了所有执行事件超过参数 long_query_time 设置值并且扫描记录不小于 min_examined_row_limit 的所有的SQL语句日志，默认开启。  long_query_time 默认为10秒，最小为0，精度可以到微秒。</p><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements 和更改此行为 log_queries_not_using_indexes，如下所述。</p><p>修改配置文件<code>/etc/my.cnf</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 慢查询日志</span></span><br><span class="line">slow_query_log=1</span><br><span class="line"><span class="comment"># 执行时间参数(s)</span></span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 较少使用</span></span><br><span class="line"><span class="comment"># 记录执行较慢的管理语句</span></span><br><span class="line">log_slow_admin_statements=1</span><br><span class="line"><span class="comment"># 记录执行较慢的未使用索引的语句</span></span><br><span class="line">log_queries_not_using_indexes=1</span><br></pre></td></tr></table></figure><h3 id="2）主从复制">2）主从复制</h3><h4 id="2-1-概述">2.1 概述</h4><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从服务器中，然后再从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108195118263.png" alt="image-20230108195118263"></p><ul><li><p>MySQL 复制的优点主要包含以下三个方面：</p><ol><li><p>主库出现问题，可以快速切换到从库提供服务。</p></li><li><p>实现读写分离，降低主库的访问压力。</p></li><li><p>可以在从库中执行备份，以避免备份期间影响主库服务。</p></li></ol></li></ul><h4 id="2-2-原理">2.2 原理</h4><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108195630533.png" alt="image-20230108195630533"></p><p>从上图来看，复制分为三步：</p><ol><li><p>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p></li><li><p>从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log。</p></li><li><p>slave 重做中继日志中的事件，将改变反应到它自己的数据。</p></li></ol><h4 id="2-3-搭建">2.3 搭建</h4><p>服务器准备：</p><ul><li><p>关闭防火墙：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>或生产环境中开放指定的 3306 端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp -permanent</span><br><span class="line">firewall-cmd reload</span><br></pre></td></tr></table></figure></li><li><p>主库配置</p><ol><li><p>修改配置文件<code>/etc/my.cnf</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 服务ID，保证整个集群环境中唯一，取值范围：1——(2^32-1),默认为1</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment"># 是否只读，1代表只读，0代表读写</span></span><br><span class="line">read-only=0</span><br><span class="line"><span class="comment"># 忽略的数据，指不需要同步的数据库</span></span><br><span class="line"><span class="comment"># binlog-ignore-db=mysql</span></span><br><span class="line"><span class="comment"># 指定同步的数据库</span></span><br><span class="line"><span class="comment"># binlog-do-db=db01</span></span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure></li><li><p>登入mysql，创建远程连接的账号，并赋予主从复制的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建niubb用户，并设置密码，该用户可以在热议主机连接该Mysql服务</span><br><span class="line">CREATE USER &#x27;niubb&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Root@123456&#x27;;</span><br><span class="line"># 为 &#x27;niubb&#x27;@&#x27;%&#x27; 用户分配主从复制权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;niubb&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>通过指令，查看二进制日志坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108204046402.png" alt="image-20230108204046402"></p><p>字段的含义说明：</p><p>​file：从那个日志文件开始推送日志文件</p><p>​position： 从那个位置开始推送日志</p><p>​binlog_ignore_db：指定不需要同步的数据库</p></li></ol></li><li><p>从库配置</p><ol><li><p>修改配置文件<code>/etc/my.cnf</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 服务ID，保证整个集群环境中唯一，取值范围：1——(2^32-1),和主库不一样即可</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment"># 是否只读，1代表只读，0代表读写</span></span><br><span class="line">read-only=1</span><br><span class="line"><span class="comment"># （这里是对普通用户只读，如果有超级用户权限还是可以读写）如需想让超管只读</span></span><br><span class="line"><span class="comment"># super-read-only=1</span></span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><pre><code>   3. 登入MySQL,设置主库配置</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#x27;xxx.xxx.xxx.xxx&#x27;,SOURCE_USER=&#x27;xxx&#x27;,SOURCE_PASSWORD=&#x27;xxx&#x27;,SOURCE_LOG_FILE=&#x27;xxx&#x27;,SOURCE_LOG_POS=xxx;</span><br></pre></td></tr></table></figure><p>如果是8.0.23之前的版本，则执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER SOURCE TO MASTER_HOST=&#x27;xxx.xxx.xxx.xxx&#x27;,MASTER_USER=&#x27;xxx&#x27;,MASTER_PASSWORD=&#x27;xxx&#x27;,MASTER_LOG_FILE=&#x27;xxx&#x27;,MASTER_LOG_POS=xxx;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th><th>8.0.23之前</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td></td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td></td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td></td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td></td></tr></tbody></table><ul><li><p>ex.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#x27;xxx.xxx.xxx.xxx&#x27;,SOURCE_USER=&#x27;niubb&#x27;,SOURCE_PASSWORD=&#x27;Root@123456&#x27;,SOURCE_LOG_FILE=&#x27;binlog.000004&#x27;,SOURCE_LOG_POS=663;</span><br></pre></td></tr></table></figure><pre><code>  4. 开启同步操作</code></pre></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start replica;# 8.0.22之后</span><br><span class="line">start slave;# 8.0.22之前</span><br></pre></td></tr></table></figure></li><li><p>查看主从状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show replica status\G;</span><br><span class="line">start slave status;# 8.0.22之前</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108210823388.png" alt="image-20230108210823388"></p></li></ol></li><li><p>最后在主库里测试下从库能否同步。</p></li><li><p>注意：如果主库一开始有数据，应该备份后在从库里恢复后在进行主从连接。</p></li></ul><h3 id="3）分库分表">3）分库分表</h3><h4 id="3-1-概述">3.1 概述</h4><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108224641250.png" alt="image-20230108224641250"></p><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p><ol><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO,效率较低。请求数据太多，带宽不够，网络IO瓶颈。</li><li>CPU瓶颈：排序、分组、链接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。</li></ol><p>$\textcolor{red}{分库分表的中心思想是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。}$</p><ul><li><p>拆分策略</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108225426011.png" alt="image-20230108225426011"></p><ul><li><p>$\textcolor{orange}{垂直拆分}$</p><ul><li><p>$\textcolor{green}{垂直分库}$：以表为依据，根据业务将不同表拆分到不同库中。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108225546860.png" alt="image-20230108225546860"></p><p>特点：</p><ol><li>每个库的表结构都不一样。</li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ol></li><li><p>$\textcolor{green}{垂直分表}$：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108230215756.png" alt="image-20230108230215756"></p><p>特点：</p><ol><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键/外键）关联。</li><li>所有表的并集是全量数据。</li></ol></li></ul></li><li><p>$\textcolor{orange}{水平拆分}$</p><ul><li><p>$\textcolor{green}{水平分库}$：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108230833971.png" alt="image-20230108230833971"></p><p>特点：</p><ol><li>每个库的表结构都一样。</li><li>每个库的数据都不一样。</li><li>所有库的并集是全量数据。</li></ol></li><li><p>$\textcolor{green}{水平分表}$：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230108231035063.png" alt="image-20230108231035063"></p><p>特点：</p><ol><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。</li><li>所有表的并集是全量数据。</li></ol></li></ul></li></ul></li><li><p>实现技术</p><ul><li>==shardingJDBC==：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</li><li>==MyCat==：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li></ul></li></ul><h4 id="3-2-MyCat">3.2 MyCat</h4><p>MyCat 是开源的、活跃的、基于 Java 语言编写的 MySQL 数据库中间件。（出自阿里巴巴）</p><p>优势：性能可靠稳定、强大的技术团队、体系完善、社区活跃</p><h5 id="3-2-1-安装-MyCat">3.2.1 安装 MyCat</h5><p><a href="http://mycat.org.cn/">MyCat官网</a></p><ol><li><p>安装 Java 环境</p><p>a. yum 安装 jdk ：（默认的安装目录 <code>/usr/lib/jvm/java-1.8.0/</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure><p>b. 配置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>c. 添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/lib/jvm/java-1.8.0</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME JRE_HOME CLASS_PATH PATH</span><br></pre></td></tr></table></figure><p>d. 重新读取配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>e. 验证是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li><li><p>安装 MyCat</p><p>a.切换至opt目录，下载mycat安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">wget http://dl.mycat.org.cn/1.6.7.6/20210303094759/Mycat-server-1.6.7.6-release-20210303094759-linux.tar.gz</span><br></pre></td></tr></table></figure><p>b. 创建/apps文件夹，并解压mycat包至/apps下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /apps</span><br><span class="line">tar -zxvf Mycat-server-1.6.7.6-release-20210303094759-linux.tar.gz -C /apps/</span><br></pre></td></tr></table></figure><p>c. 设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;PATH=/apps/mycat/bin:$PATH&#x27;</span> &gt; /etc/profile.d/mycat.sh</span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/mycat.sh</span><br></pre></td></tr></table></figure><p>d. 启动mycat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意内存小于2G 起不来</span></span><br><span class="line">mycat start</span><br></pre></td></tr></table></figure><p>e. 查看日志 启动成功日志末尾会出现successfully</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /apps/mycat/logs/wrapper.log</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-2-2-概念">3.2.2 概念</h5><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230109003624302.png" alt="image-20230109003624302"></p><h5 id="3-2-3-配置">3.2.3 配置</h5><p><a href="https://blog.csdn.net/huasan994520/article/details/125150929">参考1</a></p><p>修改 MyCat 配置文件 <code>/apps/mycat/conf/schema.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vim  /apps/mycat/conf/schema.xml</span><br><span class="line">#删除所有内容，重新写入以下</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        #schema标签：数据库设置，此数据库为逻辑数据库，name与server.xml中schema对应。</span><br><span class="line">        #name:逻辑数据库名，与server.xml中的schema对应；</span><br><span class="line">        #checkSQLschema: 数据库前缀相关设置，这里为false；</span><br><span class="line">        #sqlMaxLimit:  select时默认的limit，避免查询全表，否则可能会遇到查询量特别大的情况造成卡 死；</span><br><span class="line">        #dataNode:表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_ORDER&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line">            #table标签: 逻辑表</span><br><span class="line">            #name: 逻辑表名</span><br><span class="line">            #dataNode:逻辑表关联的数据节点，表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name</span><br><span class="line">            #rule:分片规则</span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">        #dataNode标签: 定义mycat中的数据节点，也是通常说的数据分片，也就是分库相关配置</span><br><span class="line">        #name: 定义数据节点的名字，与table中dataNode对应</span><br><span class="line">        #datahost: 物理数据库名，与datahost中name对应，该属性用于定义该分片属于哪个数据库实例</span><br><span class="line">        #database: 物理数据库中数据库名，该属性用于定义该分片属性关联到物理数据库实例上的db01数据库</span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        #dataHost标签： 物理数据库，真正存储数据的数据库</span><br><span class="line">        #name: 物理数据库名，与dataNode中dataHost对应</span><br><span class="line">        #maxCon属性指定每个读写实例连接池的最大连接。也就是说，标签内嵌套的writeHost、readHost标  签都会使用这个属性的值来实例化出连接池的最大连接数</span><br><span class="line">        #minCon属性指定每个读写实例连接池的最小连接，初始化连接池的大小</span><br><span class="line">        #balance: 均衡负载的方式</span><br><span class="line">        #writeType: 写入方式</span><br><span class="line">        #dbType: 数据库类型</span><br><span class="line">        #dbDriver指定连接后端数据库使用的 Driver，目前可选的值有 native 和 JDBC。用 native 的话，因为这个值执行的是二进制的 mysql 协议，所以可以使用 mysql 和maridb。其他类型的数据库则需要使用 JDBC 驱动来支持。</span><br><span class="line">        #switchType:  “-1” 表示不自动切换； “1” 默认值，自动切换； “2” 基于 MySQL主从同步的状态决定是否切换心跳语句为 show slave status； “3” 基于 MySQL galary cluster 的切换机制（适合集群）（1.4.1）心跳语句为 show status like ‘wsrep%’.</span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                #heartbeat: 心跳检测语句，注意语句结尾的分号要加</span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.59.113:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">                #host：用于标识不同实例，一般 writeHost 我们使用*M1，readHost 我们用*S1。</span><br><span class="line">                #url：后端实例连接地址。Native：地址：端口 JDBC：jdbc的url</span><br><span class="line">                #user：后端存储实例需要的用户名字</span><br><span class="line">                #password:后端存储实例需要的密码</span><br><span class="line">                 <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.59.112:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">#readHost标签:从服务器设置</span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#schema.xml文件中有三点需要注意：balance=&quot;1&quot;，writeType=&quot;0&quot; ,switchType=&quot;1&quot; </span><br><span class="line">#schema.xml中的balance的取值决定了负载均衡对非事务内的读操作的处理。balance 属性负载均衡类型，目前的取值有 4 种：</span><br><span class="line">##balance=&quot;0&quot;：不开启读写分离机制，所有读操作都发送到当前可用的writeHost上,即读请求仅            发送到writeHost上</span><br><span class="line">##balance=&quot;1&quot;：一般用此模式，读请求随机分发到当前writeHost对应的readHost和standby的writeHost上。即全部的readHost与stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1 -&gt;S1 ， M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下， M2,S1, S2 都参与 select 语句的负载均衡</span><br><span class="line">##balance=&quot;2&quot;：读请求随机分发到当前dataHost内所有的writeHost和readHost上。即所有读操作都随机的在writeHost、 readhost 上分发</span><br><span class="line">##balance=&quot;3&quot;：读请求随机分发到当前writeHost对应的readHost上。即所有读请求随机的分发wiriterHost 对应的 readhost 执行, writerHost 不负担读压力，注意 balance=3 只在 1.4 及其以后版本有，1.3 没有</span><br><span class="line"></span><br><span class="line">###writeHost和readHost标签，这两个标签都指定后端数据库的相关配置给mycat，用于实例化后端连接池。唯一不同的是：writeHost指定写实例、readHost指定读实例，组着这些读写实例来满足系统的要求。在一个dataHost内可以定义多个writeHost和eadHost。但是，如果writeHost指定的后端数据库宕机，那么这个writeHost绑定的所有readHost都将不可用。另一方面，由于这个writeHost宕机系统会自动的检测到，并切换到备用的writeHost上去   </span><br><span class="line">               </span><br><span class="line">#PS：Mycat主从分离只是在读的时候做了处理，写入数据的时候，只会写入到writehost，需要通过mycat的主从复制将数据复制到readhost</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改 MyCat 配置文件 <code>/apps/mycat/conf/server.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#去掉44行行注释，对应的在51行行末注释，删除50行行末注释，5 * 60 * 1000L; //连接空&gt;    闲检查</span><br><span class="line"></span><br><span class="line">#修改45行端口号为3306</span><br><span class="line">45 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serverPort&quot;</span>&gt;</span>3306<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#配置Mycat的连接信息(账号密码)，在110 和111行， 可以修改，这边不修改了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">####参数解释说明####</span><br><span class="line">110         <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">111                 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">112                 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">113                 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSchema&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">116                 <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line">117                 <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">118                 &lt;privileges check=&quot;false&quot;&gt;</span></span><br><span class="line"><span class="comment">119                         &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="comment">120                                 &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">121                                 &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">122                         &lt;/schema&gt;</span></span><br><span class="line"><span class="comment">123                 &lt;/privileges&gt;   </span></span><br><span class="line"><span class="comment">124                  --&gt;</span></span><br><span class="line"></span><br><span class="line">127         <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">128                 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>user<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">129                 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">130                 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">131                 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSchema&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">user    用户配置节点</span><br><span class="line">name    逻辑用户名，客户端登录MyCAT的用户名，也就是客户端用来连接Mycat的用户名。</span><br><span class="line">password     客户端登录MyCAT的密码</span><br><span class="line">schemas      数据库名，这里会和schema.xml中的配置关联，可配置多个，多个用逗号分开，例如:db1,db2</span><br><span class="line">privileges   配置用户针对表的增删改查的权限</span><br><span class="line">readOnly mycat   逻辑库所具有的权限。true为只读，false为读写都有，默认为false</span><br><span class="line"></span><br><span class="line">##注意</span><br><span class="line">#server.xml文件里登录mycat的用户名和密码可以任意定义，这个账号和密码是为客户机登录mycat时使用的账号信息</span><br><span class="line">#逻辑库名(如上面的TESTDB，也就是登录mycat后显示的库名，切换这个库之后，显示的就是代理的真实mysql数据库的表)要在schema.xml里面也定义，否则会导致mycat服务启动失败！这里只定义了一个标签，所以把多余的都注释了。如果定义多个标签，即设置多个连接mycat的用户名和密码，那么就需要在schema.xml文件中定义多个对应的库！</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-2-4-启动服务">3.2.4 启动服务</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">mycat start</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">mycat stop</span><br></pre></td></tr></table></figure><p>MyCat启动之后，占用端口号 <code>8066</code> 。</p><h5 id="3-2-5-登入">3.2.5 登入</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h localhost -P8066 -uroot -p123456</span><br></pre></td></tr></table></figure><h5 id="3-2-6-配置文件详解">3.2.6 配置文件详解</h5><ul><li><p><strong>schema.xml</strong></p><ul><li><p><code>&lt;schema&gt;</code> 标签</p><p>用于定义 MyCat 实例中的逻辑库，一个 MyCat 实例中，可以有多个逻辑库，可以通过 schema 标签来划分不同的逻辑库。 MyCat中的逻辑库的概念，等同于 MySQL 中的database概念，需要操作某个逻辑库下的表时，也需要切换逻辑库(use xxx)。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230109224721920.png" alt="image-20230109224721920"></p><ul><li>name：指定自定义的逻辑库库名。</li><li>checkSQLschema：在 SQL 语句操作时指定了数据库名称，执行时是否自动去除；true-自动去除，false-不自动去除。</li><li>sqlMaxLimit：如果未指定 limit 进行查询，列表查询模式查询多少条记录。</li></ul></li><li><p><code>&lt;table&gt;</code> 标签（schema 中的 ）</p><p>table 标签定义了 MyCat 中逻辑库 schema 下的逻辑表，所有需要拆分的表都需要在 table 标签中定义。</p><ul><li>name：定义逻辑表表名，在该逻辑库下唯一。</li><li>dataNode：定义逻辑表所属的 dataNode，该属性需要与 dataNode 标签中 name 对应；多个 dataNode 逗号分割。</li><li>rule：分片规则的名字，分片规则名字是在 rule.xml 中定义的。</li><li>primaryKey：逻辑表对应真实表的主键。</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表配置为 global。</li></ul></li><li><p><code>&lt;dataNode&gt;</code> 标签</p><p>dataNode 标签中定义了 MyCat 中的数据节点，也就是我们通常说的数据分片。一个 dataNode 标签就是一个独立的数据分片。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230109233001717.png" alt="image-20230109233001717"></p><ul><li>name：定义数据节点名称。</li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中 name 属性。</li><li>database： 定义分片所属数据库。</li></ul></li><li><p><code>&lt;datahost&gt;</code> 标签</p><p>该标签在 MyCat 逻辑库中作为底层标签存在，直接定义了具体的数据实例、读写分离、心跳语句。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230109233711722.png" alt="image-20230109233711722"></p><ul><li><p>name：唯一标识，供上层标签使用。</p></li><li><p>maxCon/minCon：最大链接数/最小连接数。</p></li><li><p>balance：负载均衡策略，取值 0,1,2,3。</p></li><li><p>writeType：写操作分发方式（0：写操作妆发到第一个 writeHost，第一个挂了切换到第二个；1：写操作随机分发到配置的 writeHost）。</p></li><li><p>dbDriver：数据库驱动，支持 native、jdbc。</p></li></ul></li></ul></li><li><p><strong>rule.xml</strong></p><p>rule.xml 定义所有拆分表的规则，在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230109235344485.png" alt="image-20230109235344485"></p></li><li><p><strong>server.xml</strong></p><p>server.xml 配置文件包含了 MyCat 的系统配置信息，主要有两个重要的标签：system、user。</p><ul><li><p><code>&lt;system&gt;</code> 标签</p><p>对应的系统配置项及其含义，参考资料。</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230110000228552.png" alt="image-20230110000228552"></p></li><li><p><code>&lt;user&gt;</code> 标签</p><p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230110000636587.png" alt="image-20230110000636587"></p></li></ul></li></ul><h5 id="3-2-7-分片">3.2.7 分片</h5><h3 id="4）读写分离">4）读写分离</h3><h4 id="4-1-基于MyCat的读写分离">4.1 基于MyCat的读写分离</h4><p>修改<dataHost>的balance(负载均衡)属性，通过此属性配置读写分离的类型</p><p><strong>balance(负载均衡)类型目前有4种：</strong></p><ul><li>balance=“0”：不开启读写分离机制，所有读操作都发送到当前可用的 writeHost上。</li><li>balance=“1”：全部的readHost与stand by writeHost参与select语句的负载均衡，简单的说，当双主双从 模式(M1-&gt;S1，M2-&gt;S2，并且M1与M2互为主备)，正常情况下，M2,S1,S2 都参与select语句的负载均衡。</li><li>balance=“2”：所有读操作都随机的在writeHost、readhost 上分发。</li><li>balance=“3”：所有读请求随机的分发到readhost执行，writerHost不负担读压力。</li></ul><h5 id="4-1-1-一主一从">4.1.1 一主一从</h5><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2547829c773c415f8c2424bc266f3e57.jpeg" alt="在这里插入图片描述"></p><ol><li>搭建主从复制的过程（略）</li></ol><table>  <thead>    <tr>      <th>编号</th>      <th>角色</th>      <th><code>IP</code>地址</th>      <th>机器名</th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td><code>Master</code></td>      <td>192.168.110.146</td>      <td><code>ubuntu-mysql-master</code></td>    </tr>    <tr>      <td>2</td>      <td><code>Slaver</code></td>      <td>192.168.110.147</td>      <td><code>ubuntu-mysql-slaver</code></td>    </tr>  </tbody></table><ol start="2"><li>修改mycat配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;</span><br><span class="line">        &lt;/schema&gt;</span><br><span class="line">        &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;host1&quot; database=&quot;testdb&quot; /&gt;</span><br><span class="line">        &lt;dataHost name=&quot;host1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;</span><br><span class="line">                &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">                &lt;!-- can have multi write hosts --&gt;</span><br><span class="line">                &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.110.146:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt;</span><br><span class="line">                        &lt;!-- can have multi read hosts --&gt;</span><br><span class="line">                        &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.110.147:3306&quot; user=&quot;root&quot; password=&quot;123456&quot; /&gt;</span><br><span class="line">                &lt;/writeHost&gt;</span><br><span class="line">        &lt;/dataHost&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br></pre></td></tr></table></figure><h5 id="4-1-2-双主双从">4.1.2 双主双从</h5><blockquote><p>搭建参考：<a href="https://blog.csdn.net/qq_41779565/article/details/125375231">https://blog.csdn.net/qq_41779565/article/details/125375231</a></p></blockquote><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/f4d1c70368204ed0bedc2a7d1da18ca5.jpeg" alt="在这里插入图片描述"></p><ol><li>搭建主从复制的过程（略）</li></ol><table>  <thead>    <tr>      <th>编号</th>      <th>角色</th>      <th><code>IP</code>地址</th>      <th>机器名</th>    </tr>  </thead>  <tbody>    <tr>      <td>1</td>      <td><code>Master1</code></td>      <td>192.168.110.146</td>      <td><code>ubuntu-mysql-master</code></td>    </tr>    <tr>      <td>2</td>      <td><code>Slaver1</code></td>      <td>192.168.110.147</td>      <td><code>ubuntu-mysql-slaver</code></td>    </tr>    <tr>      <td>3</td>      <td><code>Master2</code></td>      <td>192.168.110.148</td>      <td><code>ubuntu-mysql-master2</code></td>    </tr>    <tr>      <td>4</td>      <td><code>Slaver2</code></td>      <td>192.168.110.149</td>      <td><code>ubuntu-mysql-slaver2</code></td>    </tr>  </tbody></table><ol start="2"><li>配置<code>Mycat</code>读写分离</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;</span><br><span class="line">        &lt;/schema&gt;</span><br><span class="line">        &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;host1&quot; database=&quot;testdb&quot; /&gt;</span><br><span class="line">        &lt;dataHost name=&quot;host1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;</span><br><span class="line">                &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">                &lt;!-- can have multi write hosts --&gt;</span><br><span class="line">                &lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.110.146:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt;</span><br><span class="line">                        &lt;!-- can have multi read hosts --&gt;</span><br><span class="line">                        &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.110.147:3306&quot; user=&quot;root&quot; password=&quot;123456&quot; /&gt;</span><br><span class="line">                &lt;/writeHost&gt;</span><br><span class="line">               &lt;writeHost host=&quot;hostM2&quot; url=&quot;192.168.110.148:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt;</span><br><span class="line">                        &lt;!-- can have multi read hosts --&gt;</span><br><span class="line">                        &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.110.149:3306&quot; user=&quot;root&quot; password=&quot;123456&quot; /&gt;</span><br><span class="line">                &lt;/writeHost&gt;</span><br><span class="line">        &lt;/dataHost&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>writeType=0：所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个。</li><li>writeType=1：所有写操作都随机的发送到配置的writeHost，1.5以后废弃不推荐。</li><li>writeHost：重新启动后以切换后的为准，切换记录在配置文件中：dnindex.properties 。</li><li>switchType：<ul><li>1 默认值，自动切换。</li><li>-1 表示不自动切换。</li><li>2 基于MySQL主从同步的状态决定是否切换。</li></ul></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.51cto.com/liuyj/5536362&quot;&gt;https://blog.51cto.com/liuyj/5536362&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shell编程 学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/edc1b716.html"/>
    <id>https://blog.halfsummer.xyz/posts/edc1b716.html</id>
    <published>2023-03-13T23:14:53.000Z</published>
    <updated>2023-03-13T17:11:01.902Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Shell">Shell</h1><h2 id="1-Shell-脚本">1.Shell 脚本</h2><h3 id="1-第一个shell脚本">1.第一个shell脚本</h3><p>打开文本编辑器，新建一个文本文件，并命名为 <a href="http://test.sh">test.sh</a>。扩展名<code>sh</code>代表 shell，扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用<code>php</code>好了。</p><p>在 <a href="http://test.sh">test.sh</a> 中输入代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span>  <span class="comment">#这是一条语句</span></span><br></pre></td></tr></table></figure><blockquote><p>第 1 行的<code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的<code>/bin/bash</code>就是指明了解释器的具体位置。</p><p>第 2 行的 echo 命令用于向标准输出文件（Standard Output，stdout，一般就是指显示器）输出文本。在<code>.sh</code>文件中使用命令与在终端直接输入命令的效果是一样的。</p><p>第 2 行的<code>#</code>及其后面的内容是注释。Shell 脚本中所有以<code>#</code>开头的都是注释（当然以<code>#!</code>开头的除外）。写脚本的时候，多写注释是非常有必要的，以方便其他人能看懂你的脚本，也方便后期自己维护时看懂自己的脚本——实际上，即便是自己写的脚本，在经过一段时间后也很容易忘记。</p></blockquote><p>下面给出了一段稍微复杂的 Shell 脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Copyright (c) http://nb.com/shell/</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line"><span class="built_in">read</span> PERSON</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$PERSON</span>&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>第 5 行中表示从终端读取用户输入的数据，并赋值给 PERSON 变量。read 命令用来从标准输入文件（Standard Input，stdin，一般就是指键盘）读取用户输入的数据。</p><p>第 6 行表示输出变量 PERSON 的内容。注意在变量名前边要加上<code>$</code>，否则变量名会作为字符串的一部分处理。</p></blockquote><h3 id="2-执行Shell脚本">2.执行Shell脚本</h3><p>运行 Shell 脚本有两种方法，一种在新进程中运行，一种是在当前 Shell 进程中运行。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230203110803080.png" alt="image-20230203110803080"></p><ul><li><p><strong>在新进程中运行 Shell 脚本</strong></p><p>在新进程中运行 Shell 脚本有多种方法：</p><ol><li><p>将 Shell 脚本作为程序运行</p><p>Shell 脚本也是一种解释执行的程序，可以在终端直接调用（需要使用 chmod 命令给 Shell 脚本加上执行权限）如下所示:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo                <span class="comment">#切换到 test.sh 所在的目录</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">chmod</span> +x ./test.sh  <span class="comment">#给脚本添加执行权限</span></span><br><span class="line">[root@localhost demo]$ . ./test.sh           <span class="comment">#执行脚本文件</span></span><br><span class="line">Hello World !                                  <span class="comment">#运行结果</span></span><br></pre></td></tr></table></figure><blockquote><p>第 2 行中，<code>chmod +x</code>表示给 <a href="http://test.sh">test.sh</a> 增加执行权限。</p><p>第 3 行中，<code>./</code>表示当前目录，整条命令的意思是执行当前目录下的 <a href="http://test.sh">test.sh</a> 脚本。如果不写<code>./</code>，Linux 会到系统路径（由 PATH 环境变量指定）下查找 <a href="http://test.sh">test.sh</a>，而系统路径下显然不存在这个脚本，所以会执行失败。</p></blockquote><p>通过这种方式运行脚本，脚本文件第一行的<code>#!/bin/bash</code>一定要写对，好让系统查找到正确的解释器。</p></li><li><p>将 Shell 脚本作为参数传递给 Bash 解释器</p><p>你也可以直接运行 Bash 解释器，将脚本文件的名字作为参数传递给 Bash，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo               <span class="comment">#切换到 test.sh 所在的目录</span></span><br><span class="line">[root@localhost demo]$ /bin/bash test.sh  <span class="comment">#使用Bash的绝对路径</span></span><br><span class="line">Hello World !                                 <span class="comment">#运行结果</span></span><br></pre></td></tr></table></figure><p>通过这种方式运行脚本，不需要在脚本文件的第一行指定解释器信息，写了也没用。</p><p>更加简洁的写法是运行 bash 命令。bash 是一个外部命令，Shell 会在 /bin 目录中找到对应的应用程序，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[root@localhost demo]$ bash test.sh</span><br><span class="line">Hello World !</span><br></pre></td></tr></table></figure><p>这两种写法在本质上是一样的：第一种写法给出了绝对路径，会直接运行 Bash 解释器；第二种写法通过 bash 命令找到 Bash 解释器所在的目录，然后再运行，只不过多了一个查找的过程而已。</p></li></ol><p>◇ <u>检测是否开启了新进程</u></p><p>Linux 中的每一个进程都有一个唯一的 ID，称为 PID，使用<code>$$</code>变量就可以获取当前进程的 PID。<code>$$</code>是 Shell 中的特殊变量。</p><p>首先编写如下的脚本文件，并命名为 <a href="http://check.sh">check.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> $$  <span class="comment">#输出当前进程PID</span></span><br></pre></td></tr></table></figure><p>然后使用以上两种方式来运行 <a href="http://check.sh">check.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">2861  <span class="comment">#当前进程的PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">chmod</span> +x ./check.sh</span><br><span class="line">[root@localhost demo]$ ./check.sh</span><br><span class="line">4597  <span class="comment">#新进程的PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">2861  <span class="comment">#当前进程的PID</span></span><br><span class="line">[root@localhost demo]$ /bin/bash check.sh</span><br><span class="line">4584  <span class="comment">#新进程的PID</span></span><br></pre></td></tr></table></figure><p>你看，进程的 PID 都不一样，当然就是两个进程了。</p></li><li><p><strong>在当前进程中运行 Shell 脚本</strong></p><p>这里需要引入一个新的命令——source 命令。source 是 Shell 内置命令的一种，它会读取脚本文件中的代码，并依次执行所有语句。你也可以理解为，source 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。</p><p>source 命令的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> filename</span><br><span class="line"><span class="comment"># 也可以简写为：</span></span><br><span class="line">. filename</span><br></pre></td></tr></table></figure><p>两种写法的效果相同。对于第二种写法，注意点号<code>.</code>和文件名中间有一个空格。</p><p>例如，使用 source 运行上节的 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo              <span class="comment">#切换到test.sh所在的目录</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">source</span> ./test.sh  <span class="comment">#使用source</span></span><br><span class="line">Hello World !</span><br><span class="line">[root@localhost demo]$ <span class="built_in">source</span> test.sh    <span class="comment">#使用source</span></span><br><span class="line">Hello World !</span><br><span class="line">[root@localhost demo]$ . ./test.sh       <span class="comment">#使用点号</span></span><br><span class="line">Hello World !</span><br><span class="line">[root@localhost demo]$ . test.sh         <span class="comment">#使用点号</span></span><br><span class="line">Hello World !</span><br></pre></td></tr></table></figure><p>你看，使用 source 命令不用给脚本增加执行权限，并且写不写<code>./</code>都行，是不是很方便呢？</p><p>◇ <u>检测是否在当前 Shell 进程中</u></p><p>我们仍然借助<code>$$</code>变量来输出进程的 PID，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">5169  <span class="comment">#当前进程PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">source</span> ./check.sh</span><br><span class="line">5169  <span class="comment">#Shell脚本所在进程PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">5169  <span class="comment">#当前进程PID</span></span><br><span class="line">[root@localhost demo]$ . ./check.sh</span><br><span class="line">5169  <span class="comment">#Shell脚本所在进程PID</span></span><br></pre></td></tr></table></figure><p>你看，进程的 PID 都是一样的，当然是同一个进程了。</p></li></ul><hr><h2 id="2-变量">2.变量</h2><p>变量是任何一种编程语言都必不可少的组成部分，变量用来存放各种数据。脚本语言在定义变量时通常不需要指明类型，直接赋值就可以，Shell 变量也遵循这个规则。</p><p>在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</p><p>这意味着，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。例如在C语言或者 C++ 中，变量分为整数、小数、字符串、布尔等多种类型。</p><p>当然，如果有必要，你也可以使用 <code>Shell declare</code> 关键字显式定义变量的类型，但在一般情况下没有这个需求，Shell 开发者在编写代码时自行注意值的类型即可。</p><h3 id="1-定义变量">1.定义变量</h3><p>Shell 支持以下三种定义变量的方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br><span class="line">variable=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">variable=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure><p>variable 是变量名，value 是赋给变量的值。如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的，稍后我们会详细说明。</p><p><font style="color:red;">注意，赋值号<code>=</code>的周围不能有空格，这可能和你熟悉的大部分编程语言都不一样。</font></p><p>Shell 变量的命名规范和大部分编程语言都一样：</p><ul><li>变量名由数字、字母、下划线组成；</li><li>必须以字母或者下划线开头；</li><li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li></ul><p>变量定义举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://niu.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$url</span></span><br><span class="line">name=<span class="string">&#x27;niu&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">author=<span class="string">&quot;niu&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$author</span></span><br></pre></td></tr></table></figure><h3 id="2-使用变量">2.使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code>即可，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">author=<span class="string">&quot;niu&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$author</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;author&#125;</span></span><br></pre></td></tr></table></figure><p>变量名外面的花括号<code>&#123; &#125;</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skill=<span class="string">&quot;Java&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$&#123;skill&#125;</span>Script&quot;</span></span><br></pre></td></tr></table></figure><p>如果不给 skill 变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把 $skillScript 当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p><font style="color:red;">推荐给所有变量加上花括号<code>&#123;&#125;</code>，这是个良好的编程习惯。</font></p><ul><li><p>修改变量的值</p><p>已定义的变量，可以被重新赋值，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://niu.com&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url&#125;</span></span><br><span class="line">url=<span class="string">&quot;http://niu.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url&#125;</span></span><br></pre></td></tr></table></figure><p>第二次对变量赋值时不能在变量名前加<code>$</code>，只有在使用变量时才能加<code>$</code>。</p></li><li><p>单引号和双引号的区别</p><p>前面我们还留下一个疑问，定义变量时，变量的值可以由单引号<code>' '</code>包围，也可以由双引号<code>&quot; &quot;</code>包围，它们到底有什么区别呢？不妨以下面的代码为例来说明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://niu.net&quot;</span></span><br><span class="line">website1=<span class="string">&#x27;niubb：$&#123;url&#125;&#x27;</span></span><br><span class="line">website2=<span class="string">&quot;niubb：<span class="variable">$&#123;url&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$website1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$website2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">niubb：<span class="variable">$&#123;url&#125;</span></span><br><span class="line">niubb：niu.net</span><br></pre></td></tr></table></figure><p>以单引号<code>' '</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p><p>以双引号<code>&quot; &quot;</code>包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p><p><font style="color:red;">我的建议：如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</font></p></li><li><p>将命令的结果赋值给变量</p><p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`<span class="built_in">command</span>`</span><br><span class="line">variable=$(<span class="built_in">command</span>)</span><br></pre></td></tr></table></figure><p>第一种方式把命令用反引号<code> </code>（位于 Esc 键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</p><p>例如，我在 demo 目录中创建了一个名为 log.txt 的文本文件，用来记录我的日常工作。下面的代码中，使用 cat 命令将 log.txt 的内容读取出来，并赋值给一个变量，然后使用 echo 命令输出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[root@localhost demo]$ <span class="built_in">log</span>=$(<span class="built_in">cat</span> log.txt)</span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> <span class="variable">$log</span></span><br><span class="line">严长生正在编写Shell教程，教程地址：http://nb.com/shell/</span><br><span class="line">[root@localhost demo]$ <span class="built_in">log</span>=`<span class="built_in">cat</span> log.txt`</span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> <span class="variable">$log</span></span><br><span class="line">严长生正在编写Shell教程，教程地址：http://nb.com/shell/</span><br></pre></td></tr></table></figure></li><li><p>只读变量</p><p>使用 <strong>readonly</strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>下面的例子尝试更改只读变量，结果报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">myUrl=<span class="string">&quot;http://nb.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">&quot;http://nb.com/shell/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，结果如下：</span></span><br><span class="line">bash: myUrl: This variable is <span class="built_in">read</span> only.</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-删除变量">3.删除变量</h3><p>使用 <strong>unset</strong> 命令可以删除变量。语法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure><p>变量被删除后不能再次使用；unset 命令不能删除只读变量。</p><p>举个例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">myUrl=<span class="string">&quot;http://nb.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">unset</span> myUrl</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$myUrl</span></span><br></pre></td></tr></table></figure><p>上面的脚本没有任何输出。</p><h3 id="4-变量的作用域">4.变量的作用域</h3><p>Shell 变量的作用域可以分为三种：</p><p>有的变量只能在函数内部使用，这叫做局部变量（local variable）；有的变量可以在当前 Shell 进程中使用，这叫做全局变量（global variable）；而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）。</p><ol><li><h4 id="局部变量">局部变量</h4><p>Shell 也支持自定义函数，但是 Shell 函数和 C++、Java、C# 等其他编程语言函数的一个不同点就是：在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果。请看下面的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># vim local.sh </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">[root@www ~]<span class="comment"># chmod o+x local.sh </span></span><br><span class="line">[root@www ~]<span class="comment"># ./local.sh </span></span><br><span class="line">99</span><br></pre></td></tr></table></figure><p>a 是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。</p><p>要想变量的作用域仅限于函数内部，可以在定义时加上local命令，此时该变量就成了局部变量。请看下面的代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">local</span> a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p>输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。</p><p>Shell 变量的这个特性和 <code>JavaScript</code> 中的变量是类似的。在 <code>JavaScript</code> 函数内部定义的变量，默认也是全局变量，只有加上<code>var</code>关键字，它才会变成局部变量。</p></li><li><h4 id="全局变量">全局变量</h4><p>所谓全局变量，就是指变量在当前的整个 Shell 进程中都有效。每个 Shell 进程都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。</p><p>想要实际演示全局变量在不同 Shell 进程中的互不相关性，可在图形界面下同时打开两个 Shell，或使用两个终端远程连接到服务器（SSH）。</p><p>首先打开一个 Shell 窗口，定义一个变量 a 并赋值为 99，然后打印，这时在同一个 Shell 窗口中是可正确打印变量 a 的值的。然后再打开一个新的 Shell 窗口，同样打印变量 a 的值，但结果却为空，如图所示。</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230203112522488.png" alt="image-20230203112522488"></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230203112254433.png" alt="image-20230203112254433"></p><p>这说明全局变量 a 仅仅在定义它的第一个 Shell 进程中有效，对新的 Shell 进程没有影响。这很好理解，就像小王家和小徐家都有一部电视机（变量名相同），但是同一时刻小王家和小徐家的电视中播放的节目可以是不同的（变量值不同）。</p><p>需要强调的是，全局变量的作用范围是当前的 Shell 进程，而不是当前的 Shell 脚本文件，它们是不同的概念。打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID。在一个 Shell 进程中可以使用 source 命令执行多个 Shell 脚本文件，此时全局变量在这些脚本文件中都有效。</p><p>例如，现在有两个 Shell 脚本文件，分别是 <a href="http://a.sh">a.sh</a> 和 <a href="http://b.sh">b.sh</a>。<a href="http://a.sh">a.sh</a> 的代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">b=200</span><br></pre></td></tr></table></figure><p><a href="http://b.sh">b.sh</a> 的代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure><p>打开一个 Shell 窗口，输入以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># a=99</span></span><br><span class="line">[root@localhost ~]<span class="comment"># . ./a.sh</span></span><br><span class="line">99</span><br><span class="line">[root@localhost ~]<span class="comment"># . ./b.sh</span></span><br><span class="line">200</span><br></pre></td></tr></table></figure><p>这三条命令都是在一个进程中执行的，从输出结果可以发现，在 Shell 窗口中以命令行的形式定义的变量 a，在 <a href="http://a.sh">a.sh</a> 中有效；在 <a href="http://a.sh">a.sh</a> 中定义的变量 b，在 <a href="http://b.sh">b.sh</a> 中也有效，变量 b 的作用范围已经超越了 <a href="http://a.sh">a.sh</a>。</p><p>注意，必须在当前进程中运行 Shell 脚本，不能在新进程中运行 Shell 脚本。</p></li><li><h4 id="Shell-环境变量">Shell 环境变量</h4></li></ol><p>全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用<code>export</code>命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</p><p>环境变量被创建时所处的 Shell 进程称为父进程，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 Shell 子进程。当 Shell 子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。不难理解，环境变量还可以传递给孙进程。</p><p>注意，两个没有父子关系的 Shell 进程是不能传递环境变量的，并且环境变量只能向下传递而不能向上传递，即“传子不传父”。</p><p>创建 Shell 子进程最简单的方式是运行 bash 命令，如图所示：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1-1Z41QJGN02.gif" alt="进入Shell子进程"></p><p>通过<code>exit</code>命令可以一层一层地退出 Shell。</p><p>下面演示一下环境变量的使用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># a=22       #定义一个全局变量</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $a    #在当前Shell中输出a，成功</span></span><br><span class="line">22</span><br><span class="line">[root@localhost ~]<span class="comment"># bash       #进入Shell子进程</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $a    #在子进程中输出a，失败</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># exit       #退出Shell子进程，返回上一级Shell</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost ~]<span class="comment"># export a   #将a导出为环境变量</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash       #重新进入Shell子进程</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $a    #在子进程中再次输出a，成功</span></span><br><span class="line">22</span><br><span class="line">[root@localhost ~]<span class="comment"># exit       #退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost ~]<span class="comment"># exit       #退出父进程，结束整个Shell会话</span></span><br></pre></td></tr></table></figure><p>可以发现，默认情况下，a 在 Shell 子进程中是无效的；使用 export 将 a 导出为环境变量后，在子进程中就可以使用了。</p><p><code>export a</code>这种形式是在定义变量 a 以后再将它导出为环境变量，如果想在定义的同时导出为环境变量，可以写作<code>export a=22</code>。</p><p>我们一直强调的是环境变量在 Shell 子进程中有效，并没有说它在所有的 Shell 进程中都有效；如果你通过终端创建了一个新的 Shell 窗口，那它就不是当前 Shell 的子进程，环境变量对这个新的 Shell 进程仍然是无效的。请看下图：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1-1Z41QKS3523.gif" alt="环境变量在不同的Shell窗口中无效"></p><p>第一个窗口中的环境变量 a 在第二个窗口中就无效。</p><p><strong>环境变量也是临时的</strong></p><p>通过 export 导出的环境变量只对当前 Shell 进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。</p><p>有读者可能会问，如果我想让一个变量在所有 Shell 进程中都有效，不管它们之间是否存在父子关系，该怎么办呢？</p><p>只有将变量写入 Shell 配置文件中才能达到这个目的！Shell 进程每次启动时都会执行配置文件中的代码做一些初始化工作，如果将变量放在配置文件中，那么每次启动进程都会定义这个变量。</p><h3 id="5-Shell特殊变量-、-、-、-、">5.Shell特殊变量 <code>$#、$*、$@、$?、$$</code></h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名。</td></tr><tr><td>$n（n≥1）</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。当被双引号<code>&quot; &quot;</code>包含时，$@ 与 $* 稍有不同。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</td></tr></tbody></table><ol><li><p>给脚本文件传递参数</p><p>编写下面的代码，并保存为 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Process ID: $$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;File Name: <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;First Parameter : <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Second Parameter : <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 1: <span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 2: $*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total: <span class="variable">$#</span>&quot;</span></span><br></pre></td></tr></table></figure><p>运行 <a href="http://test.sh">test.sh</a>，并附带参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ . ./test.sh Shell Linux</span><br><span class="line">Process ID: 5943</span><br><span class="line">File Name: bash</span><br><span class="line">First Parameter : Shell</span><br><span class="line">Second Parameter : Linux</span><br><span class="line">All parameters 1: Shell Linux</span><br><span class="line">All parameters 2: Shell Linux</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure></li><li><p>给函数传递参数</p><p>编写下面的代码，并保存为 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Language: <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;First Parameter : <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Second Parameter : <span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;All parameters 1: <span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;All parameters 2: $*&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Total: <span class="variable">$#</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func Java http://c.biancheng.net/java/</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果为：</span></span><br><span class="line">Language: Java</span><br><span class="line">URL: http://c.biancheng.net/java/</span><br><span class="line">First Parameter : Java</span><br><span class="line">Second Parameter : http://c.biancheng.net/java/</span><br><span class="line">All parameters 1: Java http://c.biancheng.net/java/</span><br><span class="line">All parameters 2: Java http://c.biancheng.net/java/</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>$*</code>和<code>$@</code>之间的区别</p><p><code>$*</code>和<code>$@</code>都表示传递给参数或者脚本全部参数。当<code>$*</code>和<code>$@</code>不加双引号时，两者没有任何区别，都表示将接收到的每一个参数当做每一份数据，每个参数之间用空格来分开。</p><p>当<code>$*</code>和<code>$@</code>加上双引号，则两者就存在一下区别：</p><p>​<code>&quot;$*&quot;</code> 表示将传入的多个参数从整体上当做一份数据，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数。</p><p>​<code>&quot;$@&quot;</code> 表示仍然将传入的多个参数当做多份数据，空格区分，彼此之间独立，以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n</code>&quot; 的形式输出所有参数。</p><p>编写下面的代码，并保存为 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;print each param from \&quot;\$*\&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;print each param from \&quot;\$@\&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行 <a href="http://test.sh">test.sh</a>，并附带参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ . ./test.sh a b c d</span><br><span class="line"><span class="built_in">print</span> each param from <span class="string">&quot;$*&quot;</span></span><br><span class="line">a b c d</span><br><span class="line"><span class="built_in">print</span> each param from <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>从运行结果可以发现，对于<code>&quot;$*&quot;</code>，只循环了 1 次，因为它只有 1 分数据；对于<code>&quot;$@&quot;</code>，循环了 5 次，因为它有 5 份数据。</p></li><li><p><code>$?</code></p><p><code>$?</code> 是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。</p><p>所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1，这和C语言的 main() 函数是类似的。</p><p>不过，也有一些命令返回其他值，表示不同类型的错误。</p><ol><li><p><code>$?</code> 获取上一个命令的退出状态</p><p>编写下面的代码，并保存为 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">exit</span> 0  <span class="comment">#参数正确，退出状态为0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">exit</span> 1  <span class="comment">#参数错误，退出状态1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>exit</code>表示退出当前 Shell 进程，我们必须在新进程中运行 <a href="http://test.sh">test.sh</a>，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法取得它的退出状态了。</p><p>例如，运行 <a href="http://test.sh">test.sh</a> 时传递参数 100：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 100  <span class="comment">#作为一个新进程运行</span></span><br><span class="line">[mozhiyan@localhost demo]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>再如，运行 <a href="http://test.sh">test.sh</a> 时传递参数 89：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 89  <span class="comment">#作为一个新进程运行</span></span><br><span class="line">[mozhiyan@localhost demo]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p><code>$?</code> 获取函数的返回值</p><p>编写下面的代码，并保存为 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#得到两个数相加的和</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> `<span class="built_in">expr</span> <span class="variable">$1</span> + <span class="variable">$2</span>`</span><br><span class="line">&#125;</span><br><span class="line">add 23 50  <span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment">#获取函数返回值</span></span><br></pre></td></tr></table></figure><p>运行结果：<br>73</p><p>有 C++、C#、Java 等编程经验的读者请注意：严格来说，Shell 函数中的 return 关键字用来表示函数的退出状态，而不是函数的返回值；Shell 不像其它编程语言，没有专门处理返回值的关键字。</p><p>以上处理方案在其它编程语言中没有任何问题，但是在 Shell 中是非常错误的，Shell 函数的返回值和其它编程语言大有不同，</p></li></ol></li></ul><hr><h2 id="3-命令">3.命令</h2><h3 id="1-命令替换">1.命令替换</h3><p>Shell 命令替换是指将命令的输出结果赋值给某个变量。比如，在某个目录中输入 ls 命令可查看当前目录中所有的文件，但如何将输出内容存入某个变量中呢？这就需要使用命令替换了，这也是 Shell 编程中使用非常频繁的功能。</p><p>Shell 中有两种方式可以完成命令替换，一种是反引号<code> </code>，一种是<code>$()</code>，使用方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`commands`</span><br><span class="line">variable=$(commands)</span><br></pre></td></tr></table></figure><p>其中，variable 是变量名，commands 是要执行的命令。commands 可以只有一个命令，也可以有多个命令，多个命令之间以分号<code>;</code>分隔。</p><p>例如，date 命令用来获得当前的系统时间，使用命令替换可以将它的结果赋值给一个变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">begin_time=`<span class="built_in">date</span>`    <span class="comment">#开始时间，使用``替换</span></span><br><span class="line"><span class="built_in">sleep</span> 20s            <span class="comment">#休眠20秒</span></span><br><span class="line">finish_time=$(<span class="built_in">date</span>)  <span class="comment">#结束时间，使用$()替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Begin time: <span class="variable">$begin_time</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Finish time: <span class="variable">$finish_time</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，20 秒后可以看到输出结果：</span></span><br><span class="line">Begin time: 2019年 04月 19日 星期五 09:59:58 CST</span><br><span class="line">Finish time: 2019年 04月 19日 星期五 10:00:18 CST</span><br></pre></td></tr></table></figure><p>使用 data 命令的<code>%s</code>格式控制符可以得到当前的 UNIX 时间戳，这样就可以直接计算脚本的运行时间了。UNIX 时间戳是指从 1970 年 1 月 1 日 00:00:00 到目前为止的秒数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">begin_time=`<span class="built_in">date</span> +%s`    <span class="comment">#开始时间，使用``替换</span></span><br><span class="line"><span class="built_in">sleep</span> 20s                <span class="comment">#休眠20秒</span></span><br><span class="line">finish_time=$(<span class="built_in">date</span> +%s)  <span class="comment">#结束时间，使用$()替换</span></span><br><span class="line">run_time=$((finish_time - begin_time))  <span class="comment">#时间差</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;begin time: <span class="variable">$begin_time</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;finish time: <span class="variable">$finish_time</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run time: <span class="variable">$&#123;run_time&#125;</span>s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，20 秒后可以看到输出结果：</span></span><br><span class="line">begin time: 1555639864</span><br><span class="line">finish time: 1555639884</span><br><span class="line">run time: 20s</span><br></pre></td></tr></table></figure><p>第 6 行代码中的<code>(( ))</code>是 Shell 数学计算命令。和 <a href="http://c.biancheng.net/cplus/">C++</a>、<a href="http://c.biancheng.net/csharp/">C#</a>、<a href="http://c.biancheng.net/java/">Java</a> 等编程语言不同，在 Shell 中进行数据计算不那么方便，必须使用专门的数学计算命令，<code>(( ))</code>就是其中之一。</p><p>注意，如果被替换的命令的输出内容包括多行（也即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个。请看下面的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">LSL=`<span class="built_in">ls</span> -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LSL</span>  <span class="comment">#不使用双引号包围</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------------------&quot;</span>  <span class="comment">#输出分隔符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$LSL</span>&quot;</span>  <span class="comment">#使用引号包围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果:</span></span><br><span class="line">total 8 drwxr-xr-x. 2 root root 21 7月 1 2016 abc -rw-rw-r--. 1 root root 147 10月 31 10:29 demo.sh -rw-rw-r--. 1 root root 35 10月 31 10:20 demo.sh~</span><br><span class="line">--------------------------</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x. 2 root     root      21 7月   1 2016 abc</span><br><span class="line">-rw-rw-r--. 1 root root 147 10月 31 10:29 demo.sh</span><br><span class="line">-rw-rw-r--. 1 root root  35 10月 31 10:20 demo.sh~</span><br></pre></td></tr></table></figure><p>所以，为了防止出现格式混乱的情况，我建议在输出变量时加上双引号。</p><p><strong>再谈反引号和 $()</strong></p><p>原则上讲，上面提到的两种变量替换的形式是等价的，可以随意使用；但是，反引号毕竟看起来像单引号，有时候会对查看代码造成困扰，而使用 $() 就相对清晰，能有效避免这种混乱。而且有些情况必须使用 $()：$() 支持嵌套，反引号不行。</p><p>下面的例子演示了使用计算 ls 命令列出的第一个文件的行数，这里使用了两层嵌套。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># Fir_File_Lines=$(wc -l $(ls | sed -n &#x27;1p&#x27;))</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo &quot;$Fir_File_Lines&quot;</span></span><br><span class="line">36 anaconda-ks.cfg</span><br></pre></td></tr></table></figure><p>要注意的是，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。所以这两种命令替换的方式各有特点，究竟选用哪种方式全看个人需求。</p><h3 id="2-内置命令">2.内置命令</h3><p>所谓 Shell 内建命令，就是由 Bash 自身提供的命令，而不是文件系统中的某个可执行文件。</p><p>例如，用于进入或者切换目录的 cd 命令，虽然我们一直在使用它，但如果不加以注意很难意识到它与普通命令的性质是不一样的：该命令并不是某个外部文件，只要在 Shell 中你就一定可以运行这个命令。</p><p>可以使用 type 来确定一个命令是否是内建命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a Shell <span class="built_in">builtin</span></span><br><span class="line">[root@localhost ~]<span class="comment"># type ifconfig</span></span><br><span class="line">ifconfig is /sbin/ifconfig</span><br></pre></td></tr></table></figure><p>由此可见，cd 是一个 Shell 内建命令，而 ifconfig 是一个外部文件，它的位置是<code>/sbin/ifconfig</code>。</p><p>还记得系统变量 <a href="http://c.biancheng.net/view/962.html">$PATH</a> 吗？$PATH 变量包含的目录中几乎聚集了系统中绝大多数的可执行命令，它们都是外部命令。</p><p>通常来说，内建命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘 I/O，还需要 fork 出一个单独的进程来执行，执行完成后再退出。而执行内建命令相当于调用当前 Shell 进程的一个函数。</p><ul><li><p>Bash Shell 中直接可用的内建命令:</p><table>  <caption>    Bash Shell 内建命令  </caption>  <tbody>    <tr>      <th>命令</th>      <th>说明</th>    </tr>    <tr>      <td>:</td>      <td>扩展参数列表，执行重定向操作</td>    </tr>    <tr>      <td>.</td>      <td>读取并执行指定文件中的命令（在当前 shell 环境中）</td>    </tr>    <tr>      <td>alias</td>      <td>为指定命令定义一个别名</td>    </tr>    <tr>      <td>bg</td>      <td>将作业以后台模式运行</td>    </tr>    <tr>      <td>bind</td>      <td>将键盘序列绑定到一个 readline 函数或宏</td>    </tr>    <tr>      <td>break</td>      <td>退出 for、while、select 或 until 循环</td>    </tr>    <tr>      <td>builtin</td>      <td>执行指定的 shell 内建命令</td>    </tr>    <tr>      <td>caller</td>      <td>返回活动子函数调用的上下文</td>    </tr>    <tr>      <td>cd</td>      <td>将当前目录切换为指定的目录</td>    </tr>    <tr>      <td>command</td>      <td>执行指定的命令，无需进行通常的 shell 查找</td>    </tr>    <tr>      <td>compgen</td>      <td>为指定单词生成可能的补全匹配</td>    </tr>    <tr>      <td>complete</td>      <td>显示指定的单词是如何补全的</td>    </tr>    <tr>      <td>compopt</td>      <td>修改指定单词的补全选项</td>    </tr>    <tr>      <td>continue</td>      <td>继续执行 for、while、select 或 until 循环的下一次迭代</td>    </tr>    <tr>      <td>declare</td>      <td>声明一个变量或变量类型。</td>    </tr>    <tr>      <td>dirs</td>      <td>显示当前存储目录的列表</td>    </tr>    <tr>      <td>disown</td>      <td>从进程作业表中刪除指定的作业</td>    </tr>    <tr>      <td>echo</td>      <td>将指定字符串输出到 STDOUT</td>    </tr>    <tr>      <td>enable</td>      <td>启用或禁用指定的内建shell命令</td>    </tr>    <tr>      <td>eval</td>      <td>将指定的参数拼接成一个命令，然后执行该命令</td>    </tr>    <tr>      <td>exec</td>      <td>用指定命令替换 shell 进程</td>    </tr>    <tr>      <td>exit</td>      <td>强制 shell 以指定的退出状态码退出</td>    </tr>    <tr>      <td>export</td>      <td>设置子 shell 进程可用的变量</td>    </tr>    <tr>      <td>fc</td>      <td>从历史记录中选择命令列表</td>    </tr>    <tr>      <td>fg</td>      <td>将作业以前台模式运行</td>    </tr>    <tr>      <td>getopts</td>      <td>分析指定的位置参数</td>    </tr>    <tr>      <td>hash</td>      <td>查找并记住指定命令的全路径名</td>    </tr>    <tr>      <td>help</td>      <td>显示帮助文件</td>    </tr>    <tr>      <td>history</td>      <td>显示命令历史记录</td>    </tr>    <tr>      <td>jobs</td>      <td>列出活动作业</td>    </tr>    <tr>      <td>kill</td>      <td>向指定的进程 ID(PID) 发送一个系统信号</td>    </tr>    <tr>      <td>let</td>      <td>计算一个数学表达式中的每个参数</td>    </tr>    <tr>      <td>local</td>      <td>在函数中创建一个作用域受限的变量</td>    </tr>    <tr>      <td>logout</td>      <td>退出登录 shell</td>    </tr>    <tr>      <td>mapfile</td>      <td>从 STDIN 读取数据行，并将其加入索引数组</td>    </tr>    <tr>      <td>popd</td>      <td>从目录栈中删除记录</td>    </tr>    <tr>      <td>printf</td>      <td>使用格式化字符串显示文本</td>    </tr>    <tr>      <td>pushd</td>      <td>向目录栈添加一个目录</td>    </tr>    <tr>      <td>pwd</td>      <td>显示当前工作目录的路径名</td>    </tr>    <tr>      <td>read</td>      <td>从 STDIN 读取一行数据并将其赋给一个变量</td>    </tr>    <tr>      <td>readarray</td>      <td>从 STDIN 读取数据行并将其放入索引数组</td>    </tr>    <tr>      <td>readonly</td>      <td>从 STDIN 读取一行数据并将其赋给一个不可修改的变量</td>    </tr>    <tr>      <td>return</td>      <td>强制函数以某个值退出，这个值可以被调用脚本提取</td>    </tr>    <tr>      <td>set</td>      <td>设置并显示环境变量的值和 shell 属性</td>    </tr>    <tr>      <td>shift</td>      <td>将位置参数依次向下降一个位置</td>    </tr>    <tr>      <td>shopt</td>      <td>打开/关闭控制 shell 可选行为的变量值</td>    </tr>    <tr>      <td>source</td>      <td>读取并执行指定文件中的命令（在当前 shell 环境中）</td>    </tr>    <tr>      <td>suspend</td>      <td>暂停 Shell 的执行，直到收到一个 SIGCONT 信号</td>    </tr>    <tr>      <td>test</td>      <td>基于指定条件返回退出状态码 0 或 1</td>    </tr>    <tr>      <td>times</td>      <td>显示累计的用户和系统时间</td>    </tr>    <tr>      <td>trap</td>      <td>如果收到了指定的系统信号，执行指定的命令</td>    </tr>    <tr>      <td>type</td>      <td>显示指定的单词如果作为命令将会如何被解释</td>    </tr>    <tr>      <td>typeset</td>      <td>声明一个变量或变量类型。</td>    </tr>    <tr>      <td>ulimit</td>      <td>为系统用户设置指定的资源的上限</td>    </tr>    <tr>      <td>umask</td>      <td>为新建的文件和目录设置默认权限</td>    </tr>    <tr>      <td>unalias</td>      <td>刪除指定的别名</td>    </tr>    <tr>      <td>unset</td>      <td>刪除指定的环境变量或 shell 属性</td>    </tr>    <tr>      <td>wait</td>      <td>等待指定的进程完成，并返回退出状态码</td>    </tr>  </tbody></table></li></ul><h3 id="3-alias-给命令创建别名">3.alias 给命令创建别名</h3><p>alisa 用来给命令创建一个别名。若直接输入该命令且不带任何参数，则列出当前 Shell 进程中使用了哪些别名。现在你应该能理解类似<code>ll</code>这样的命令为什么与<code>ls -l</code>的效果是一样的吧。</p><p>下面让我们来看一下有哪些命令被默认创建了别名：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">&#x27;ls -d .* --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">which</span>=<span class="string">&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span></span><br></pre></td></tr></table></figure><p>你看，为了让我们使用方便，Shell 会给某些命令默认创建别名。</p><ul><li><p>使用 alias 命令自定义别名</p><p>使用 alias 命令自定义别名的语法格式为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> new_name=<span class="string">&#x27;command&#x27;</span></span><br></pre></td></tr></table></figure><p>比如，一般的关机命令是<code>shutdown-h now</code>，写起来比较长，这时可以重新定义一个关机命令，以后就方便多了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> myShutdown=<span class="string">&#x27;shutdown -h now&#x27;</span></span><br></pre></td></tr></table></figure><p>再如，通过 date 命令可以获得当前的 UNIX 时间戳，具体写法为<code>date +%s</code>，如果你嫌弃它太长或者不容易记住，那可以给它定义一个别名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> timestamp=<span class="string">&#x27;date +%s&#x27;</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">alias</span> timestamp=<span class="string">&#x27;date +%s&#x27;</span></span><br><span class="line">begin=`timestamp`  </span><br><span class="line"><span class="built_in">sleep</span> 20s</span><br><span class="line">finish=$(timestamp)</span><br><span class="line">difference=$((finish - begin))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run time: <span class="variable">$&#123;difference&#125;</span>s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，20 秒后看到输出结果：</span></span><br><span class="line">run time: 20s</span><br></pre></td></tr></table></figure><p><strong>别名只是临时的</strong>，在代码中使用 alias 命令定义的别名只能在当前 Shell 进程中使用，在子进程和其它进程中都不能使用。当前 Shell 进程结束后，别名也随之消失。要想让别名对所有的 Shell 进程都有效，就得把别名写入 Shell 配置文件。Shell 进程每次启动时都会执行配置文件中的代码做一些初始化工作，将别名放在配置文件中，那么每次启动进程都会定义这个别名。</p></li><li><p>使用 unalias 命令删除别名</p><p>使用 unalias 内建命令可以删除当前 Shell 进程中的别名。unalias 有两种使用方法：</p><ul><li>第一种用法是在命令后跟上某个命令的别名，用于删除指定的别名。</li><li>第二种用法是在命令后接<code>-a</code>参数，删除当前 Shell 进程中所有的别名。</li></ul><p>同样，这两种方法都是在当前 Shell 进程中生效的。要想永久删除配置文件中定义的别名，只能进入该文件手动删除。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 ll 别名</span></span><br><span class="line">[root@localhost ~]$ <span class="built_in">unalias</span> ll</span><br><span class="line"><span class="comment"># 再次运行该命令时，报“找不到该命令”的错误，说明该别名被删除了</span></span><br><span class="line">[root@localhost ~]$ ll</span><br><span class="line">-bash: ll: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-echo-输出字符串">4.echo 输出字符串</h3><h3 id="5-read-读取从键盘输入的数据">5.read 读取从键盘输入的数据</h3><h3 id="6-exit-退出当前进程">6.exit 退出当前进程</h3><h3 id="7-declare-typeset-设置变量属性">7.declare(typeset) 设置变量属性</h3><p>declare 和 typeset 都是 Shell 内建命令，它们的用法相同，都用来设置变量的属性。不过 typeset 已经被弃用了，建议使用 declare 代替。</p><p>declare 命令的用法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare [+/-] [aAfFgilprtux] [变量名=变量值]</span><br></pre></td></tr></table></figure><p>其中，<code>-</code>表示设置属性，<code>+</code>表示取消属性，<code>aAfFgilprtux</code>都是具体的选项，它们的含义如下表所示：</p><table><tbody><tr><th>选项</th><th>含义</th></tr><tr><td>-f [name]</td><td>列出之前由用户在脚本中定义的函数名称和函数体。</td></tr><tr><td>-F [name]</td><td>仅列出自定义函数名称。</td></tr><tr><td>-g name</td><td>在 Shell 函数内部创建全局变量。</td></tr><tr><td>-p [name]</td><td>显示指定变量的属性和值。</td></tr><tr><td>-a name</td><td>声明变量为普通数组。</td></tr><tr><td>-A name</td><td>声明变量为关联数组（支持索引下标为字符串）。</td></tr><tr><td>-i name&nbsp;</td><td>将变量定义为整数型。</td></tr><tr><td>-r name[=value]&nbsp;</td><td>将变量定义为只读（不可修改和删除），等价于 readonly name。</td></tr><tr><td>-x name[=value]</td><td>将变量设置为环境变量，等价于&nbsp;export name[=value]。</td></tr></tbody></table><p>【实例1】将变量声明为整数并进行计算。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -i m n ret  <span class="comment">#将多个变量声明为整数</span></span><br><span class="line">m=10</span><br><span class="line">n=30</span><br><span class="line">ret=<span class="variable">$m</span>+<span class="variable">$n</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">40</span><br></pre></td></tr></table></figure><p>【实例2】将变量定义为只读变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ <span class="built_in">declare</span> -r n=10</span><br><span class="line">[c.biancheng.net]$ n=20</span><br><span class="line">bash: n: 只读变量</span><br><span class="line">[c.biancheng.net]$ <span class="built_in">echo</span> <span class="variable">$n</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>【实例3】显示变量的属性和值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ <span class="built_in">declare</span> -r n=10</span><br><span class="line">[c.biancheng.net]$ <span class="built_in">declare</span> -p n</span><br><span class="line"><span class="built_in">declare</span> -r n=<span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><h3 id="8-test-检测某个条件是否成立-a-id-test-anchor-a">8.test([ ]) 检测某个条件是否成立 <a id="test_anchor"> </a></h3><p>test 是 Shell 内置命令，用来检测某个条件是否成立。test 通常和 if 语句一起使用，并且大部分 if 语句都依赖 test。</p><p>test 命令有很多选项，可以进行数值、字符串和文件三个方面的检测。</p><p>Shell test 命令的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> expression</span><br></pre></td></tr></table></figure><p>当 test 判断 expression 成立时，退出状态为 0，否则为非 0 值。</p><p>test 命令也可以简写为<code>[]</code>，它的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ expression ]</span><br></pre></td></tr></table></figure><p>==注意<code>[]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。<code>[]</code>的写法更加简洁，比 test 使用频率高。==</p><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> age</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$age</span> -le 2; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;婴儿&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> <span class="variable">$age</span> -ge 3 &amp;&amp; <span class="built_in">test</span> <span class="variable">$age</span> -le 8; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;幼儿&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$age</span> -ge 9 ] &amp;&amp; [ <span class="variable">$age</span> -le 17 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;少年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$age</span> -ge 18 ] &amp;&amp; [ <span class="variable">$age</span> -le 25 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;成年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> <span class="variable">$age</span> -ge 26 &amp;&amp; <span class="built_in">test</span> <span class="variable">$age</span> -le 40; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;青年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> <span class="variable">$age</span> -ge 41 &amp;&amp; [ <span class="variable">$age</span> -le 60 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;中年&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;老年&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>其中，<code>-le</code>选项表示小于等于，<code>-ge</code>选项表示大于等于，<code>&amp;&amp;</code>是逻辑与运算符。</p><p>学习 test 命令，重点是学习它的各种选项，下面我们就逐一讲解。</p><h4 id="1）与文件检测相关">1）与文件检测相关</h4><table>  <caption>    表1：test 文件检测相关选项列表  </caption>  <tbody>    <tr>      <th colspan="2">文件类型判断</th>    </tr>    <tr>      <th>选 项</th>      <th>作 用</th>    </tr>    <tr>      <td>-b filename</td>      <td>判断文件是否存在，并且是否为块设备文件。</td>    </tr>    <tr>      <td>-c filename</td>      <td>判断文件是否存在，并且是否为字符设备文件。</td>    </tr>    <tr>      <td>-d filename</td>      <td>判断文件是否存在，并且是否为目录文件。</td>    </tr>    <tr>      <td>-e filename</td>      <td>判断文件是否存在。</td>    </tr>    <tr>      <td>-f filename</td>      <td>判断文件是否存在，井且是否为普通文件。</td>    </tr>    <tr>      <td>-L filename</td>      <td>判断文件是否存在，并且是否为符号链接文件。</td>    </tr>    <tr>      <td>-p&nbsp;filename</td>      <td>判断文件是否存在，并且是否为管道文件。</td>    </tr>    <tr>      <td>-s filename</td>      <td>判断文件是否存在，并且是否为非空。</td>    </tr>    <tr>      <td>-S filename</td>      <td>判断该文件是否存在，并且是否为套接字文件。</td>    </tr>    <tr>      <th colspan="2">文件权限判断</th>    </tr>    <tr>      <th>选 项</th>      <th>作&nbsp;用</th>    </tr>    <tr>      <td>-r filename</td>      <td>判断文件是否存在，并且是否拥有读权限。</td>    </tr>    <tr>      <td>-w filename</td>      <td>判断文件是否存在，并且是否拥有写权限。</td>    </tr>    <tr>      <td>-x filename</td>      <td>判断文件是否存在，并且是否拥有执行权限。</td>    </tr>    <tr>      <td>-u filename</td>      <td>判断文件是否存在，并且是否拥有 SUID 权限。</td>    </tr>    <tr>      <td>-g filename</td>      <td>判断文件是否存在，并且是否拥有 SGID 权限。</td>    </tr>    <tr>      <td>-k filename</td>      <td>判断该文件是否存在，并且是否拥有 SBIT 权限。</td>    </tr>    <tr>      <th colspan="2">文件比较</th>    </tr>    <tr>      <th>选 项</th>      <th>作&nbsp;用</th>    </tr>    <tr>      <td>filename1 -nt filename2</td>      <td>判断 filename1 的修改时间是否比 filename2 的新。</td>    </tr>    <tr>      <td>filename -ot filename2</td>      <td>判断 filename1 的修改时间是否比 filename2 的旧。</td>    </tr>    <tr>      <td>filename1 -ef filename2</td>      <td>        判断 filename1 是否和 filename2 的 inode        号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法      </td>    </tr>  </tbody></table><p>Shell test 文件检测举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> filename</span><br><span class="line"><span class="built_in">read</span> url</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -w <span class="variable">$filename</span> &amp;&amp; <span class="built_in">test</span> -n <span class="variable">$url</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$url</span> &gt; <span class="variable">$filename</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;写入成功&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;写入失败&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在 Shell 脚本文件所在的目录新建一个文本文件并命名为 urls.txt，然后运行 Shell 脚本，运行结果为：</span></span><br><span class="line">urls.txt↙</span><br><span class="line">http://c.biancheng.net/shell/↙</span><br><span class="line">写入成功</span><br></pre></td></tr></table></figure><h4 id="2）与数值比较相关">2）与数值比较相关</h4><table>  <caption>    表2：test 数值比较相关选项列表  </caption>  <tbody>    <tr>      <th>选 项</th>      <th>作&nbsp;用</th>    </tr>    <tr>      <td>num1 -eq num2</td>      <td>判断 num1 是否和 num2 相等。</td>    </tr>    <tr>      <td>num1 -ne num2</td>      <td>判断 num1 是否和 num2 不相等。</td>    </tr>    <tr>      <td>num1 -gt num2</td>      <td>判断 num1 是否大于 num2 。</td>    </tr>    <tr>      <td>num1 -lt num2</td>      <td>判断 num1 是否小于 num2。</td>    </tr>    <tr>      <td>num1 -ge num2</td>      <td>判断 num1 是否大于等于 num2。</td>    </tr>    <tr>      <td>num1 -le num2</td>      <td>判断 num1 是否小于等于 num2。</td>    </tr>  </tbody></table><p>注意，test 只能用来比较整数，小数相关的比较还得依赖 <a href="#bc_anchor">bc 命令</a>。</p><p>Shell test 数值比较举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a b</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$a</span> -eq <span class="variable">$b</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数相等&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数不相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果1：</span></span><br><span class="line">10 10</span><br><span class="line">两个数相等</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果2：</span></span><br><span class="line">10 20</span><br><span class="line">两个数不相等</span><br></pre></td></tr></table></figure><h4 id="3）与字符串判断相关">3）与字符串判断相关</h4><table>  <caption>    表3：test 字符串判断相关选项列表  </caption>  <tbody>    <tr>      <th>选 项</th>      <th>作&nbsp;用</th>    </tr>    <tr>      <td>-z str</td>      <td>判断字符串 str 是否为空。</td>    </tr>    <tr>      <td>-n str</td>      <td>判断宇符串 str 是否为非空。</td>    </tr>    <tr>      <td>        str1 = str2<br />        str1 == str2      </td>      <td>        <code>=</code>和<code>==</code>是等价的，都用来判断 str1 是否和 str2        相等。      </td>    </tr>    <tr>      <td>str1 != str2</td>      <td>判断 str1 是否和 str2 不相等。</td>    </tr>    <tr>      <td>str1 \&gt; str2</td>      <td>        判断 str1 是否大于        str2。<code>\&gt;</code>是<code>&gt;</code>的转义字符，这样写是为了防止<code>&gt;</code>被误认为成重定向运算符。      </td>    </tr>    <tr>      <td>str1 \&lt; str2</td>      <td>判断 str1 是否小于 str2。同样，<code>\&lt;</code>也是转义字符。</td>    </tr>  </tbody></table><p><code>==、&gt;、&lt;</code> 在大部分编程语言中都用来比较数字，而在 Shell 中，它们只能用来比较字符串，不能比较数字，这是非常奇葩的，大家要习惯。</p><p>其次，不管是比较数字还是字符串，Shell 都不支持 &gt;= 和 &lt;= 运算符，切记。</p><p>Shell test 字符串比较举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> str1</span><br><span class="line"><span class="built_in">read</span> str2</span><br><span class="line"><span class="comment">#检测字符串是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> ] || [ -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;字符串不能为空&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#比较字符串</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$str1</span> = <span class="variable">$str2</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串相等&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串不相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">http://c.biancheng.net/</span><br><span class="line">http://c.biancheng.net/shell/</span><br><span class="line">两个字符串不相等</span><br></pre></td></tr></table></figure><p>变量 <code>$str1</code> 和 <code>$str2</code> 都被双引号包围起来，这样做是为了防止 <code>$str1</code> 或者 <code>$str2</code> 是空字符串时出现错误。</p><h4 id="4）与逻辑运算相关">4）与逻辑运算相关</h4><table>  <caption>    表4：test 逻辑运算相关选项列表  </caption>  <tbody>    <tr>      <th>选 项</th>      <th>作&nbsp;用</th>    </tr>    <tr>      <td>expression1 -a expression</td>      <td>        逻辑与，表达式 expression1 和 expression2 都成立，最终的结果才是成立的。      </td>    </tr>    <tr>      <td>expression1 -o expression2</td>      <td>        逻辑或，表达式 expression1 和 expression2 有一个成立，最终的结果就成立。      </td>    </tr>    <tr>      <td>!expression</td>      <td>逻辑非，对 expression 进行取反。</td>    </tr>  </tbody></table><p>改写上面的代码，使用逻辑运算选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> str1</span><br><span class="line"><span class="built_in">read</span> str2</span><br><span class="line"><span class="comment">#检测字符串是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> -o -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]  <span class="comment">#使用 -o 选项取代之前的 ||</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;字符串不能为空&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#比较字符串</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$str1</span> = <span class="variable">$str2</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串相等&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串不相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>前面的代码我们使用两个<code>[]</code>命令，并使用<code>||</code>运算符将它们连接起来，这里我们改成<code>-o</code>选项，只使用一个<code>[]</code>命令就可以了。</p><ul><li><p>在 test 中使用变量建议用双引号包围起来</p><p>test 和 [] 都是命令，一个命令本质上对应一个程序或者一个函数。即使是一个程序，它也有入口函数，例如C语言程序的入口函数是 main()，运行C语言程序就从 main() 函数开始，所以也可以将一个程序等效为一个函数，这样我们就不用再区分函数和程序了，直接将一个命令和一个函数对应起来即可。</p><p>有了以上认知，就很容易看透命令的本质了：使用一个命令其实就是调用一个函数，命令后面附带的选项和参数最终都会作为实参传递给函数。</p><p>假设 test 命令对应的函数是 func()，使用<code>test -z $str1</code>命令时，会先将变量 $str1 替换成字符串：</p><ul><li>如果 $str1 是一个正常的字符串，比如 abc123，那么替换后的效果就是<code>test -z abc123</code>，调用 func() 函数的形式就是<code>func(&quot;-z abc123&quot;)</code>。test 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数。</li><li>如果 $str1 是一个空字符串，那么替换后的效果就是<code>test -z</code>，调用 func() 函数的形式就是<code>func(&quot;-z &quot;)</code>，这就比较奇怪了，因为<code>-z</code>选项没有和参数成对出现，func() 在分析时就会出错。</li></ul><p>如果我们给 $str1 变量加上双引号，当 $str1 是空字符串时，<code>test -z &quot;$str1&quot;</code>就会被替换为<code>test -z &quot;&quot;</code>，调用 func() 函数的形式就是<code>func(&quot;-z \&quot;\&quot;&quot;)</code>，很显然，<code>-z</code>选项后面跟的是一个空字符串（<code>\&quot;</code>表示转义字符），这样 func() 在分析时就不会出错了。</p><p>所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号<code>&quot;&quot;</code>包围起来，这样能避免变量为空值时导致的很多奇葩问题。</p></li><li><p>总结</p><p>test 命令比较奇葩，&gt;、&lt;、== 只能用来比较字符串，不能用来比较数字，比较数字需要使用 -eq、-gt 等选项；不管是比较字符串还是数字，test 都不支持 &gt;= 和 &lt;=。有经验的程序员需要慢慢习惯 test 命令的这些奇葩用法。</p><p>对于整型数字的比较，我建议大家使用 (())。(()) 支持各种运算符，写法也符合数学规则，用起来更加方便，何乐而不为呢？</p><p>几乎完全兼容 test ，并且比 test 更加强大，比 test 更加灵活的是<code>[[ ]]</code>；<code>[[ ]]</code>不是命令，是关键字。</p></li></ul><h3 id="9-检测某个条件是否成立">9.[[ ]] 检测某个条件是否成立</h3><p><code>[[ ]]</code>是 Shell 内置==关键字==，放到命令中来讲是因为 text 功能相近，也用来检测某个条件是否成立。</p><p>test 能做到的，<code>[[ ]]</code> 也能做到，而且 <code>[[ ]]</code> 做的更好；test 做不到的，<code>[[ ]]</code> 还能做到。可以认为 <code>[[ ]]</code> 是 test 的升级版，对细节进行了优化，并且扩展了一些功能。</p><p>[[ ]] 的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure><p>当 <code>[[ ]]</code> 判断 expression 成立时，退出状态为 0，否则为非 0 值。注意<code>[[ ]]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。</p><h4 id="1）不需要注意某些细枝末节">1）不需要注意某些细枝末节</h4><p><code>[[ ]]</code> 是 Shell 内置关键字，不是命令，在使用时没有给函数传递参数的过程，所以 test 命令的某些注意事项在 <code>[[ ]]</code> 中就不存在了，具体包括：</p><ul><li>不需要把变量名用双引号<code>&quot;&quot;</code>包围起来，即使变量是空值，也不会出错。</li><li>不需要、也不能对 &gt;、&lt; 进行转义，转义后会出错。</li></ul><p>请看下面的演示代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> str1</span><br><span class="line"><span class="built_in">read</span> str2</span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$str1</span> ]] || [[ -z <span class="variable">$str2</span> ]]  <span class="comment">#不需要对变量名加双引号</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;字符串不能为空&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$str1</span> &lt; <span class="variable">$str2</span> ]]  <span class="comment">#不需要也不能对 &lt; 进行转义</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;str1 &lt; str2&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;str1 &gt;= str2&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">http://c.biancheng.net/shell/</span><br><span class="line">http://data.biancheng.net/</span><br><span class="line">str1 &lt; str2</span><br></pre></td></tr></table></figure><h4 id="2）支持逻辑运算符">2）支持逻辑运算符</h4><p>对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> ] || [ -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]</span><br></pre></td></tr></table></figure><p>你也可以借助选项把多个表达式写在一个 test 命令中，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> -o -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]</span><br></pre></td></tr></table></figure><p>但是，这两种写法都有点“别扭”，完美的写法是在一个命令中使用逻辑运算符将多个表达式连接起来。我们的这个愿望在 <code>[[ ]]</code> 中实现了，<code>[[ ]]</code> 支持 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 三种逻辑运算符。</p><p>使用 <code>[[ ]]</code> 对上面的语句进行改进：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z <span class="variable">$str1</span> || -z <span class="variable">$str2</span> ]]</span><br></pre></td></tr></table></figure><p>这种写法就比较简洁漂亮了。</p><p>注意，<code>[[ ]]</code> 剔除了 test 命令的<code>-o</code>和<code>-a</code>选项，你只能使用 <code>||</code> 和 <code>&amp;&amp;</code>。这意味着，你不能写成下面的形式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z <span class="variable">$str1</span> -o -z <span class="variable">$str2</span> ]]</span><br></pre></td></tr></table></figure><p>当然，使用逻辑运算符将多个 [[ ]] 连接起来依然是可以的，因为这是 Shell 本身提供的功能，跟 [[ ]] 或者 test 没有关系，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z <span class="variable">$str1</span> ]] || [[ -z <span class="variable">$str2</span> ]]</span><br></pre></td></tr></table></figure><table>  <caption>    该表总结了各种写法的对错  </caption>  <tbody>    <tr>      <th colspan="2">test 或&nbsp;[]</th>      <th colspan="2">[[ ]]</th>    </tr>    <tr>      <td>[ -z "$str1" ] || [ -z "$str2" ]</td>      <td>        <span style="color: #008000"><b>√</b></span>      </td>      <td>[[ -z $str1 ]] || [[ -z $str2 ]]</td>      <td>        <b><span style="color: #008000">√</span></b>      </td>    </tr>    <tr>      <td>[ -z "$str1" -o -z "$str2" ]</td>      <td>        <b><span style="color: #008000">√</span></b>      </td>      <td>[[ -z $str1 -o -z $str2 ]]</td>      <td>        <b><span style="color: #ff0000">×</span></b>      </td>    </tr>    <tr>      <td>[&nbsp;-z $str1 || -z $str2 ]</td>      <td>        <span style="color: #ff0000"><b>×</b></span>      </td>      <td>[[ -z $str1 || -z $str2 ]]</td>      <td>        <b><span style="color: #008000">√</span></b>      </td>    </tr>  </tbody></table><h4 id="3）支持正则表达式">3）支持正则表达式</h4><p>在 Shell <code>[[ ]]</code> 中，可以使用<code>=~</code>来检测字符串是否符合某个正则表达式，它的用法为：</p><p>str 表示字符串，regex 表示正则表达式。</p><p>下面的代码检测一个字符串是否是手机号：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> tel</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$tel</span> =~ ^1[0-9]&#123;10&#125;$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;你输入的是手机号码&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;你输入的不是手机号码&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果1：</span></span><br><span class="line">13203451100</span><br><span class="line">你输入的是手机号码</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果2：</span></span><br><span class="line">132034511009</span><br><span class="line">你输入的不是手机号码</span><br></pre></td></tr></table></figure><blockquote><p>对<code>^1[0-9]&#123;10&#125;$</code>的说明：</p><ul><li><code>^</code>匹配字符串的开头（一个位置）；</li><li><code>[0-9]&#123;10&#125;</code>匹配连续的十个数字；</li><li><code>$</code>匹配字符串的末尾（一个位置）。</li></ul></blockquote><ul><li><p>总结</p><p>有了 <code>[[ ]]</code>，你还有什么理由使用 <code>test</code> 或者 <code>[ ]</code>，<code>[[ ]]</code> 完全可以替代之，而且更加方便，更加强大。</p><p>但是 <code>[[ ]]</code> 对数字的比较仍然不友好，所以我建议，以后大家使用 if 判断条件时，==用 <code>(())</code> 来处理整型数字，用 <code>[[ ]]</code> 来处理字符串或者文件==。</p></li></ul><hr><h2 id="4-位置参数">4.位置参数</h2><p>Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用<code>$n</code>的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><p>同样，在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用<code>$n</code>的形式接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><p>这种通过<code>$n</code>的形式来接收的参数，在 Shell 中称为位置参数。</p><p>变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“特殊变量”。</p><p>除了 <code>$n</code>，Shell 中还有 <code>$#、$*、$@、$?、$$</code> 几个特殊参数。</p><h3 id="1-给脚本文件传递位置参数">1.给脚本文件传递位置参数</h3><p>请编写下面的代码，并命名为 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Language: <span class="variable">$1</span>&quot;</span><span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span><br></pre></td></tr></table></figure><p>运行 <a href="http://test.sh">test.sh</a>，并附带参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ cd demo</span><br><span class="line">[root@localhost demo]$ . ./test.sh Shell http://nb.com/shell/</span><br><span class="line">Language: Shell</span><br><span class="line">URL: http://nb.com/shell/</span><br></pre></td></tr></table></figure><p>其中<code>Shell</code>是第一个位置参数，<code>http://nb.com/shell/</code>是第二个位置参数，两者之间以空格分隔。</p><h3 id="2-给函数传递位置参数">2.给函数传递位置参数</h3><p>请编写下面的代码，并命名为 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#定义函数</span><br><span class="line">function func()&#123;</span><br><span class="line">echo &quot;Language: $1&quot;</span><br><span class="line">    echo &quot;URL: $2&quot;&#125;</span><br><span class="line">    </span><br><span class="line">#调用函数</span><br><span class="line">func C++ http://nb.com/cplus/</span><br></pre></td></tr></table></figure><p>运行 <a href="http://test.sh">test.sh</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ cd demo</span><br><span class="line">[root@localhost demo]$ . ./test.sh</span><br><span class="line">Language: C++</span><br><span class="line">URL: http://nb.com//cplus/</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong></p><p>如果参数个数太多，达到或者超过了 10 个，那么就得用<code>$&#123;n&#125;</code>的形式来接收了，例如 ${10}、${23}。<code>&#123; &#125;</code>的作用是为了帮助解释器识别参数的边界，这跟使用变量时加<code>&#123; &#125;</code>是一样的效果。</p></blockquote><hr><h2 id="5-字符串">5.字符串</h2><h3 id="1-定义">1.定义</h3><p>字符串（String）就是一系列字符的组合。字符串是 Shell 编程中最常用的数据类型之一（除了数字和字符串，也没有其他类型了）。</p><p>字符串可以由单引号<code>' '</code>包围，也可以由双引号<code>&quot; &quot;</code>包围，也可以不用引号。它们之间是有区别的。</p><p>下面我们说一下三种形式的区别：</p><ol><li><p>由单引号<code>' '</code>包围的字符串：</p><ul><li>任何字符都会原样输出，在其中使用变量是无效的。</li><li>字符串中不能出现单引号，即使对单引号进行转义也不行。</li></ul></li><li><p>由双引号<code>&quot; &quot;</code>包围的字符串：</p><ul><li>如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。</li><li>字符串中可以出现双引号，只要它被转义了就行。</li></ul></li><li><p>不被引号包围的字符串</p><ul><li>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号<code>&quot; &quot;</code>包围的字符串一样。</li><li>字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。</li></ul></li></ol><p>我们通过代码来演示一下三种形式的区别：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">n=74</span><br><span class="line">str1=c.biancheng.net<span class="variable">$n</span> </span><br><span class="line">str2=<span class="string">&quot;shell \&quot;script\&quot; <span class="variable">$n</span>&quot;</span></span><br><span class="line">str3=<span class="string">&#x27;C语言中文网 $n&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">c.biancheng.net74</span><br><span class="line">shell <span class="string">&quot;script&quot;</span> 74</span><br><span class="line">C语言中文网 <span class="variable">$n</span></span><br></pre></td></tr></table></figure><p>str1 中包含了<code>$n</code>，它被解析为变量 n 的引用。<code>$n</code>后边有空格，紧随空格的是 str2；Shell 将 str2 解释为一个新的变量名，而不是作为字符串 str1 的一部分。</p><p>str2 中包含了引号，但是被转义了（由反斜杠<code>\</code>开头的表示转义字符）。str2 中也包含了<code>$n</code>，它也被解析为变量 n 的引用。</p><p>str3 中也包含了<code>$n</code>，但是仅仅是作为普通字符，并没有解析为变量 n 的引用。</p><h3 id="2-获取字符串长度">2.获取字符串长度</h3><p>在 Shell 中获取字符串长度很简单，具体方法如下：</p><p>$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;Shell&quot;&gt;Shell&lt;/h1&gt;
&lt;h2 id=&quot;1-Shell-脚本&quot;&gt;1.Shell 脚本&lt;/h2&gt;
&lt;h3 id=&quot;1-第一个shell脚本&quot;&gt;1.第一个shel</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker 学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/920e92d1.html"/>
    <id>https://blog.halfsummer.xyz/posts/920e92d1.html</id>
    <published>2023-03-13T23:04:59.000Z</published>
    <updated>2023-03-13T17:11:01.894Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><!--本文色卡号 #5FA55A #01B4BC #F6D51F #FA8925 #FA5457--><h1 id="1）简介">1）简介</h1><div class="tip home"><p>Docker：<a href="https://www.docker.com">https://www.docker.com</a></p></div><div class="tip home"><p>Docker Hub：<a href="https://hub.docker.com">https://hub.docker.com</a></p></div><h2 id="1-1-Docker-为什么横空出世">1.1 Docker 为什么横空出世</h2><p>传统开发中，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<b style="color:#01B4BC;">开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况</b>。<b style="color:#FA5457;">Docker的出现使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作</b>。</p><h2 id="1-2-概述">1.2 概述</h2><p><b style="color:#FA5457;">Docker是基于Go语言实现的云开源项目</b>。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“<b style="color:#FA5457;">一次镜像，处处运行</b>”。</p><p><b style="color:#01B4BC;">Linux容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的</b>。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而 Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<b style="color:#FA5457;">只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作</b>。</p><h2 id="1-3-容器与虚拟机的比较">1.3 容器与虚拟机的比较</h2><p>📌 <strong>纯物理部署、虚拟机的部署的缺点</strong></p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c13d7da4.png" alt="image-20230106105948208"></p><p>📌 <strong>虚拟化发展史</strong></p><ul><li><p>个人虚拟化 vmware workstation，主要用于个人电脑。</p></li><li><p>企业版虚拟化 vmware esxi 虚拟化工具，用于高性能服务器</p></li><li><p>Linux下虚拟机工作，kvm 工具</p><img src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230106111151052.png" alt="image-20230106111151052" style="zoom: 50%;" /></li><li><p>容器-LXC &amp; docker</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c1311949.png" alt="image-20230106111707293"></p></li></ul><p>📌 <strong>开发中的问题</strong></p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，开发、测试、生产环境有差异，会遇到各种问题</li></ul><p>📌 <strong>Docker 解决依赖兼容问题</strong></p><ul><li>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</li><li>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</li></ul><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c14030d7.png" alt="在这里插入图片描述" style="zoom: 33%;" /><p>📌 <strong>Docker 解决操作系统环境差异</strong></p><p>应用程序在计算机中交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>📌 <strong>Docker如何解决不同系统环境的问题？</strong></p><ul><li><b style="color:#01B4BC;">Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</b>，不管实际的运行系统是Centos还是Ubuntu都可以正常运行，因为应用程序调用的是捆绑在一起的系统的函数，系统函数再调用linux内核的函数。</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，<b style="color:#01B4BC;">只借助于操作系统的Linux内核来运行，不在乎实际运行的系统版本是什么</b>。</li></ul><blockquote><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以<b style="color:#01B4BC;">将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</b></li><li>运行时<b style="color:#01B4BC;">利用沙箱机制形成隔离容器</b>，各个应用<b style="color:#01B4BC;">互不干扰</b></li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul></blockquote><blockquote><p>Docker和虚拟机的差异：</p><ul><li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li><li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li></ul></blockquote><h2 id="1-4-Docker-架构">1.4 Docker 架构</h2><p>Docker是一个CS架构的程序，由两部分组成：</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c13edfdc.png" alt="在这里插入图片描述"></p><ul><li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</li><li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><h2 id="1-5-Docker-引擎">1.5 Docker 引擎</h2><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c13c4845.png" alt="image-20230106114851591"></p><h2 id="1-6-Docker-平台组成">1.6 Docker 平台组成</h2><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c10526cd.png" alt="image-20230106115104206"></p><h2 id="1-7-镜像-容器">1.7 镜像&amp;容器</h2><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><blockquote><p><strong>镜像</strong>就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p></blockquote><h2 id="1-8-Docker-生命周期">1.8 Docker 生命周期</h2><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c10de085.png" alt="image-20230106201947897"></p><h2 id="1-9-Docker-镜像原理理解">1.9 Docker 镜像原理理解</h2><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3c1088a88.png" alt="image-20230106214026388"></p><h1 id="2）Docker-安装">2）Docker 安装</h1><h2 id="2-1-Docker-版本说明">2.1 Docker 版本说明</h2><ul><li><a href="https://hub.docker.com/">DockerHub</a>：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</li><li>国内也有类似于DockerHub 的公开服务，比如 网易云镜像服务、阿里云镜像库等。</li></ul><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><blockquote><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询内核版本</span></span><br><span class="line">cat /etc/redhat-release</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询操作系统的发型版号</span></span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure><h2 id="2-2-卸载">2.2 卸载</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：(<code>'\'</code>表示本行命令未结束，下一行继续，<code>'\'</code>前记得有一个空格)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="2-3-安装">2.3 安装</h2><p>📌 <strong>基础环境配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/Centos-base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>开启linux内核的流量转发：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/sysctl.d/docker.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>重新加载修改内核参数的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.d/docker.conf</span><br></pre></td></tr></table></figure><blockquote><p>🔴 如果报错：</p><blockquote><p>No such file or directory<br>sysctl: cannot stat /proc/sys/net/bridge/bridge-nf-call-ip6tables: No such file or directory<br>sysctl: cannot stat /proc/sys/net/bridge/beidge-nf-call-iptables: No such file or directory<br>net.ipv4.conf.default.rp_filter = 0<br>net.ipv4.conf.all.rp_filter = 0<br>net.ipv4.ip_forward = 1</p></blockquote><p>就执行如下命令：（向内核中加载模块）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure><p>然后再重新执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p /etc/sysctl.d/docker.conf</span><br></pre></td></tr></table></figure></blockquote><p>📌 <strong>yum安装</strong></p><ul><li><p><strong>方法1</strong>：</p><p>首先需要将虚拟机联网，安装yum工具、存储驱动、逻辑卷管理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>更新本地镜像源：(<code>yum-config-manager</code> 命令的本质是对 <code>/etc/yum.repos.d/</code>(库数据的储存位置)文件夹下文件的增删查改。)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure></li><li><p><strong>方法2</strong>：</p><p>查看源中可用版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>如果没有匹配项，则下载阿里源repo文件 第一个是阿里云自带仓库 第二个是阿里云提供的docker专属repo仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新yum缓存:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure><p>安装与卸载:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce-xxx </span><br><span class="line"></span><br><span class="line">yum remove -y docker-xxx</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-4-配置镜像加速器">2.4 配置镜像加速器</h2><p>Docker的镜像默认是从Docker hub下载，网速很慢，国内有很多云服务商都提供了加速器服务（阿里云加速器，Daocloud加速器，灵雀云加速器等）</p><p>注意：此处docker版本不同daemon文件的后缀不同，新版后缀为.conf，旧版的可能为.json。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-4-9-centos ~]# mkdir -p /etc/docker</span><br><span class="line">[root@VM-4-9-centos ~]#</span><br><span class="line">[root@VM-4-9-centos ~]# touch /etc/docker/daemon.conf</span><br><span class="line">[root@VM-4-9-centos ~]#</span><br><span class="line">[root@VM-4-9-centos ~]# vim /etc/docker/daemon.conf</span><br><span class="line">[root@VM-4-9-centos ~]# cat /etc/docker/daemon.conf</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">　　&quot;registry-mirrors&quot;:[</span><br><span class="line">　　　　&quot;https://8xpk5wnt.mirror.aliyun.com&quot;</span><br><span class="line">　　]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者：</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://hub.daocloud.io&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-启动">2.5 启动</h2><p>关闭防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机启动防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加开机启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动服务</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="2-6-测试">2.6 测试</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker run hello-world</span></span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete </span><br><span class="line">Digest: sha256:6e8b6f026e0b9c419ea0fd02d3905dd0952ad1feea67543f525c73a0a790fefb</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...省略部分数据...</span><br></pre></td></tr></table></figure><hr><h1 id="3）镜像管理命令">3）镜像管理命令</h1><p>使用镜像的流程：</p><ol><li>获取该软件的docker镜像。</li><li>运行该镜像，就启动了一个容器。</li><li>停止容器，删除该镜像。</li></ol><h2 id="8-1-搜索镜像是否存在于镜像库">8.1  搜索镜像是否存在于镜像库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search 镜像名:tag# tag就是具体的标签版本</span><br></pre></td></tr></table></figure><h2 id="8-2-查看镜像">8.2  查看镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前所有镜像</span></span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">[root@localhost ~]# docker image ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个镜像详细信息</span></span><br><span class="line">[root@localhost ~]# docker images 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只显示镜像<span class="built_in">id</span> --quiet</span></span><br><span class="line">[root@localhost ~]# docker images -q</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化显示镜像只提取出需要的信息</span></span><br><span class="line">[root@localhost ~]# docker images --format &quot;&#123;&#123;.ID&#125;&#125;--&#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化成表格 显示镜像只提取出需要的信息</span></span><br><span class="line">[root@localhost ~]# docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="8-2-镜像拉取">8.2 镜像拉取</h2><p>获取镜像，镜像托管仓库，好比yum源一样。（docker默认仓库是dockerhub）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull 镜像名:tag# tag | latest</span><br></pre></td></tr></table></figure><h2 id="8-3-查看-Docker-的服务信息">8.3 查看 Docker 的服务信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker info</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker info | grep Root</span><br><span class="line"> Docker Root Dir: /var/lib/docker</span><br></pre></td></tr></table></figure><p>镜像存放在：<code>ll /var/lib/docker/image/overlay2/imagedb/content/sha256/</code></p><p>镜像文件其实是一个json数据类型的文件，记录 镜像和容器的配置关系</p><h2 id="8-4-删除镜像">8.4 删除镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi 镜像名(或 ID 或 ID前三位)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">批量删除</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker images -aq是列出所有的镜像 用反引号‘`’框柱表示取出命令的结果</span></span><br><span class="line">[root@localhost ~]# docker rmi `docker images -aq`</span><br></pre></td></tr></table></figure><h2 id="8-5-导出镜像">8.5 导出镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker image save 镜像名[:tag] &gt; /重定向的位置/镜像名.tgz</span><br></pre></td></tr></table></figure><h2 id="8-6-导入镜像">8.6 导入镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker image load -i /位置/镜像名.tgz</span><br></pre></td></tr></table></figure><h2 id="8-7-查看-Docker-镜像信息">8.7 查看 Docker 镜像信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect 镜像id</span><br></pre></td></tr></table></figure><hr><h1 id="4）容器管理命令">4）容器管理命令</h1><h2 id="9-1-运行、创建容器">9.1 运行、创建容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果镜像不存在本地，则回去下载该镜像</span></span><br><span class="line">docker run 镜像名</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">丰富docker运行的参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">rm</span> 容器挂掉后被删除</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name niubb 给容器命名niubb</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ping 是后面容器执行的指令</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker run -d --rm --name niubb centos:7.6.1810 ping baidu.com</span><br><span class="line">5579d43af5173d37d575cbb497573ec5b7db6e0daeed70730115e0eb6db34ad7</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND            CREATED          STATUS          PORTS     NAMES</span><br><span class="line">5579d43af517   centos:7.6.1810   &quot;ping baidu.com&quot;   12 seconds ago   Up 11 seconds             niubb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用--<span class="built_in">rm</span>后，容器挂掉后删除了状态记录</span></span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">52e5ccb0d743   centos         &quot;/bin/bash&quot;              11 minutes ago   Exited (0) 11 minutes ago             heuristic_rosalind</span><br><span class="line">6684befd9bfa   f1cb7c7d58b7   &quot;bash&quot;                   2 hours ago      Exited (130) 2 hours ago              agitated_bartik</span><br><span class="line">3bbc199beb84   f1cb7c7d58b7   &quot;bash&quot;                   3 hours ago      Exited (127) 2 hours ago              tender_shtern</span><br><span class="line">2f2c4da21e01   5d0da3dc9764   &quot;bash&quot;                   3 hours ago      Exited (0) 3 hours ago                agitated_buck</span><br><span class="line">e2c3e6042ba3   nginx          &quot;/docker-entrypoint.…&quot;   4 hours ago      Exited (0) 10 minutes ago             busy_lewin</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 宿主机路径:容器内路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:rw 为可读写可省略</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:ro 在容器内只读，如果写入会报错</span></span><br><span class="line">[root@localhost ~]# docker run -d -v /opt:/tep/centos7.6 centos:7.6.1810</span><br><span class="line">[root@localhost ~]# docker run -d -v /opt:/tep/centos7.6:rw centos:7.6.1810</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况下，仓库被创建在/var/lib/registry目录下</span></span><br></pre></td></tr></table></figure><p><span style="color:red;background:yellow;">※注意：</span></p><ol><li><p><span style="color:red;">容器内的程序必须处于前台运行状态，否则容器就会直接退出。</span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run centos</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED       STATUS       PORTS                NAMES</span><br></pre></td></tr></table></figure></li><li><p>如果容器内，什么事情也不做，容器也会挂掉。容器内必须有一个进程在前台运行。</p></li></ol><h2 id="9-2-启动、停止、重启容器">9.2 启动、停止、重启容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id/名字</span><br><span class="line">docker stop 容器id/名字</span><br><span class="line">docker restart 容器id/名字</span><br></pre></td></tr></table></figure><h2 id="9-3-查看容器、容器日志、容器的详细信息">9.3 查看容器、容器日志、容器的详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有容器状态</span></span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器日志</span></span><br><span class="line">[root@localhost ~]# docker logs 容器id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实时刷新容器日志</span></span><br><span class="line">[root@localhost ~]# docker logs -f 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器的详细信息</span></span><br><span class="line">[root@localhost ~]# docker container inspect 容器id</span><br></pre></td></tr></table></figure><h2 id="9-4-删除容器">9.4 删除容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 删除指定容器</span></span><br><span class="line">[root@localhost ~]# docker rm -f &lt;containerid&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 删除未启动成功的容器</span></span><br><span class="line">[root@localhost ~]# docker rm $(docker ps -a|grep Created|awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">[root@localhost ~]# docker rm $(docker ps -qf status=created)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 删除退出状态的容器</span></span><br><span class="line">[root@localhost ~]# docker rm $(docker ps -a|grep Exited|awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">[root@localhost ~]# docker rm $(docker ps -qf status=exited)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@docker_test ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS                           PORTS                               NAMES</span><br><span class="line">d13ef6c6cb8e   nginx     &quot;/docker-entrypoint.…&quot;   6 minutes ago       Up 6 minutes                     0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx1</span><br><span class="line">e30bfa566607   docker    &quot;docker-entrypoint.s…&quot;   51 minutes ago      Exited (125) 13 minutes ago                                          peaceful_black</span><br><span class="line">886aa44c834e   docker    &quot;docker-entrypoint.s…&quot;   57 minutes ago      Exited (0) 55 minutes ago                                            festive_wing</span><br><span class="line">4d8d27bc3d78   nginx     &quot;/docker-entrypoint.…&quot;   About an hour ago   Exited (0) 58 minutes ago                                            reverent_engelbart</span><br><span class="line">74026fa35fbe   nginx     &quot;/docker-entrypoint.…&quot;   About an hour ago   Exited (0) About an hour ago                                         jovial_galois</span><br><span class="line">64d0278cd793   nginx     &quot;/docker-entrypoint.…&quot;   About an hour ago   Exited (127) About an hour ago                                       practical_archimedes</span><br><span class="line">[root@docker_test ~]# docker rm $(docker ps -a|grep Exited|awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">e30bfa566607</span><br><span class="line">886aa44c834e</span><br><span class="line">4d8d27bc3d78</span><br><span class="line">74026fa35fbe</span><br><span class="line">64d0278cd793</span><br><span class="line">[root@docker_test ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                               NAMES</span><br><span class="line">d13ef6c6cb8e   nginx     &quot;/docker-entrypoint.…&quot;   28 minutes ago   Up 28 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx1</span><br></pre></td></tr></table></figure><h2 id="9-5-进入容器内">9.5 进入容器内</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-it 交互操作</span></span><br><span class="line">[root@localhost ~]# docker exec -it 容器id bash</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line">aa7cb64f6428   nginx     &quot;/docker-entrypoint.…&quot;   6 seconds ago   Up 5 seconds   80/tcp    sleepy_faraday</span><br><span class="line">[root@localhost ~]# docker exec -it aa7cb64f6428 bash</span><br><span class="line">root@aa7cb64f6428:/# </span><br></pre></td></tr></table></figure><h2 id="9-6-容器的端口映射">9.6 容器的端口映射</h2><p>宿主机的端口范围：0~65535</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 端口映射：宿主机端口:容器端口</span></span><br><span class="line">[root@localhost ~]# docker run -d -p 端口号:端口号 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-P 随机端口映射</span></span><br><span class="line">[root@localhost ~]# docker run -d -P 镜像名</span><br></pre></td></tr></table></figure><h2 id="9-7-查看容器的端口映射">9.7 查看容器的端口映射</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker port 容器id</span><br></pre></td></tr></table></figure><h2 id="9-8-更新容器参数">9.8 更新容器参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker update [选项] 容器id</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>--blkio-weight</code></td><td style="text-align:left">阻塞IO (相对权重)，介于10到1000之间，0表示禁用（默认禁止）</td></tr><tr><td style="text-align:left"><code>--cpu-period</code></td><td style="text-align:left">限制CPU CFS（完全公平的调度程序）期限</td></tr><tr><td style="text-align:left"><code>--cpu-quota</code></td><td style="text-align:left">限制CPU CFS（完全公平的调度程序）配额</td></tr><tr><td style="text-align:left"><code>--cpu-rt-period</code></td><td style="text-align:left"><code>API 1.25+</code>，将CPU实时时间限制为微秒</td></tr><tr><td style="text-align:left"><code>--cpu-rt-runtime</code></td><td style="text-align:left"><code>API 1.25+</code>，将CPU实时运行时间限制为微秒</td></tr><tr><td style="text-align:left"><code>--cpu-shares</code>, <code>-c</code></td><td style="text-align:left">CPU份额（相对权重）</td></tr><tr><td style="text-align:left"><code>--cpus</code></td><td style="text-align:left"><code>API 1.29+</code>，CPU数量</td></tr><tr><td style="text-align:left"><code>--cpuset-cpus</code></td><td style="text-align:left">允许执行的CPU（0-3，0,1）</td></tr><tr><td style="text-align:left"><code>--cpuset-mem</code></td><td style="text-align:left">允许执行的MEM（0-3，0,1）</td></tr><tr><td style="text-align:left"><code>--kernel-memory</code></td><td style="text-align:left">内核内存限制</td></tr><tr><td style="text-align:left"><code>--memory-swap</code></td><td style="text-align:left">交换限制等于内存加交换，“-1”以启用无限交换</td></tr><tr><td style="text-align:left"><code>--memory-reservatio</code></td><td style="text-align:left">内存软限制</td></tr><tr><td style="text-align:left"><code>--memory</code>, <code>-m</code></td><td style="text-align:left">内存限制</td></tr><tr><td style="text-align:left"><code>--pids-limit</code></td><td style="text-align:left"><code>API 1.40+</code>，调节容器pids限制（-1表示无限制）</td></tr><tr><td style="text-align:left"><code>--restart</code></td><td style="text-align:left">容器退出时重新启动策略以应用</td></tr></tbody></table><h2 id="9-9-容器的文件拷贝">9.9 容器的文件拷贝</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从容器内拷贝文件到linux主机上</span></span><br><span class="line">[root@localhost ~]# docker cp 容器id:容器内路径 目标主机路径</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从宿主机拷贝文件到容器内</span> </span><br><span class="line">[root@localhost ~]# docker cp 文件路径 容器id:容器内路径</span><br></pre></td></tr></table></figure><h2 id="9-8-容器的提交">9.8 容器的提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker commit 容器id 重命名镜像</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS                            PORTS     NAMES</span><br><span class="line">a04a590adf6c   centos:7.6.1810   &quot;bash&quot;                   59 seconds ago   Exited (0) 7 seconds ago                    awesome_lamarr</span><br><span class="line">[root@localhost ~]# docker commit a04a590adf6c niubb/centos-vim-7.6.1810</span><br><span class="line">sha256:f6f3648f6cccdd589e6849d0075d96bd53c3727062b168fac6775b904850fef9</span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY                  TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">niubb/centos-vim-7.6.1810   latest     f6f3648f6ccc   9 seconds ago   449MB</span><br><span class="line">centos                      7.6.1810   f1cb7c7d58b7   3 years ago     202MB</span><br></pre></td></tr></table></figure><h2 id="9-9-容器的导出和导入">9.9 容器的导出和导入</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> -o 文件名.tar CONTAINER<span class="comment"># 导出容器的内容留作为一个tar归档文件</span></span><br><span class="line">docker import [OPTIONS] 文件名.tar 命名CONTAINER<span class="comment"># 从tar包中得内容创建一个新的文件系统再导入为镜像</span></span><br></pre></td></tr></table></figure><h2 id="9-9-查看容器详细信息">9.9 查看容器详细信息</h2><p><strong>方法一：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker inspect 容器名称/容器id</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker inspect nginx1</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;d13ef6c6cb8e10be379cd796956f3e334aa44ceef15da80db3f4fddf14b09479&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2023-01-21T12:11:57.22722614Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/docker-entrypoint.sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;nginx&quot;,</span><br><span class="line">            &quot;-g&quot;,</span><br><span class="line">            &quot;daemon off;&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 84812,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2023-01-21T12:11:57.504385223Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:a99a39d070bfd1cb60fe65c45dea3a33764dc00a9546bf8dc46cb5a11b1b50e9&quot;,</span><br><span class="line">...省略数据...</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询容器创建语句</span></span><br><span class="line">[root@localhost ~]# runlike -p 容器名</span><br></pre></td></tr></table></figure><ul><li><p>安装runlike</p><p>需要安装pip工具包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install python-pip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不成功，尝试下列命令</span></span><br><span class="line">[root@localhost ~]# yum -y install python36</span><br><span class="line">[root@localhost ~]# pip install --upgrade pip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以尝试更换国内源</span></span><br><span class="line">[root@localhost ~]# touch /etc/pip.conf</span><br><span class="line">[root@docker_test ~]# cat &gt;&gt; /etc/pip.conf &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">[global]</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# pip3 install runlike</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="5）Docker-镜像">5）Docker 镜像</h1><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><p>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。</p><p>部署一个用于你需要的容器环境。</p><ul><li>定制docker镜像有两种方式：<ol><li>手动修改容器内容，导出新的镜像</li><li>基于Dockerfile 自行编写指令，基于指令流程创建镜像。</li></ol></li></ul><h2 id="10-1-dockerfile-指令">10.1 dockerfile 指令</h2><h3 id="10-1-1-FROM-指定基础镜像">10.1.1 FROM 指定基础镜像</h3><h3 id="10-1-2-MAINTAINER-指定维护者信息">10.1.2 MAINTAINER 指定维护者信息</h3><p>（可以没有维护者）</p><h3 id="10-1-3-RUN-执行命令">10.1.3 RUN 执行命令</h3><h3 id="10-1-4-ADD-拷贝文件，会自动解压">10.1.4 ADD 拷贝文件，会自动解压</h3><ol><li>添加宿主机的文件到容器内，如果是gzip、bzip2、xz、tar ADD能自动解压到当前路径下。</li><li>原文件如果是URL，此时docker引擎会下载该链接，放入目标路径，且自动设置为600权限。如果URL源文件是压缩包，则不自动解压。</li></ol><h3 id="10-1-5-COPY-复制文件">10.1.5 COPY 复制文件</h3><p>添加宿主机的文件到容器内，COPY仅复制</p><h3 id="10-1-6-WORKDIR-设置当前工作目录">10.1.6 WORKDIR 设置当前工作目录</h3><p>（相当于cd）</p><h3 id="10-1-7-VOLUME-设置卷，挂载到主机目录">10.1.7 VOLUME 设置卷，挂载到主机目录</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data1&quot;</span>,<span class="string">&quot;/data2&quot;</span>]</span></span><br><span class="line"><span class="comment"># 支持列表的形式挂载多个文件夹</span></span><br></pre></td></tr></table></figure><h3 id="10-1-8-EXPOSE-指定对外的端口">10.1.8 EXPOSE 指定对外的端口</h3><h3 id="10-1-9-CMD-指定容器启动后要干的事情">10.1.9 CMD 指定容器启动后要干的事情</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/os-release</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;cat&quot;</span>，<span class="string">&quot;/etc/os-release&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><p>Docker挂载主机目录访问如果出现cannot open directory.：Permission denied</p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可（扩大容器权限，使容器内的root拥有真正的root权限）</p></li></ul><h3 id="10-1-10-ENTRYPOINT-容器启动后执行的命令">10.1.10 ENTRYPOINT 容器启动后执行的命令</h3><p>当指定了ENTRYPOINT之后，CMD的指令语义就有了变化。CMD的内容当做参数传递给ENTRYPOINT指令。</p><h3 id="10-1-11-ENV-环境变量">10.1.11 ENV 环境变量</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYSQL_VERSION=<span class="number">5.6</span></span><br></pre></td></tr></table></figure><p>ARG和ENV的区别在于，ENV无论实在镜像构建时，还是容器运行时，该变量都可以使用。ARG只存在于构建镜像时。</p><p>10.1.12 USER 用户切换</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"><span class="keyword">USER</span> niubb</span><br></pre></td></tr></table></figure><h3 id="10-1-12-restart-重启机制">10.1.12 restart 重启机制</h3><p>docker容器的重启策略有下面四种:</p><ul><li><code>no</code><br>是默认的重启策略,docker容器如启动失败或意外停止后Docker Daemon不会尝试进行重启，除非手动启动容器，否则一直是stop的状态。</li><li><code>always</code><br>表示永远重启，它的先决条件是如果你使用<code>docker stop</code>命令停止了容器则docker不会自行启动该容器，但如果执行<code>docker stop</code>命令后重启了Docker Daemon则该容器会触发<code>always</code>重启策略，进而启动容器。</li><li><code>on-failure</code><br>重启策略的触发标准是当<code>Docker Daemon</code>检测到容器非正常停止后则会执行该重启策略。<code>on-failure</code>要求传入一个整型参数表示重启次数，当重启次数<code>&gt;=</code>该整数值则不会予以重启。</li><li><code>unless-stopped</code><br>重启策略与<code>always</code>很相似，唯一不同处在于<code>unless-stopped</code>会在<code>Docker Daemon</code>启动时会检测docker容器列表内的容器在上次停止时的状态，如果上一次容器停止时就是stop状态则不会启动该容器，否则启动该容器。</li></ul><h2 id="10-2-构建镜像">10.2 构建镜像</h2><p>cd切换到写好的dockerfile文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker bulid .</span><br><span class="line">docker bulid -t &#x27;取一个镜像名&#x27; .</span><br></pre></td></tr></table></figure><h1 id="11）容器数据卷">11）容器数据卷</h1><h2 id="1-命令">.1 命令</h2><ol><li><p>初始化运行容器时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br></pre></td></tr></table></figure></li><li><p>dockerfile:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;宿主机绝对路径&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>值得注意的是通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，而是自动生成的。</p><p>在dockerfile中VOLUME可以指定多个挂在目录，即<code>[&quot;宿主机绝对路径1&quot;,&quot;宿主机绝对路径2&quot;]</code>代表这两个目录都会挂在到宿主机的自动生成的目录。</p></li></ol><h2 id="2-概述">.2 概述</h2><ul><li><p>容器在运行时，应该保证在存储层不写入任何数据，运行在容器内产生的数据，我们推荐是挂载写入到宿主机上，进行维护。卷的设计目的就是<span style="color:red;">数据的持久化</span>，完全独立于容器的生存周期，因此Docker不会在容器删除是删除器挂载的数据卷。</p></li><li><p>特点：</p><ol><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol></li><li><p>注意：</p><p>Docker挂载主机目录访问如果出现<code>cannot open directory .: Permission denied</code></p><p>解决办法：在挂载目录后多加一个–privileged=true参数即可。</p><p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p></li></ul><h2 id="3-读写规则">.3 读写规则</h2><p><code>:rw</code> 默认规则为可读写。</p><p><code>:ro</code> 容器实例内部被限制，只能读取不能写(= read only)，此时如果宿主机写入内容，可以同步给容器内，容器可以读取到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw 镜像名</span><br><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure><h2 id="4-卷的继承和共享">.4 卷的继承和共享</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it  --privileged=true --volumes-from 父类容器id  --name u2 镜像名</span><br></pre></td></tr></table></figure><p>此时u2只是继承了父类容器的规则，父类容器如果挂掉并不会对u2的挂载产生影响。</p><h1 id="团队协作">团队协作</h1><h2 id="1-阿里云">.1 阿里云</h2><h2 id="2-dockerhub">.2 dockerhub</h2><h2 id="3-私有仓库">.3 私有仓库</h2><h3 id="3-1-创建私有仓库">.3.1 创建私有仓库</h3><ul><li><p>下载镜像Docker Registry</p><p>相当于本地有个私有Docker hub。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v $&#123;PWD&#125;/registry:/var/lib/registry --restart always --privileged=true --name registry registry</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件 daedom.json 使之支持http：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daedom.json</span><br></pre></td></tr></table></figure><p>在 daedom.json 添加：（！！！千万别漏掉后面的逗号！！！）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;你的ip地址:5000&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>重启 Docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-查看私有库镜像">.3.2 查看私有库镜像</h3><ul><li><p>浏览器访问 <code>http://你的ip地址:5000/v2/_catalog</code></p></li><li><p>或者 curl 查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://你的ip地址:5000/v2/_catalog</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-推送和拉取">.3.3 推送和拉取</h3><p>以下以nginx举例说明</p><ul><li><p>给镜像打上标签（使其符合私库规范）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:1.18.0 你的ip地址:5000/nginx:1.18.0</span><br></pre></td></tr></table></figure></li><li><p>把本地的镜像推到服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 你的ip地址:5000/nginx:1.18.0</span><br></pre></td></tr></table></figure></li><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 你的ip地址:5000/nginx:1.18.0</span><br></pre></td></tr></table></figure></li></ul><h1 id="Docker-APP常规安装">Docker APP常规安装</h1><h2 id="1-tomcat">.1 tomcat</h2><ul><li><p>创建临时容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 --rm --name temp_tomcat -d tomcat</span><br></pre></td></tr></table></figure><ul><li><p>8080如果不能访问，进入交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker_test ~]# docker exec -it temp_tomcat /bin/bash</span><br><span class="line">root@d69eb116a23c:/usr/local/tomcat# cd webapps</span><br><span class="line">root@d69eb116a23c:/usr/local/tomcat/webapps# cp -r webapps.dist/. webapps</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 --privileged=true  --restart=always \</span><br><span class="line">-v /mydata/tomcat/webapps:/usr/local/tomcat/webapps \</span><br><span class="line">-v /mydata/tomcat/logs:/usr/local/tomcat/logs \</span><br><span class="line">-v /mydata/tomcat/conf:/usr/local/tomcat/conf \</span><br><span class="line">--name tomcat \</span><br><span class="line">tomcat</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-MySQL">.2 MySQL</h2><ul><li><p>检查宿主机上是否有Mysql，以及3306端口占用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@nb /]# ps -ef | grep mysql</span><br><span class="line">root      4688  1287  0 01:35 pts/0    00:00:00 grep --color=auto mysql</span><br><span class="line">[root@nb /]# netstat -anp | grep 3306</span><br><span class="line">[root@nb /]# </span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=true --restart=always \</span><br><span class="line">-v /mydata/mysql/logs:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=000588 \</span><br><span class="line">--name mysql \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>修改配置</p><p>此时应该修改配置文件，否则默认不支持utf-8</p><p>修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /mydata/mysql/conf/my.cnf</span><br><span class="line">vim /mydata/mysql/conf/my.cnf</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure><p>重启容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><p>再次进入容器后再进入MySQL，查看当前字符集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql bash</span><br><span class="line">mysql -u root -p 123456</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;character%&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-redis">.3 redis</h2><ul><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --restart=always \</span><br><span class="line">--privileged=true \</span><br><span class="line">-v /mydata/redis/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">redis-server /etc/redis/redis.conf \</span><br><span class="line">--log-opt max-size=100m --log-opt max-file=2 \</span><br><span class="line">--appendonly yes \</span><br><span class="line">--requirepass 000588 \</span><br><span class="line">--name redis \</span><br><span class="line">-d redis</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>--privileged=true</code> 开启容器卷</li><li><code>--restart=always</code> 总是开机启动</li><li><code>-log</code>是日志方面的</li><li><code>-p 6379:6379</code> 将6379端口挂载出去</li><li><code>--name</code> 给这个容器取一个名字</li><li><code>-v</code> 数据卷挂载<ul><li><code>/mydata/redis/redis.conf:/etc/redis/redis.conf</code> 这里是将 liunx 路径下的myredis.conf 和redis下的redis.conf 挂载在一起。</li><li><code>/mydata/redis/data:/data</code> 这个同上</li></ul></li><li><code>-d redis</code> 表示后台启动redis</li><li><code>redis-server /etc/redis/redis.conf</code> 以配置文件启动 redis，加载容器内的 conf 文件，最终找到的是挂载的目录 <code>/etc/redis/redis.conf</code> 也就是 liunx 下的<code>/home/redis/myredis/myredis.conf</code></li><li><code>--appendonly yes</code> 开启redis 持久化</li><li><code>--requirepass 000588</code> 设置密码</li></ol></blockquote><ul><li><p>修改redis.conf</p><p>打开配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /mydata/redis/redis.conf</span><br></pre></td></tr></table></figure><p>修改 redis.conf ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1.开启redis验证</span><br><span class="line">requirepass 000588</span><br><span class="line"></span><br><span class="line"># 2.允许redis外地连接</span><br><span class="line"># 注释掉 </span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 3.将daemonize yes注释起来或者 daemonize no设置，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span><br><span class="line">daemonize no</span><br></pre></td></tr></table></figure><p>myredis.conf <a href="https://blog.csdn.net/FangHX25/article/details/109134203">原版conf翻译</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line"># bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line">requirepass 000588</span><br><span class="line"></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">logfile &quot;&quot;</span><br><span class="line"></span><br><span class="line">databases 30</span><br><span class="line"></span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line"></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line">rdb-save-incremental-fsync yes</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="4-nginx">.4 nginx</h2><ul><li><p>创建临时容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --rm --name temp-nginx -d nginx</span><br></pre></td></tr></table></figure><blockquote><ol><li><code>--rm</code> 退出容器时会自动将其删除</li></ol></blockquote></li><li><p>创建宿主机目录并拷贝需要创建的容器卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/nginx/conf</span><br><span class="line">mkdir -p /data/nginx/html</span><br><span class="line">mkdir -p /data/nginx/logs</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker cp temp-nginx:/etc/nginx/nginx.conf /data/nginx/conf/nginx.conf</span><br><span class="line">docker cp temp-nginx:/etc/nginx/conf.d /data/nginx/conf/conf.d</span><br><span class="line">docker cp temp-nginx:/usr/share/nginx/html /data/nginx</span><br><span class="line">chmod 777 /data/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop temp-nginx</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 -p 443:443 --privileged=true --restart=always \</span><br><span class="line">-v /mydata/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /mydata/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx \</span><br><span class="line">--name nginx \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure></li></ul><h1 id="Docker-APP复杂安装">Docker APP复杂安装</h1><h2 id="1-MySQL主从复制">1. MySQL主从复制</h2><ol><li><p>启动主库镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=<span class="literal">true</span> --restart=always \</span><br><span class="line">-v /mydata/mysql-master/logs:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=000588 \</span><br><span class="line">--name mysql-master \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>进入主库配置文件<code>/mydata/mysql-master/conf</code>下新建 <code>my.cnf</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，同一局域网中需要唯一</span></span><br><span class="line">server_id=101</span><br><span class="line"><span class="comment">## 指定不需要同步的数据库名称</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="comment">## 开启二进制日志功能</span></span><br><span class="line">log-bin=mall-mysql-bin</span><br><span class="line"><span class="comment">## 设置二进制日志使用内存大小（事务）</span></span><br><span class="line">binlog_cache_size=1M</span><br><span class="line"><span class="comment">## 设置使用的二进制日志格式（mixed,statement,row）</span></span><br><span class="line">binlog_format=mixed</span><br><span class="line"><span class="comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span><br><span class="line">expire_logs_days=7</span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure><p>重新启动主库容器<code>docker restart mysql-master</code>。</p></li><li><p>主库操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker 连接容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql-master /bin/bash -c <span class="string">&#x27;mysql -uroot -p000588&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改mysql身份验证插件为mysql_native_password;</span></span><br><span class="line"><span class="comment"># 因为mysql 8.0+起;其默认的身份验证插件为caching_sha2_password;</span></span><br><span class="line"><span class="comment"># 如果不改会导致登录验证失败;</span></span><br><span class="line"><span class="comment"># ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;000588&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建从库数据同步用户slave;</span></span><br><span class="line">CREATE USER slave IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;000588&#x27;</span>;</span><br><span class="line"><span class="comment">#  授权</span></span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"><span class="comment"># 查看主库状态（记录数据1,待用）</span></span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure></li><li><p>启动从服务器镜像</p><p>如果同宿主服务器修改:</p><p>端口<code>-p 3307:3306</code></p><p>容器名<code>--name mysql-slave</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=<span class="literal">true</span> --restart=always \</span><br><span class="line">-v /mydata/mysql-slave/logs:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=000588 \</span><br><span class="line">--name mysql-slave \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>进入主库配置文件<code>/mydata/mysql-slave/conf</code>下新建 <code>my.cnf</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment">## 设置server_id，同一局域网中需要唯一</span></span><br><span class="line">server_id=102</span><br><span class="line"><span class="comment">## 指定不需要同步的数据库名称</span></span><br><span class="line">binlog-ignore-db=mysql  </span><br><span class="line"><span class="comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用</span></span><br><span class="line">log-bin=mall-mysql-slave1-bin  </span><br><span class="line"><span class="comment">## 设置二进制日志使用内存大小（事务）</span></span><br><span class="line">binlog_cache_size=1M  </span><br><span class="line"><span class="comment">## 设置使用的二进制日志格式（mixed,statement,row）</span></span><br><span class="line">binlog_format=mixed  </span><br><span class="line"><span class="comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。</span></span><br><span class="line">expire_logs_days=7  </span><br><span class="line"><span class="comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。</span></span><br><span class="line"><span class="comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致</span></span><br><span class="line">slave_skip_errors=1062  </span><br><span class="line"><span class="comment">## relay_log配置中继日志</span></span><br><span class="line">relay_log=mall-mysql-relay-bin  </span><br><span class="line"><span class="comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志</span></span><br><span class="line">log_slave_updates=1  </span><br><span class="line"><span class="comment">## slave设置为只读（具有super权限的用户除外）</span></span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><p>重新启动从库容器<code>docker restart mysql-slave</code>。</p></li><li><p>从库操作(记录数据1)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql-slave /bin/bash -c <span class="string">&#x27;mysql -uroot -p000588&#x27;</span></span><br><span class="line"><span class="comment"># 如果主从在一台服务器,则需要通过[ docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; mysql] 查询主库容器IP</span></span><br><span class="line"><span class="comment"># 如果不在一台服务器,则直接使用外网ip即可 主库中两个结果添加进来</span></span><br><span class="line"></span><br><span class="line">change master to master_host=<span class="string">&#x27;192.168.206.105&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_password=<span class="string">&#x27;000588&#x27;</span>, master_port=3306, master_log_file=<span class="string">&#x27;mall-mysql-bin.000001&#x27;</span>, master_log_pos=154, master_connect_retry=30;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主数据库的IP地址；</span></span><br><span class="line">master_host：<span class="string">&#x27;192.168.206.105&#x27;</span>,</span><br><span class="line"><span class="comment"># 主数据库的运行端口；</span></span><br><span class="line">master_port：3306,</span><br><span class="line"><span class="comment"># 在主数据库创建的用于同步数据的用户账号；</span></span><br><span class="line">master_user：<span class="string">&#x27;slave&#x27;</span>,</span><br><span class="line"><span class="comment"># 在主数据库创建的用于同步数据的用户密码；</span></span><br><span class="line">master_password：<span class="string">&#x27;000588&#x27;</span>,</span><br><span class="line"><span class="comment"># 指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；</span></span><br><span class="line">master_log_file：<span class="string">&#x27;mysql-bin.000001&#x27;</span>,</span><br><span class="line"><span class="comment"># 指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；</span></span><br><span class="line">master_log_pos：154,</span><br><span class="line"><span class="comment"># 连接失败重试的时间间隔，单位为秒。</span></span><br><span class="line">master_connect_retry：30;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启主从同步</span></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line"><span class="comment"># 查看主从同步状况</span></span><br><span class="line">mysql&gt; show slave status\G;</span><br></pre></td></tr></table></figure><p><code>Slave_IO_Running</code>及<code>Slave_SQL_Running</code>为YES时;从库启动+主从复制成功。</p></li></ol><ul><li><p>停止主从复制</p><p>在从库中执行<code>stop slave；</code></p></li><li><p>读写分离</p><p>参考<a href="https://blog.csdn.net/jkjkjkll/article/details/125102188">https://blog.csdn.net/jkjkjkll/article/details/125102188</a></p></li></ul><p>Docker 网络</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;!--本文色卡号 #5FA55A #01B4BC #F6D51F #FA8925 #FA5457--&gt;
&lt;h1 id=&quot;1）简介&quot;&gt;1）简介&lt;/h1&gt;
&lt;div class=&quot;tip </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Gitee + PicGO 搭建图床</title>
    <link href="https://blog.halfsummer.xyz/posts/6c6bf881.html"/>
    <id>https://blog.halfsummer.xyz/posts/6c6bf881.html</id>
    <published>2023-03-13T23:00:32.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1）图床是干什么的？">1）图床是干什么的？</h1><p>图床就是一个便于在博文中插入在线图片连接的个人图片仓库。设置图床之后，在自己博客中插入的图片链接就可以随时随地在线预览了，并且不会因为任何意外原因无法查看，除非自己亲自删除。虽然你可以在CSDN上也可以生成图片链接。但是每个软件都有自己的防盗链机制，有时候你是不可以复制到其他平台的，这时候搭建一个免费的图床就显得尤为重要了。</p><h1 id="2）安装-PicGo">2）安装 PicGo</h1><p>PicGo的官网下载链接是：<code>https://www.github.com/Molunerfinn/PicGo</code></p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b04d72bc.png" alt="image-20230109103646118"  /><p>a.下载安装：</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b04ceec7.png" alt="windows安装包"></p><p>b.打开PicGo选择最底下的插件设置：</p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b04abcd9.png" alt="image-20230109104040950" style="zoom:50%;" /><p>c.搜索<code>gitee</code>安装<code>gitee-uploader 1.1.2</code>。（这里注意一下，必须要先安装<code>node.js</code>才能安装插件，没装的自己装一下，然后重启就行）</p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b046e705.png" alt="image-20230109104143565" style="zoom:50%;" /><h1 id="3）建立-Gitee-图床库">3）建立 Gitee 图床库</h1><ol><li><p><s><em>创建仓库的步骤略~</em></s></p></li><li><p>生成私人令牌token</p><p>a.点击头像，进入设置</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b044b99d.png" alt="image-20230109104944258"></p><p>b.找到右边安全设置里面的私人令牌。</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b0447c80.png" alt="image-20230109105044076"></p><p>c.点击生成新令牌，把<code>projects</code>这一项勾上，其他的不用勾，然后提交。</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b0677557.png" alt="image-20230109105146340"></p><p>这里需要验证一下密码，验证密码之后会出来一串数字，这一串数字就是你的token，<strong>令牌只会明文显示一次，令牌只会明文显示一次，令牌只会明文显示一次</strong>（重要的话说三遍），建议首先把这串字符复制到一个记事本保存起来。搞丢了又要重新生成一个。</p></li></ol><h1 id="4）配置-PicGo">4）配置 PicGo</h1><p>​这里就很容易理解了，填写一些gitee的信息，就可以实现软件互通了。这里如果你之前安装过PicGo，可能界面有点不同是因为版本的问题，但是不影响使用。</p><ul><li><p><strong>repo：用户名/仓库名(必须填写)</strong></p></li><li><p><strong>branch：分支，填写master</strong></p></li><li><p><strong>token：刚才你获取的个人令牌(必须填写)</strong></p></li><li><p><strong>path：上传到仓库的路径，可以不填</strong></p></li><li><p><strong>customPath：默认不填即可</strong></p></li><li><p><strong>customUrl：默认不填即可</strong></p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b06597ed.png" alt="image-20230109105723293" style="zoom:50%;" /></li></ul><h1 id="5）配置-Typora">5）配置 Typora</h1><p>选择 <code>文件 &gt; 偏好设置</code></p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230313-640f3b06c28d6.png" alt="image-20230109105909439"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;1）图床是干什么的？&quot;&gt;1）图床是干什么的？&lt;/h1&gt;
&lt;p&gt;图床就是一个便于在博文中插入在线图片连接的个人图片仓库。设置图床之后，在自己博客中插入的图片链接就可以随时随</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Markdown Mermaid思维导图</title>
    <link href="https://blog.halfsummer.xyz/posts/6c57ce3e.html"/>
    <id>https://blog.halfsummer.xyz/posts/6c57ce3e.html</id>
    <published>2023-03-13T22:55:31.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。</p><p><a href="https://mermaidjs.github.io/">点击进入官网</a></p><p><a href="https://github.com/knsv/mermaid">点击进入Github 项目地址</a></p><p><a href="https://zhuanlan.zhihu.com/p/355997933">参考文案</a></p><h1 id="1）语法">1）语法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR; # 其中LR指的是方向</span><br><span class="line">A --&gt; B # 不同的箭头表示</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A --&gt; B </span><br></pre></td></tr></table></figure><h1 id="2）方向">2）方向</h1><table><thead><tr><th>用词</th><th>含义</th></tr></thead><tbody><tr><td>TB</td><td>从上到下</td></tr><tr><td>BT</td><td>从下到上</td></tr><tr><td>RL</td><td>从右到左</td></tr><tr><td>LR</td><td>从左到右</td></tr></tbody></table><h1 id="3）节点间的连线">3）节点间的连线</h1><table><thead><tr><th>表述</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>添加尾部箭头</td></tr><tr><td><code>-</code></td><td>不添加尾部箭头</td></tr><tr><td><code>--</code></td><td>单线</td></tr><tr><td><code>--text--</code></td><td>单线上加文字</td></tr><tr><td><code>==</code></td><td>粗线</td></tr><tr><td><code>==text==</code></td><td>粗线加文字</td></tr><tr><td><code>-.-</code></td><td>虚线</td></tr><tr><td><code>-.text.-</code></td><td>虚线加文字</td></tr></tbody></table><h1 id="4）节点">4）节点</h1><p>即流程图中每个文本块，包括开始、结束、处理、判断等。Mermaid 中每个节点都有一个 id，以及节点的文字。</p><table><thead><tr><th>表述</th><th>说明</th></tr></thead><tbody><tr><td><code>id[文字]</code></td><td>矩形节点</td></tr><tr><td><code>id(文字)</code></td><td>圆角矩形节点</td></tr><tr><td><code>id([文字])</code></td><td>体育场形</td></tr><tr><td><code>id[[文字]]</code></td><td>子程序形</td></tr><tr><td><code>id[(文字)]</code></td><td>圆柱形</td></tr><tr><td><code>id((文字))</code></td><td>圆形节点</td></tr><tr><td><code>id&#123;文字&#125;</code></td><td>菱形节点</td></tr><tr><td><code>id&#123;&#123;文字&#125;&#125;</code></td><td>六角形</td></tr><tr><td><code>id[/文字/]</code></td><td>平行四边形</td></tr><tr><td><code>id[\文字\]</code></td><td>反向平行四边形</td></tr><tr><td><code>id[/文字\]</code></td><td>梯形</td></tr><tr><td><code>id[\文字/]</code></td><td>反向梯形</td></tr></tbody></table><ul><li><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A&gt;&quot;Ubuntu&lt;br&gt;(Linux)&quot;] -.soft.-&gt; C&#123;TV&#125;</span><br><span class="line">B[&quot;MAC&quot;] ==&gt; D((ARM64))</span><br><span class="line">D--&gt; C</span><br><span class="line">A --&gt; B</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A&gt;&quot;Ubuntu&lt;br&gt;(Linux)&quot;] -.soft.-&gt; C&#123;TV&#125;</span><br><span class="line">B[&quot;MAC&quot;] ==&gt; D((ARM64))</span><br><span class="line">D--&gt; C</span><br><span class="line">A --&gt; B</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a---b</span><br><span class="line">b--文本1!---c</span><br><span class="line">c---|文本2|d</span><br><span class="line">d===e</span><br><span class="line">e==文本3===f</span><br><span class="line">f-.-g</span><br><span class="line">g-.文本.-h</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a---b</span><br><span class="line">b--文本1!---c</span><br><span class="line">c---|文本2|d</span><br><span class="line">d===e</span><br><span class="line">e==文本3===f</span><br><span class="line">f-.-g</span><br><span class="line">g-.文本.-h</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A o--o B</span><br><span class="line">    B &lt;--&gt; C</span><br><span class="line">    C x--x D</span><br><span class="line">    </span><br><span class="line">    旧连线 --文本--&gt; 也会不同</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A o--o B</span><br><span class="line">    B &lt;--&gt; C</span><br><span class="line">    C x--x D</span><br><span class="line">    </span><br><span class="line">    旧连线 --文本--&gt; 也会不同</span><br></pre></td></tr></table></figure></li><li><p>延长连线：增加相应字符即可，如下图中的B到E，连线中增加了一个 <code>-</code> 。字符可多次添加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B --&gt;|Yes| C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B ---&gt;|No| E[End];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[Start] --&gt; B&#123;Is it?&#125;;</span><br><span class="line">    B --&gt;|Yes| C[OK];</span><br><span class="line">    C --&gt; D[Rethink];</span><br><span class="line">    D --&gt; B;</span><br><span class="line">    B ---&gt;|No| E[End];</span><br></pre></td></tr></table></figure><ul><li><p>多重链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   a --&gt; b &amp; c--&gt; d</span><br><span class="line">   </span><br><span class="line">   A &amp; B--&gt; C &amp; D</span><br><span class="line">   </span><br><span class="line">    X --&gt; M</span><br><span class="line">    X --&gt; N</span><br><span class="line">    Y --&gt; M</span><br><span class="line">    Y --&gt; N</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">   a --&gt; b &amp; c--&gt; d</span><br><span class="line">   </span><br><span class="line">   A &amp; B--&gt; C &amp; D</span><br><span class="line">   </span><br><span class="line">    X --&gt; M</span><br><span class="line">    X --&gt; N</span><br><span class="line">    Y --&gt; M</span><br><span class="line">    Y --&gt; N</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="5）注释-子图">5）注释 &amp;子图</h1><p>​<code>%%这是一条注释，在渲染图中不可见</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%%这是一条注释，在渲染图中不可见</span><br><span class="line">flowchart TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br><span class="line">    one --&gt; two</span><br><span class="line">    three --&gt; two</span><br><span class="line">    two --&gt; c2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%%这是一条注释，在渲染图中不可见</span><br><span class="line">flowchart TB</span><br><span class="line">    c1--&gt;a2</span><br><span class="line">    subgraph one</span><br><span class="line">    a1--&gt;a2</span><br><span class="line">    end</span><br><span class="line">    subgraph two</span><br><span class="line">    b1--&gt;b2</span><br><span class="line">    end</span><br><span class="line">    subgraph three</span><br><span class="line">    c1--&gt;c2</span><br><span class="line">    end</span><br><span class="line">    one --&gt; two</span><br><span class="line">    three --&gt; two</span><br><span class="line">    two --&gt; c2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;p&gt;Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python xlwings 将数据写入excel表格</title>
    <link href="https://blog.halfsummer.xyz/posts/6a75650e.html"/>
    <id>https://blog.halfsummer.xyz/posts/6a75650e.html</id>
    <published>2023-03-12T00:18:00.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1）创建book对象">1）创建book对象</h1><h2 id="📌打开excel程序，并新建一个工作簿">📌打开excel程序，并新建一个工作簿</h2><p>add_book参数为False时，只打开EXCEL程序,没有新建工作簿</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app=xw.App(visible=<span class="literal">True</span>,add_book=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="📌在打开了excel程序的情况后，再新建工作簿">📌在打开了excel程序的情况后，再新建工作簿</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb=app.books.add()</span><br></pre></td></tr></table></figure><h2 id="📌打开本地电脑上的文件">📌打开本地电脑上的文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line"><span class="comment">#open()里面是文件的路径</span></span><br><span class="line">wb = app.books.<span class="built_in">open</span>(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：</span></span><br><span class="line">wb = xw.Book(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="📌获得打开工作簿的绝对路径">📌获得打开工作簿的绝对路径</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pth=wb.fullname</span><br></pre></td></tr></table></figure><h2 id="📌获得工作簿的名称">📌获得工作簿的名称</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=wb.name</span><br></pre></td></tr></table></figure><h2 id="📌保存工作簿">📌保存工作簿</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.save(filepath)</span><br></pre></td></tr></table></figure><h2 id="📌关闭工作簿">📌关闭工作簿</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h2 id="📌退出excel程序">📌退出excel程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.quit()</span><br></pre></td></tr></table></figure><hr><h1 id="2）操作sheet对象">2）操作sheet对象</h1><h2 id="📌新建一个工作表">📌新建一个工作表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sht=wb.sheets.add(<span class="string">&#x27;工作表名&#x27;</span>)</span><br><span class="line"><span class="comment">#还可以带before=&#x27;表名&#x27;或者after=&#x27;表名&#x27;，表示新建表的位置.</span></span><br></pre></td></tr></table></figure><h2 id="📌删除指定的工作表">📌删除指定的工作表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.sheets[<span class="string">&#x27;工作表名&#x27;</span>].delete()</span><br></pre></td></tr></table></figure><h2 id="📌获得当前活跃的工作表">📌获得当前活跃的工作表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sht=wb.sheets.active</span><br></pre></td></tr></table></figure><h2 id="📌激活指定的工作表">📌激活指定的工作表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.sheets[<span class="string">&#x27;工作表名&#x27;</span>].activate()</span><br></pre></td></tr></table></figure><h2 id="📌获得工作表的名称">📌获得工作表的名称</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.sheets[表索引号].name</span><br></pre></td></tr></table></figure><h2 id="📌对工作表-sheet-进行重命名">📌对工作表(sheet)进行重命名</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.sheets[表索引或原工作表名].name=<span class="string">&#x27;新工作表名&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="📌清空整个工作表里的内容和格式">📌清空整个工作表里的内容和格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.sheets[<span class="string">&#x27;表名&#x27;</span>].clear()</span><br></pre></td></tr></table></figure><h2 id="📌获得工作簿中工作表sheet的数量">📌获得工作簿中工作表sheet的数量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wb.sheets.count</span><br></pre></td></tr></table></figure><h2 id="📌计算工作表sht中有数据区域最大的行数">📌计算工作表sht中有数据区域最大的行数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">max_row=sht[<span class="string">&#x27;a1048576&#x27;</span>].end(<span class="string">&#x27;up&#x27;</span>).row</span><br><span class="line"><span class="comment">#方法二：</span></span><br><span class="line">max_row=sht.used_range.last_cell.row</span><br></pre></td></tr></table></figure><h2 id="📌计算工作表sht中有数据区域最大的列数">📌计算工作表sht中有数据区域最大的列数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">max_column=sht[<span class="string">&#x27;xfd1&#x27;</span>].end(<span class="string">&#x27;left&#x27;</span>).column</span><br><span class="line">方法二：</span><br><span class="line">max_column=sht.used_range.last_cell.column</span><br></pre></td></tr></table></figure><h2 id="📌获得工作表中已经使用的单元格区域">📌获得工作表中已经使用的单元格区域</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">rng=sht.api.UsedRange</span><br><span class="line"><span class="comment">#方法二：</span></span><br><span class="line">rng=sht.used_range</span><br></pre></td></tr></table></figure><hr><h1 id="3）读取与写入">3）读取与写入</h1><h2 id="📌获得单元格的值">📌获得单元格的值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;a1&#x27;</span>).expand(<span class="string">&#x27;table&#x27;</span>).value</span><br><span class="line"><span class="comment">#也可以：</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;a1&#x27;</span>).expand().value</span><br></pre></td></tr></table></figure><h2 id="📌给单元格或单元格区域赋值常量">📌给单元格或单元格区域赋值常量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1&#x27;</span>).value = 常量    </span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1:Z10&#x27;</span>).value = 常量  <span class="comment">#也可以是一个区域。</span></span><br></pre></td></tr></table></figure><h2 id="📌给单元格或单元格区域赋值一个一维列表">📌给单元格或单元格区域赋值一个一维列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据写入的是excel行方向。</span></span><br><span class="line">sht.<span class="built_in">range</span>((<span class="string">&#x27;a1&#x27;</span>).value=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#数据写入的是excel列方向。</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1&#x27;</span>).options(transpose=<span class="literal">True</span>).value=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="📌给单元格或单元格区域赋值一个二维列表">📌给单元格或单元格区域赋值一个二维列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法1：range为一个单元格的时候</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1&#x27;</span>).options(expand=<span class="string">&#x27;table&#x27;</span>)=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法2：直接选一个同样大小的区域进行赋值。</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;a1:b2&#x27;</span>).value=[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure><h2 id="📌向单元格中写入公式">📌向单元格中写入公式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sht1.<span class="built_in">range</span>(<span class="string">&#x27;c1&#x27;</span>).formula = <span class="string">&#x27;=sum(a1:b1)&#x27;</span></span><br></pre></td></tr></table></figure><hr><h1 id="4）样式设置">4）样式设置</h1><p>先生成一个excel工作薄(book)，获得当前活动的工作表(sheet):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"></span><br><span class="line">app = xw.App(visible=<span class="literal">True</span>, add_book=<span class="literal">False</span>)</span><br><span class="line">wb = app.books.add()</span><br><span class="line">sht = wb.sheets.active</span><br><span class="line">cell = sht.<span class="built_in">range</span>(<span class="string">&#x27;c3&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="📌设置单元格大小-行高与列宽">📌设置单元格大小(行高与列宽)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;设置单元格大小&quot;&quot;&quot;</span></span><br><span class="line">sht.autofit()    <span class="comment"># 自动调整单元格大小。</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;a1:d5&#x27;</span>).column_width = <span class="number">5</span>    <span class="comment"># 设置第1-4列的列宽。</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>).row_height = <span class="number">20</span>     <span class="comment"># 设置第1行 行高</span></span><br></pre></td></tr></table></figure><h2 id="📌设置单元格字体-font-格式">📌设置单元格字体(font)格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;设置单元格 字体格式&quot;&quot;&quot;</span></span><br><span class="line">cell.color = <span class="number">255</span>,<span class="number">200</span>,<span class="number">255</span>         <span class="comment"># 设置单元格的填充颜色</span></span><br><span class="line">cell.api.Font.ColorIndex = <span class="number">3</span>     <span class="comment"># 设置字体的颜色，具体颜色索引见下方。</span></span><br><span class="line">cell.api.Font.Size = <span class="number">24</span>          <span class="comment"># 设置字体的大小。</span></span><br><span class="line">cell.api.Font.Bold = <span class="literal">True</span>        <span class="comment"># 设置为粗体。</span></span><br><span class="line">cell.api.NumberFormat = <span class="string">&quot;0.00&quot;</span>     <span class="comment"># 设置单元格的数字格式。</span></span><br></pre></td></tr></table></figure><h2 id="📌设置单元格对齐方式">📌设置单元格对齐方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;设置单元格的对齐方式&quot;&quot;&quot;</span></span><br><span class="line">cell.api.HorizontalAlignment = -<span class="number">4108</span>    <span class="comment"># -4108 水平居中。 -4131 靠左，-4152 靠右。</span></span><br><span class="line">cell.api.VerticalAlignment = -<span class="number">4130</span>      <span class="comment"># -4108 垂直居中（默认）。 -4160 靠上，-4107 靠下， -4130 自动换行对齐。</span></span><br></pre></td></tr></table></figure><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230312-640cb2ac9f971.png" alt="alignment"></p><h2 id="📌设置单元格边框">📌设置单元格边框</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;设置边框&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># Borders(9) 底部边框，LineStyle = 1 直线。</span></span><br><span class="line">cell.api.Borders(<span class="number">9</span>).LineStyle = <span class="number">1</span></span><br><span class="line">cell.api.Borders(<span class="number">9</span>).Weight = <span class="number">3</span>       <span class="comment"># 设置边框粗细。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Borders(7) 左边框，LineStyle = 2 虚线。</span></span><br><span class="line">cell.api.Borders(<span class="number">7</span>).LineStyle = <span class="number">2</span></span><br><span class="line">cell.api.Borders(<span class="number">7</span>).Weight = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Borders(8) 顶部框，LineStyle = 5 双点划线。</span></span><br><span class="line">cell.api.Borders(<span class="number">8</span>).LineStyle = <span class="number">5</span></span><br><span class="line">cell.api.Borders(<span class="number">8</span>).Weight = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Borders(10) 右边框，LineStyle = 4 点划线。</span></span><br><span class="line">cell.api.Borders(<span class="number">10</span>).LineStyle = <span class="number">4</span></span><br><span class="line">cell.api.Borders(<span class="number">10</span>).Weight = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Borders(5) 单元格内从左上角 到 右下角。</span></span><br><span class="line">cell.api.Borders(<span class="number">5</span>).LineStyle = <span class="number">1</span></span><br><span class="line">cell.api.Borders(<span class="number">5</span>).Weight = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Borders(6) 单元格内从左下角 到 右上角。</span></span><br><span class="line">cell.api.Borders(<span class="number">6</span>).LineStyle = <span class="number">1</span></span><br><span class="line">cell.api.Borders(<span class="number">6</span>).Weight = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230312-640cb2beb7632.png" alt="border-linestyle"></p><h2 id="📌区域内部边框设置如下">📌区域内部边框设置如下</h2><p>选择的是一个区域(range)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;如果是一个区域的单元格，内部边框设置如下&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># # Borders(11) 内部垂直边线。</span></span><br><span class="line">rng.api.Borders(<span class="number">11</span>).LineStyle = <span class="number">1</span></span><br><span class="line">rng.api.Borders(<span class="number">11</span>).Weight = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># # Borders(12) 内部水平边线。</span></span><br><span class="line">rng.api.Borders(<span class="number">12</span>).LineStyle = <span class="number">1</span></span><br><span class="line">rng.api.Borders(<span class="number">12</span>).Weight = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230312-640cb32b86896.png" alt="border02"></p><h2 id="📌合并-merge-拆分-unmerge-单元格">📌合并(merge)拆分(unmerge)单元格</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;合并拆分单元格&quot;&quot;&quot;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;C8:D8&#x27;</span>).api.merge()      <span class="comment"># 合并单元格 C8 到 D8</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;C8:D8&#x27;</span>).api.unmerge()    <span class="comment"># 拆分单元格。</span></span><br></pre></td></tr></table></figure><hr><h1 id="5）实例演示">5）实例演示</h1><p>利用xlwings，操作Excel文件，制作下述表格内容：</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230311-640c789a00faa.png" alt="image-20230311204818671"></p><p>命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">app = xw.App(visible=<span class="literal">False</span>, add_book=<span class="literal">False</span>)</span><br><span class="line">app.display_alerts = <span class="literal">False</span></span><br><span class="line">app.screen_updating = <span class="literal">False</span></span><br><span class="line">wb = app.books.add()</span><br><span class="line">sht = wb.sheets[<span class="string">&#x27;Sheet1&#x27;</span>]</span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1&#x27;</span>).value = <span class="string">&#x27;个人信息表&#x27;</span></span><br><span class="line"><span class="comment">#设置合并</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1:G1&#x27;</span>).api.Merge()</span><br><span class="line"></span><br><span class="line"><span class="comment"># xlwings设置excel单元格对齐方式</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1:G1&#x27;</span>).api.HorizontalAlignment =-<span class="number">4108</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A1:G1&#x27;</span>).api.VerticalAlignment = -<span class="number">4108</span></span><br><span class="line"><span class="comment">#数据写入的是excel行方向</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A2:F2&#x27;</span>).value = [<span class="string">&#x27;序号&#x27;</span>,<span class="string">&#x27;学号&#x27;</span>,<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;英语&#x27;</span>,<span class="string">&#x27;数学&#x27;</span>,<span class="string">&#x27;物理&#x27;</span>,<span class="string">&#x27;总分&#x27;</span>]</span><br><span class="line"><span class="comment">#数据写入的是excel列方向</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;A3:A8&#x27;</span>).options(transpose=<span class="literal">True</span>).value=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;B3:B8&#x27;</span>).options(transpose=<span class="literal">True</span>).value=[<span class="string">&#x27;id01&#x27;</span>,<span class="string">&#x27;id02&#x27;</span>,<span class="string">&#x27;id03&#x27;</span>,<span class="string">&#x27;id04&#x27;</span>,<span class="string">&#x27;id05&#x27;</span>,<span class="string">&#x27;id06&#x27;</span>]</span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;C3:C8&#x27;</span>).options(transpose=<span class="literal">True</span>).value=[<span class="string">&#x27;A01&#x27;</span>,<span class="string">&#x27;A02&#x27;</span>,<span class="string">&#x27;A03&#x27;</span>,<span class="string">&#x27;A04&#x27;</span>,<span class="string">&#x27;A05&#x27;</span>,<span class="string">&#x27;A06&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#以表格方式填入数据</span></span><br><span class="line">tables=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):<span class="comment">#列</span></span><br><span class="line">    rol=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">3</span>):<span class="comment">#行</span></span><br><span class="line">        rol.append(random.randint(<span class="number">0</span>,<span class="number">101</span>))  </span><br><span class="line">    tables.append(rol)</span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;D3&#x27;</span>).options(expand=<span class="string">&#x27;table&#x27;</span>).value=tables</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用公式计算</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;G3&#x27;</span>).formula=<span class="string">&#x27;=SUM(D3:F3)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;G4&#x27;</span>).formula=<span class="string">&#x27;=SUM(D4:F4)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;G5&#x27;</span>).formula=<span class="string">&#x27;=SUM(D5:F5)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;G6&#x27;</span>).formula=<span class="string">&#x27;=SUM(D6:F6)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;G7&#x27;</span>).formula=<span class="string">&#x27;=SUM(D7:F7)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;G8&#x27;</span>).formula=<span class="string">&#x27;=SUM(D8:F8)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;D9&#x27;</span>).formula=<span class="string">&#x27;=SUM(D3:D8)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;E9&#x27;</span>).formula=<span class="string">&#x27;=SUM(E3:E8)&#x27;</span></span><br><span class="line">sht.<span class="built_in">range</span>(<span class="string">&#x27;F9&#x27;</span>).formula=<span class="string">&#x27;=SUM(F3:F8)&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Python读写excel的库很多，有xlrd、xlwt、openpyxl、xlwings等。.xlwings库功能强大，window、mac系统都能使用，不仅可以读写excel数据，还可修改、设置格式，绘制图表，也可以调用VBA。同时语法简单，熟悉EXCEL中VBA语法的，相信很快就能掌握xlwings的使用。</summary>
    
    
    
    <category term="python" scheme="https://blog.halfsummer.xyz/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>Rsync备份服务器配置</title>
    <link href="https://blog.halfsummer.xyz/posts/9e614189.html"/>
    <id>https://blog.halfsummer.xyz/posts/9e614189.html</id>
    <published>2023-03-09T23:52:34.000Z</published>
    <updated>2023-03-13T17:11:01.902Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1）简介">1）简介</h1><p>rsync（remote synchronize）是Liunx/Unix下的一个远程数据同步工具。它可通过LAN/WAN快速同步多台主机间的文件和目录，并适当利用rsync算法（差分编码）以减少数据的传输。rsync算法并不是每一次都整份传输，而是只传输两个文件的不同部分，因此其传输速度相当快。除此之外，rsync可拷贝、显示目录属性，以及拷贝文件，并可选择性的压缩以及递归拷贝。</p><h2 id="1-1-rsync的工作原理">1.1 rsync的工作原理</h2><ul><li>客户端构造FileList，FileList包含了需要与服务器同步的所有文件信息对name-&gt;id<br>（id用来唯一表示文件例如MD5）</li><li>客户端将FileList发送到服务器。</li><li>服务器上rsync处理客户端发过来的FileList，构建新的NewFileList。其中根据MD5值比较，删除服务器上已经存在的文件信息对，只保留服务器上不存在或变化的文件。</li><li>客户端得到服务器发送过来的NewFileList，然后把NewFileList中的文件重新传输到服务器。</li></ul><h2 id="1-2-rsync优点">1.2 rsync优点</h2><ol><li><p>可以镜像保存整个目录树和文件系统。</p></li><li><p>可以很容易做到保持原来文件的权限、时间、软硬连接等。</p></li><li><p>无需特殊权限即可安装。</p></li><li><p>快速：第一次同步时rsync复制全部内容，但在下一次值传输修改过的内容</p></li><li><p>压缩传输：rysnc在传输的过程中可以实行压缩及解压缩操作，可以使用更少的带宽</p></li><li><p>安全：可以使用scp、ssh等方式来进行文件传输</p></li><li><p>支持匿名传输，以方便进行网站镜像</p></li><li><p>rsync不仅可以远程同步数据（类似于scp），而且可以本地同步数据（类似于cp），做差异同步</p></li><li><p>openssh 8.0已经把scp标记为过时不建议使用了。建议用sftp或者rsync替代scp</p></li></ol><p><em>（需要在Liunx/Unix服务器之间互传海量数据时，建议选择rsync进行传输）</em></p><h2 id="1-3-rsync认证方式">1.3 rsync认证方式</h2><p>rsync有两种常用的认证方式，一种是rsync-daemon方式，另外一种是ssh方式。</p><p>在平时使用过程，我们使用最多的是rsync-daemon方式。</p><p>⚠️<strong>注意：在使用rsync时，服务器和客户端都必须安装rsync程序</strong>。</p><h3 id="📌rsync-daemon-认证">📌rsync-daemon 认证</h3><p>rsync在rsync-daemon认证方式下，默认监听TCP的873端口。</p><p>rsync-daemon认证方式是rsync的主要认证方式，这个也是我们经常使用的认证方式。并且也只有在此种模式下，rsync才可以把密码写入到一个文件中。</p><blockquote><p>⚠️注意：<br>rsync-daemon认证方式，需要服务器和客户端都安装rsync服务并且只需要rsync服务器端启动rsync，同时配置rsync配置文件。客户端启动不启动rsync服务，都不影响同步的正常进行。</p></blockquote><h3 id="📌ssh认证">📌ssh认证</h3><p>rsync在ssh认证方式下，可通过系统用户进行认证，即在rsync上通过ssh隧道进行传输，类似于scp工具。此时同步操作不在局限于rsync中定义的同步文件夹。</p><blockquote><p>⚠️注意：<br>ssh认证方式，不需要服务器和客户端配置rsync配置文件只需要双方都安装rsync服务，并且也不需要双方启动rsync。</p></blockquote><p>若rsync服务端SSH为标准端口，此时rsync使用方式如下：</p><pre><code>rsync -avz /root/test root@10.10.10.10:/root/</code></pre><p>若rsync服务端SSH为非标准端口，可通过rsync的-e参数进行端口指定。使用方式如下：</p><pre><code>rsync -avz /root/test -e 'ssh -p1234' root@10.10.10.10:/root/</code></pre><h1 id="2）安装rsync">2）安装rsync</h1><p>安装rsync，我们可以分为两种方式：源码方式安装和RPM方式安装。</p><p><strong>注意：rsync软件无论是服务器端还是客户端都是同一个软件包。</strong></p><h2 id="2-1-源码方式安装">2.1 源码方式安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码方式安装rsync，需要到其官网下载对应的安装包。rsync官网：rsync.samba.org </span></span><br><span class="line"></span><br><span class="line">1)、下载</span><br><span class="line">wget https://download.samba.org/pub/samba/stable/samba-4.18.0.tar.gz</span><br><span class="line"></span><br><span class="line">2)、解压并安装</span><br><span class="line">tar -xvf rsync-4.18.0.tar.gz</span><br><span class="line"></span><br><span class="line">3)、编译安装</span><br><span class="line"><span class="comment"># 源码安装rsync时，其编译时所需要的gcc库文件尽量提前安装完毕</span></span><br><span class="line"><span class="comment"># 默认安装到/usr/local/目录下</span></span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">4)、设置开机启动</span><br><span class="line"><span class="built_in">echo</span> “/usr/local/bin/rsync --daemon -config=/etc/rsyncd.conf” &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-2-yum方式安装">2.2 yum方式安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install  rsync</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line"><span class="built_in">echo</span> “/usr/local/bin/rsync --daemon -config=/etc/rsyncd.conf” &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure><h1 id="3）配置rsync-daemon">3）配置rsync daemon</h1><h2 id="3-1-服务端配置">3.1 服务端配置</h2><p>📌<strong>准备rsync配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 rsync 用户启动进程</span></span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 无需让rsync以root身份运行，允许接收文件的完整属性</span></span><br><span class="line">fake super = <span class="built_in">yes</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁锢推送的数据至某个目录, 不允许跳出该目录</span></span><br><span class="line">use <span class="built_in">chroot</span> = no                </span><br><span class="line"></span><br><span class="line">max connections = 200          <span class="comment"># 最大连接数</span></span><br><span class="line"><span class="built_in">timeout</span> = 600                  <span class="comment"># 超时时间</span></span><br><span class="line">ignore errors                  <span class="comment"># 忽略错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> only = <span class="literal">false</span>              <span class="comment"># 对备份数据可读写</span></span><br><span class="line"></span><br><span class="line">list = <span class="literal">false</span>                   <span class="comment"># 不允许查看模块信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义虚拟用户，作为连接认证用户</span></span><br><span class="line">auth <span class="built_in">users</span> = myuser </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义rsync服务用户连接认证密码文件路径</span></span><br><span class="line">secrets file = /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 定义模块信息</span></span><br><span class="line">[backup]                </span><br><span class="line">comment = commit        <span class="comment"># 模块注释信息</span></span><br><span class="line">path = /backup          <span class="comment"># 定义接收备份数据目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只允许10.10.10段ip连接</span></span><br><span class="line">hosts allow = 10.10.10.0/24</span><br></pre></td></tr></table></figure><p>📌<strong>配置并启动守护进程</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要一个rsync进程运行时使用的普通用户 rsync</span></span><br><span class="line">useradd rsync -M -s /sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端需要定义一个客户端连接    虚拟用户名和密码</span></span><br><span class="line"><span class="comment"># 密码文件形式  user:passwd</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;myuser:password&quot;</span> &gt; /etc/rsync.passwd</span><br><span class="line"><span class="built_in">chmod</span> 600 /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备模块定义好的目录,客户端的数据都存放在该目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> /backup</span><br><span class="line"><span class="built_in">chown</span> -R rsync.rsync /backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">rsync --daemon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务</span></span><br><span class="line">ps aux | grep rsync</span><br><span class="line">netstat -lntp|grep 873</span><br></pre></td></tr></table></figure><h2 id="3-2-客户端的使用">3.2 客户端的使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 在客户端安装完毕rsync服务后，是不需要启动rsync服务的。</span></span><br><span class="line"><span class="comment"># 我们只需要在客户端创建连接rsync服务器时，验证码用户所需要的密码文件即可。</span></span><br><span class="line"><span class="comment"># 该密码文件中的密码要与rsync服务器上的密码文件中的密码对应</span></span><br><span class="line"><span class="comment"># 并且也要与rsync服务器rsyncd.conf配置文件中的认证模块中的用户匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> “password”&gt;&gt;/etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 600 /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 rsync 守护程序分配的所有 module 列表，可以执行下面命令。</span></span><br><span class="line">rsync rsync://10.10.10.10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体写法是服务器与目标目录之间使用双冒号分隔`::`</span></span><br><span class="line"><span class="comment"># 地址中的module并不是实际路径名，而是 rsync 守护程序指定的模块名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地的文件同步到远程服务器</span></span><br><span class="line"><span class="comment"># rsync [OPTION]… [SRC]… [USER@]HOST::DEST</span></span><br><span class="line"><span class="comment"># rsync [选项] [--port=]  [--password-file=] [/local/path] [用户名]@服务端IP::[模块名]</span></span><br><span class="line"></span><br><span class="line">rsync -av --password-file=/etc/rsync.passwd <span class="built_in">local</span>/ myuser@10.10.10.10::backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程机器的文件同步到本地</span></span><br><span class="line"><span class="comment"># rsync [OPTION]… [USER@]HOST::SRC [DEST]</span></span><br><span class="line"><span class="comment"># rsync [选项] [--port=] [--password-file=] [用户名@]服务端IP::[模块名]  [/local/path]</span></span><br><span class="line"></span><br><span class="line">rsync -av --password-file=/etc/rsync.passwd myuser@10.10.10.10::backup <span class="built_in">local</span>/</span><br></pre></td></tr></table></figure><h1 id="4）rsync使用">4）rsync使用</h1><h2 id="4-1-同步模式模式">4.1 同步模式模式</h2><h3 id="4-1-1-本地同步">4.1.1 本地同步</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##本地  rsync   选项       源      目标</span></span><br><span class="line">Local:  rsync [OPTION...] SRC... [DEST]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将/etc目录备份到/opt目录下，和cp的区别在于会自动增量备份</span></span><br><span class="line">rsync -avz /etc /opt</span><br></pre></td></tr></table></figure><h3 id="4-1-2远程同步">4.1.2远程同步</h3><h4 id="ssh协议">ssh协议</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认使用 SSH 进行远程登录和数据传输</span></span><br><span class="line"><span class="comment"># 不需要做任何配置，需要都安装rsync，操作上类似scp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将远端文件拉（下载）到本地</span></span><br><span class="line">Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">         </span><br><span class="line"><span class="comment">#将本地文件推送（上传）到远端</span></span><br><span class="line">Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br><span class="line"> </span><br><span class="line"><span class="comment">#将etc推送到10.10.10.10下的自定义文件夹下</span></span><br><span class="line">rsync -az /etc/ 10.10.10.10:/opt/etc-$(hostname)-$(<span class="built_in">date</span> +%F)</span><br></pre></td></tr></table></figure><h4 id="rsync协议">rsync协议</h4><blockquote><p>使用rsync协议，需要服务端启动守护进程</p><p>操作参考 <a href="">配置rsync daemon</a></p></blockquote><h2 id="4-2-命令参数">4.2 命令参数</h2><p>📌<strong>常用参数</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-v, –verbose详细模式输出。</span><br><span class="line"></span><br><span class="line">-a, –archive归档模式，表示以递归方式传输文件，并保持所有文件属性不变。</span><br><span class="line"></span><br><span class="line">-z, –compress对备份的文件在传输时进行压缩处理。</span><br><span class="line"></span><br><span class="line">–delete：删除那些DST中存在而在SRC中没有的文件。</span><br></pre></td></tr></table></figure><p>📌<strong>所有参数</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a：–archive archive mode 权限保存模式，相当于 -rlptgoD 参数，存档，递归，保持属性等。</span><br><span class="line">-r：–recursive 复制所有下面的资料，递归处理。</span><br><span class="line">-p：–perms 保留档案权限，文件原有属性。</span><br><span class="line">-t：–<span class="built_in">times</span> 保留时间点，文件原有时间。</span><br><span class="line">-g：–group 保留原有属组。</span><br><span class="line">-o：–owner 保留档案所有者(root only)。</span><br><span class="line">-D：–devices 保留device资讯(root only)。</span><br><span class="line">-l：–links 复制所有的连接，拷贝连接文件。</span><br><span class="line">-z：–compress 压缩模式，当资料在传送到目的端进行档案压缩。</span><br><span class="line">-H：–hard-links 保留硬链接文件。</span><br><span class="line">-A：–acls 保留ACL属性文件，需要配合–perms。</span><br><span class="line">-P：-P参数和 --partial --progress 相同，只是为了把参数简单化，表示传进度。</span><br><span class="line">--version：输出rsync版本。</span><br><span class="line">-v：–verbose 复杂的输出信息。</span><br><span class="line">-u：–update 仅仅进行更新，也就是跳过已经存在的目标位置，并且文件时间要晚于要备份的文件，不覆盖新的文件。</span><br><span class="line">--port=PORT：定义rsyncd(daemon)要运行的port(预设为tcp 873)。</span><br><span class="line"></span><br><span class="line">--delete：删除那些目标位置有的文件而备份源没有的文件。</span><br><span class="line"></span><br><span class="line">--delete-before: 接收者在传输之前进行删除操作</span><br><span class="line"></span><br><span class="line">--password-file=FILE ：从 指定密码文件中获取密码。</span><br><span class="line">--bwlimit=KBPS：限制 I/O 带宽。</span><br><span class="line">--filter “-filename”：需要过滤的文件。</span><br><span class="line">--exclude=filname：需要过滤的文件。</span><br><span class="line">--progress：显示备份过程。</span><br></pre></td></tr></table></figure><h1 id="5）示例">5）示例</h1><h2 id="5-1-常用示例">5.1 常用示例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前目录下所有文件同步到远端</span></span><br><span class="line">rsync -avzP ./* myuser@10.10.10.15::backup </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服务端同步数据到本地</span></span><br><span class="line">rsync -avzP  myuser@10.10.10.15::backup .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持服务端于客户端上数据完全一致，服务端有则同步给客户端，服务端没有，客户端有的则从客户端删除</span></span><br><span class="line"><span class="comment"># –delete 选项，表示客户端上的数据要与服务器端完全一致,多则删之，少则补之</span></span><br><span class="line"><span class="comment"># 用的时候要小心点，最好不要把已经有重要数所据的目录，当做本地更新目录，否则会把你的数据全部删除</span></span><br><span class="line">rsync -avzP  --delete myuser@10.10.10.15::backup  /tmp/test/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的 rsync 命令将10.10.10.10主机上的 /www 目录（不包含 /www/logs 和 /www/conf子目录）复制到本地的 /backup/www/ </span></span><br><span class="line">rsync -avzP --delete --exclude <span class="string">&quot;logs/&quot;</span> --exclude <span class="string">&quot;conf/&quot;</span>  \</span><br><span class="line">10.10.10.10:/www/ /backup/www/</span><br></pre></td></tr></table></figure><h2 id="5-2-快速删除大量数据">5.2 快速删除大量数据</h2><p><strong>在<code>need_delete</code> 目录下建立30万个文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">time <span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 300000)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">test</span> &gt;&gt;<span class="variable">$i</span>.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行时间</span></span><br><span class="line">real0m42.267s</span><br><span class="line">user0m6.756s</span><br><span class="line">sys0m33.973s</span><br></pre></td></tr></table></figure><p><strong>测试rsync删除</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建一个空目录new_dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后执行 </span></span><br><span class="line">time rsync -a --delete-before new_dir/ need_delete/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需要几秒钟，速度非常快</span></span><br><span class="line">real0m8.146s</span><br><span class="line">user0m0.216s</span><br><span class="line">sys0m7.127s</span><br></pre></td></tr></table></figure><p><strong>测试 rm -rf 删除</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time <span class="built_in">rm</span> -rf need_delete/</span><br><span class="line"></span><br><span class="line">real0m9.639s</span><br><span class="line">user0m0.143s</span><br><span class="line">sys0m8.250s</span><br></pre></td></tr></table></figure><h1 id="6）rsyncd-conf-详解">6）rsyncd.conf 详解</h1><h2 id="6-1-全局参数">6.1 全局参数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在独立运行时，用于指定的服务器运行的 IP 地址</span></span><br><span class="line">address = IP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听端口</span></span><br><span class="line">port = 873 </span><br><span class="line"></span><br><span class="line"><span class="comment"># rsync 的守护进程将其 PID 写入指定的文件</span></span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定支持 max connections 参数的锁文件</span></span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 rsync 守护进程的日志文件，而不将日志发送给 syslog</span></span><br><span class="line"><span class="built_in">log</span> file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#========== 控制参数 =============#</span></span><br><span class="line"> <span class="comment"># 以指定的 UID 传输文件</span></span><br><span class="line">uid = rsync        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定该模块以指定的 GID 传输文件。</span></span><br><span class="line">gid = rsync                     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁锢推送的数据至某个目录, 不允许跳出该目录,</span></span><br><span class="line"><span class="comment"># 默认为 yes，则 rsync 在传输文件之前首先 chroot 到 path 参数所指定的目录下</span></span><br><span class="line"><span class="comment"># 这样做的原因是实现额外的安全防护，但是缺点是需要 root 权限</span></span><br><span class="line"><span class="comment"># 并且不能备份指向 path 外部的符号连接所指向的目录文件</span></span><br><span class="line">use <span class="built_in">chroot</span> = no                </span><br><span class="line"></span><br><span class="line"><span class="comment"># 无需让rsync以root身份运行，允许接收文件的完整属性</span></span><br><span class="line">fake super = <span class="built_in">yes</span>                </span><br><span class="line"></span><br><span class="line"><span class="comment"># 大并发连接数量以保护服务器，超过限制的连接请求将被告知随后再试</span></span><br><span class="line"><span class="comment"># 默认为0 （没有限制）</span></span><br><span class="line">max connections = 200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时时间</span></span><br><span class="line"><span class="built_in">timeout</span> = 600               </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定在 rsync 服务器上运行 delete 操作时是否忽略 I/O 错误。</span></span><br><span class="line"><span class="comment"># 一般来说 rsync 在出现 I/O 错误时将将跳过 –delete 操作</span></span><br><span class="line"><span class="comment"># 以防止因为暂时的资源不足或其它 I/O 错误导致的严重问题。</span></span><br><span class="line">ignore errors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定是否允许客户上传文件。</span></span><br><span class="line"><span class="comment"># 默认为true，不允许用户上传文件，</span></span><br><span class="line"><span class="comment"># 若为 false 并且服务器目录也具有读写权限则允许上传。</span></span><br><span class="line"><span class="built_in">read</span> only = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定当客户请求列出可以使用的模块列表时，该模块是否应该被列出。</span></span><br><span class="line"><span class="comment"># 默认为 true，如果设置该选项为 false，可以创建隐藏的模块</span></span><br><span class="line">list = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="6-2-模块参数">6.2 模块参数</h2><blockquote><p>模块参数主要用于定义 rsync 服务器哪个目录要被同步。</p><p>模块声明的格式必须为 [module] 形式，这个名字就是在 rsync 客户端看到的名字，类似于 Samba 服务器提供的共享名。</p><p>而服务器真正同步的数据是通过 path 来指定的。可以根据自己的需要，来指定多个模块，模块中可以定义以下参数：</p></blockquote><p><strong>基本模块参数</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定模块名</span></span><br><span class="line">[backup]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定当前模块在 rsync 服务器上的同步路径，该参数是必须指定的</span></span><br><span class="line">path = /backup  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 给模块指定一个描述，该描述连同模块名在客户连接得到模块列表时显示给客户</span></span><br><span class="line">comment = commit</span><br></pre></td></tr></table></figure><p><strong>模块文件筛选参数</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定多个由空格隔开的多个文件或目录(相对路径)</span></span><br><span class="line"><span class="comment"># 并将其添加到 exclude 列表中。这等同于在客户端命令中使用 –exclude 来指定模式。</span></span><br><span class="line">exclude = exclude_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个包含 exclude 规则定义的文件名，服务器从该文件中读取 exclude 列表定义</span></span><br><span class="line">exclude from = exclude-file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多个由空格隔开的多个文件或目录(相对路径)，并将其添加到 include 列表中。</span></span><br><span class="line"><span class="comment"># 这等同于在客户端命令中使用 –include 来指定模式 。</span></span><br><span class="line">include = include-file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个包含 include 规则定义的文件名，服务器从该文件中读取 include 列表定义</span></span><br><span class="line">include from = exclude-file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个模块只能指定一个exclude 参数、一个include 参数</span></span><br><span class="line"><span class="comment"># 结合 include 和 exclude 可以定义复杂的exclude/include 规则</span></span><br><span class="line"><span class="comment"># 这几个参数分别与相应的rsync 客户命令选项等价，唯一不同的是它们作用在服务器端</span></span><br></pre></td></tr></table></figure><p><strong>模块用户认证参数</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rsync 默认匿名方式传输</span></span><br><span class="line"><span class="comment"># 若只配置匿名访问的 rsync 服务器，则无需设置下述参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定由空格或逗号分隔的用户名列表，只有这些用户才允许连接该模块。</span></span><br><span class="line"><span class="comment"># 这里的用户和系统用户没有任何关系。用户名和口令以明文方式存放在 secrets file 参数指定的文件中</span></span><br><span class="line">auth <span class="built_in">users</span> = user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个 rsync 认证口令文件。只有在 auth users 被定义时，该文件才起作用</span></span><br><span class="line">secrets file = /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># rsync 认证口令文件的权限一定是 600，否则客户端将不能连接服务器。</span></span><br><span class="line"><span class="comment"># rsync 认证口令文件中每一行指定一个 用户名:口令 对，格式为：</span></span><br><span class="line"><span class="comment"># username:passwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说口令最好不要超过8个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个rsync配置文件中可以包含多个认证模块，同时一个密码文件中也可以存放多个用户和其对应的密码。</span></span><br><span class="line"><span class="comment"># 其中每一个认证模块可以对应不同的客户端。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;1）简介&quot;&gt;1）简介&lt;/h1&gt;
&lt;p&gt;rsync（remote synchronize）是Liunx/Unix下的一个远程数据同步工具。它可通过LAN/WAN快速同步多台</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NFS服务器配置</title>
    <link href="https://blog.halfsummer.xyz/posts/757768a4.html"/>
    <id>https://blog.halfsummer.xyz/posts/757768a4.html</id>
    <published>2023-03-09T22:54:06.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1）这里用一个实例环境来讲解">1）这里用一个实例环境来讲解</h1><table><thead><tr><th>hostname</th><th>ip</th></tr></thead><tbody><tr><td>Server-nfs</td><td>192.168.0.1</td></tr><tr><td>Cilent-nfs-linux</td><td>192.168.0.10</td></tr><tr><td>Cilent-nfs-windows</td><td>192.168.0.20</td></tr></tbody></table><p>📌 <strong>配置网络环境</strong></p><p>-----略-----</p><hr><h1 id="2）NFS-服务端部署">2）NFS 服务端部署</h1><h2 id="📌-在服务端安装NFS服务">📌 <strong>在服务端安装NFS服务</strong></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nfs-utils rpcbind</span><br></pre></td></tr></table></figure><h2 id="📌-创建共享目录">📌 <strong>创建共享目录</strong></h2><p>这个目录可以在任意位置的任意名字</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/share</span><br><span class="line"><span class="built_in">chmod</span> o+w /opt/share/</span><br></pre></td></tr></table></figure><h2 id="📌-配置共享目录">📌 <strong>配置共享目录</strong></h2><p>默认文件为空：此配置按列分隔</p><ul><li><p>第一列：<strong>共享文件的路径</strong></p></li><li><p>第二列：&lt;客户端ip&gt;(&lt;rw(读写)&gt; | &lt;ro(只读)&gt;,&lt;all_squash(映射为系统账号)&gt;)</p><blockquote><p>系统账号为nfs-nobody（/etc/passwd可查看）</p></blockquote></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/exports</span><br><span class="line"></span><br><span class="line">/opt/share192.168.0.0/24(rw,all_squash)</span><br></pre></td></tr></table></figure><h2 id="📌重启NFS服务">📌<strong>重启NFS服务</strong></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nfs</span><br><span class="line">systemctl status nfs</span><br></pre></td></tr></table></figure><hr><h1 id="3）Linux-NFS-客户端部署">3）Linux NFS 客户端部署</h1><h2 id="📌在客户端安装NFS服务">📌在客户端安装NFS服务</h2><p>这里并不是用于配置服务端，而是让客户端挂载时能够识别服务端的文件系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install nfs-utils rpcbind</span><br></pre></td></tr></table></figure><h2 id="📌创建挂载点">📌创建挂载点</h2><p>语法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs &lt;服务器ip&gt;:&lt;共享的绝对路径&gt; 本地挂载点</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mnt/nfs_share</span><br><span class="line">mount -t nfs 192.168.0.1:/opt/share /mnt/nfs_share</span><br></pre></td></tr></table></figure><hr><h1 id="4）Windows-NFS-客户端部署">4）Windows NFS 客户端部署</h1><h2 id="📌-安装nfs客户端">📌 安装nfs客户端</h2><p>windows一般只有在旗舰版中才有nfs，在服务中安装nfs客户端即可，版本较多自行百度。</p><h2 id="📌-查看NFS服务器共享的信息">📌 查看NFS服务器共享的信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e 192.168.0.1</span><br></pre></td></tr></table></figure><h2 id="📌挂载">📌挂载</h2><p>注意Windows下的斜杆为撬棍！</p><p>语法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount \\&lt;服务器ip&gt;\&lt;共享的绝对路径&gt; 盘符</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount \\192.168.0.1\opt\share x:<span class="comment"># 必须使用未使用的盘符</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;1）这里用一个实例环境来讲解&quot;&gt;1）这里用一个实例环境来讲解&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;hostname&lt;/th&gt;
&lt;th&gt;ip&lt;/th</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PassWall的正确设置，利用SmartDNS实现国内外分离</title>
    <link href="https://blog.halfsummer.xyz/posts/d3fb2262.html"/>
    <id>https://blog.halfsummer.xyz/posts/d3fb2262.html</id>
    <published>2023-03-06T10:43:16.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="查看本地dns服务的端口">查看本地dns服务的端口</h1><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-640559303e3a7.png" alt="image-20230306110832844"></p><p>这里是6153记下来。</p><hr><h1 id="PassWall配置">PassWall配置</h1><p>📌 启用</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-640553f46895a.png" alt="image-20230306104605886"></p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-640558f7632fc.png" alt="image-20230306110735947"></p><hr><h1 id="SmartDNS配置">SmartDNS配置</h1><p>📌 常规配置页：</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-6405542633d0a.png" alt="image-20230306104702793"></p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-640555bb1b04a.png" alt="image-20230306105347649"></p><p>📌 自己添加DNS服务器：</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-6405545242fc2.png" alt="image-20230306104746841"></p><p>📌 重点来了在此我们需要将国内和国外的dns服务器分开：(这里分为CN和GW)</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-6405554830079.png" alt="image-20230306105152740"></p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-64055577e6c99.png" alt="image-20230306105240507"></p><p>📌 在自定义设置中添加：</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-640557a0bf385.png" alt="image-20230306110153316"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="string">:6153</span> <span class="string">-group</span> <span class="string">CN</span></span><br><span class="line"><span class="string">bind</span> <span class="string">:6453</span> <span class="string">-group</span> <span class="string">GW</span> <span class="string">-no-speed-check</span> <span class="string">-no-cache</span></span><br></pre></td></tr></table></figure><p>📌 拉到下方，保存&amp;应用。</p><hr><h1 id="注意事项">注意事项</h1><h2 id="1-PassWall的规则列表">1.PassWall的规则列表</h2><p>这个区域必须要有填写在SmartDNS的地址，没有请自己加上。</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-640559e64988b.png" alt="image-20230306111134867"></p><h2 id="2-如果可以访问外网但是不能访问国内">2.如果可以访问外网但是不能访问国内</h2><p>📌 请这样设置</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-64055a84a8597.png" alt="image-20230306111413322"></p><p>📌 在试试可以不，如果还不行修改防火墙规则</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-64055ad1e8e8a.png" alt="image-20230306111530529"></p><p>添加：（这里eth1是我的网卡，你修改成你的）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I POSTROUTING -o eth1 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>📌 最后在试试，把这两个接受下</p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230306-64055b5e4254c.png" alt="image-20230306111750768"></p><h2 id="3-国内外DNS汇总">3.国内外DNS汇总</h2><blockquote><p><strong>国内DNS:</strong><br><strong>阿里公共DNS：</strong><br>223.5.5.5   类型选择：UDP<br>223.6.6.6   类型选择：UDP<br>阿里加密DNS：alidns_ip/dns-query   类型选择：https<br>阿里加密DNS：<a href="http://dns.alidns.com/dns-query">dns.alidns.com/dns-query</a>   类型选择：https<br><strong>腾讯公共DNS:</strong><br>DNS：119.29.29.29  类型选择：UDP<br>腾讯加密DNS：doh.pub/dns-query  类型选择：https<br>腾讯加密DNS：sm2.doh.pub/dns-query  类型选择：https<br><strong>360公共DNS</strong><br>中国电信/铁通/移动：  101.226.4.6   218.30.118.6   类型选择：UDP<br>中国联通：  123.125.81.6      140.207.198.6   类型选择：UDP<br>百度公共DNS：180.76.76.76  类型选择：UDP<br>**114DNS：**114.114.114.114    114.114.115.115   类型选择：UDP</p></blockquote><blockquote><p><strong>国外DNS：</strong><br>**CloudflareDNS：**1.1.1.1   类型选择：UDP<br>Cloudflare加密DNS：1.1.1.1/dns-query   类型选择：tls<br><strong>Google DNS：</strong><br>8.8.8.8      8.8.4.4    类型选择：UDP<br>谷歌加密DNS：dns.google/dns-query   类型选择：https<br>谷歌加密DNS：dns.google   类型选择：tls<br><strong>Norton ConnectSafe：</strong> 199.85.126.10    199.85.127.10  类型选择：UDP<br>威瑞信：64.6.64.6   64.6.65.6  类型选择：UDP<br><strong>Comodo安全DNS：</strong>  8.26.56.2    68.20.247.20  类型选择：UDP<br><strong>DNS Watch：</strong> 84.200.69.80    84.200.70.40  类型选择：UDP<br><strong>Quad9：</strong><br>Quda9加密DNS：<a href="http://dns11.quad9.net/dns-query">dns11.quad9.net/dns-query</a></p></blockquote><p><strong>原理我就不讲解了，照着搬就可以了。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;查看本地dns服务的端口&quot;&gt;查看本地dns服务的端口&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://cos.halfsummer.xyz/pictures/niub</summary>
      
    
    
    
    <category term="openwrt" scheme="https://blog.halfsummer.xyz/categories/openwrt/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux三剑客grep、sed、awk</title>
    <link href="https://blog.halfsummer.xyz/posts/b29674f9.html"/>
    <id>https://blog.halfsummer.xyz/posts/b29674f9.html</id>
    <published>2023-03-06T10:16:10.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1）三剑客的特点及应用场景">1）三剑客的特点及应用场景</h1><table><thead><tr><th>命令</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td>grep</td><td>过滤</td><td>过滤速度是最快的</td></tr><tr><td>sed</td><td>替换，修改文件内容，取行</td><td>如果要进行替换/修改文件内容<br/>取出某个范围的内容</td></tr><tr><td>awk</td><td>取列，统计计算</td><td>取列<br/>对比，比较<br/>统计计算</td></tr></tbody></table><hr><h1 id="2）grep">2）grep</h1><p>grep全拼：Global search Regular expression and Print out the line</p><p>作用，文本搜索工具，根据用户指定的条件对目标文本进行匹配检查并打印匹配的行。</p><p>📌<strong>语法</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep [options] [pattern] file</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-E</td><td>相当于egrep，正则</td></tr><tr><td>-A</td><td>after；-A5 匹配你要的内容显示接下来的5行</td></tr><tr><td>-B</td><td>before；-B5 匹配你要的内容显示上面的5行</td></tr><tr><td>-C</td><td>context；-C5 匹配你要的内容显示上下5行</td></tr><tr><td>-c</td><td>只统计匹配到的行数（类似于wc -l）</td></tr><tr><td>-v</td><td>取反（一般用于对自己取反<code>grep -v grep</code>；查询进程时grep也会产生进程）</td></tr><tr><td>-n</td><td>显示行号</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-w</td><td>精确匹配</td></tr></tbody></table><h1 id="3）sed">3）sed</h1><h2 id="3-1-简介">3.1 简介</h2><p>sed是Stream Editor (字符流编辑器)的缩写，简称流编辑器。</p><p>常用功能包括结合正则表达式对文件实现快速增删改查,其中查询的功能中最常用的两大功能是过滤(过滤指定字符串)、取行(取出指定行)。</p><h2 id="3-2-执行过程">3.2 执行过程</h2><p><span style="color:blue;">四个字总结： “找谁干啥”</span></p><p><img src="https://cos.halfsummer.xyz/pictures/niubb/2023/20230308-6407e969a99cc.png" alt="img"></p><h2 id="3-3-语法">3.3 语法</h2><p>📌<strong>语法</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sed [options] <span class="string">&#x27;&#123;command&#125;[flags]&#x27;</span> [filename]    </span><br><span class="line"><span class="comment"># 中括号内容必有 大括号内容可有可无</span></span><br><span class="line">sed  <span class="comment"># 执行命令</span></span><br><span class="line">[options]  <span class="comment"># 命令选项</span></span><br><span class="line">&#123;<span class="built_in">command</span>&#125;[flags]    <span class="comment"># sed内部选项和参数</span></span><br><span class="line">[filename]     <span class="comment"># 文件</span></span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong> <code>options</code>：</p><table border="0">  <tbody>    <tr>      <td>参数</td>      <td>解释</td>    </tr>    <tr>      <td>-n</td>      <td>        取消sed默认输出（默认输出：无论是不是匹配项都输出，即像cat一样把文本内容打印出来），常与sed内置命令p一起使用      </td>    </tr>    <tr>      <td>-i</td>      <td>        直接将修改结果写入文件，不用-i，sed修改的是内存数据而不是修改源文件      </td>    </tr>    <tr>      <td>-e</td>      <td>多次编辑，不再需要管道符了</td>    </tr>    <tr>      <td>-r</td>      <td>支持正则扩展</td>    </tr>  </tbody></table><p>📌<strong>内部命令</strong> <code>command</code>：</p><p>常用：增删改查</p><table>  <tbody>    <tr>      <td style="vertical-align: top">        <p><strong>操作符</strong></p>      </td>      <td style="vertical-align: top; width: 240px">        <p><strong>用途</strong></p>      </td>      <td style="vertical-align: top; width: 192px">        <p><strong>指令示例</strong></p>      </td>      <td style="vertical-align: top">        <p><strong>解释</strong></p>      </td>    </tr>    <tr>      <td rowspan="3" style="vertical-align: top">        <p><strong>s</strong></p>      </td>      <td rowspan="3" style="vertical-align: top; width: 240px">        <p>字符串替换(substitution)</p>      </td>      <td style="vertical-align: top; width: 192px"><p>s/old/new/</p></td>      <td style="vertical-align: top">        <p>将每行的第1&nbsp;个old替换为new</p>      </td>    </tr>    <tr>      <td style="vertical-align: top; width: 192px"><p>s/old/new/3</p></td>      <td style="vertical-align: top">        <p>将每行的第3&nbsp;个old替换为new</p>      </td>    </tr>    <tr>      <td style="vertical-align: top; width: 192px"><p>s/old/new/g</p></td>      <td style="vertical-align: top"><p>将所有的old都替换为new</p></td>    </tr>    <tr>      <td rowspan="2" style="vertical-align: top">        <p><strong>p</strong></p>      </td>      <td rowspan="2" style="vertical-align: top; width: 240px">        <p>打印行（print）</p>      </td>      <td style="vertical-align: top; width: 192px">        <p>2，4p&nbsp;&nbsp;&nbsp;</p>      </td>      <td style="vertical-align: top"><p>输出第2－4行</p></td>    </tr>    <tr>      <td style="vertical-align: top; width: 192px"><p>2p,4p</p></td>      <td style="vertical-align: top"><p>输出第2行、第4行</p></td>    </tr>    <tr>      <td style="vertical-align: top">        <p><strong>d</strong></p>      </td>      <td style="vertical-align: top; width: 240px"><p>删除行（delete）</p></td>      <td style="vertical-align: top; width: 192px"><p>2,4d</p></td>      <td style="vertical-align: top"><p>删除第2－4行</p></td>    </tr>    <tr>      <td rowspan="3" style="vertical-align: top">        <p><strong>cai</strong></p>      </td>      <td rowspan="3" style="vertical-align: top; width: 240px">        <p>取代/新增/插入</p>      </td>      <td style="vertical-align: top; width: 192px"><p>c</p></td>      <td style="vertical-align: top">        <p>c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行</p>      </td>    </tr>    <tr>      <td style="vertical-align: top; width: 192px"><p>a</p></td>      <td style="vertical-align: top">        <p>a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</p>      </td>    </tr>    <tr>      <td style="vertical-align: top; width: 192px"><p>i</p></td>      <td style="vertical-align: top">        <p>i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)</p>      </td>    </tr>  </tbody></table><p>📌<strong>sed匹配范围</strong>：</p><table border="0">  <tbody>    <tr>      <td>范围</td>      <td>解释</td>    </tr>    <tr>      <td>空地址</td>      <td>全文处理</td>    </tr>    <tr>      <td>单地址</td>      <td>指定文件某一行</td>    </tr>    <tr>      <td>/pattern/</td>        <td>被模式匹配到的每一行，<span style="color:red;">斜线中表示正则！！！</span></td>    </tr>    <tr>      <td>范围区间</td>      <td>10,20表示10~20行；10，+5第10行向下5行;/pattern1/,/pattern2/</td>    </tr>    <tr>      <td>步长</td>      <td>1~2表示1,3,5,7奇数行，2~2表示2,4,6,8偶数行</td>    </tr>  </tbody></table>## 3.4 应用<h3 id="📌示例">📌示例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@db001 ~]<span class="comment"># cat &gt; test.txt &lt;&lt;EOF </span></span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="📌查找（打印）p">📌查找（打印）<code>p</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印test.txt文件内容</span></span><br><span class="line">$ sed <span class="string">&#x27;p&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印test.txt文件第三行的内容</span></span><br><span class="line">$ sed <span class="string">&#x27;3p&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印test.txt文件第二、三、四行内容</span></span><br><span class="line">$ sed <span class="string">&#x27;2,4p&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印test.txt文件包含字符串&quot;3 the&quot;的行</span></span><br><span class="line">$ sed <span class="string">&#x27;/3 the/p&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog </span><br><span class="line"><span class="comment">#可以看得出，打印内容是重复的行，原因是打印了指定文件内容一次，又将读入缓存的所有数据打印了一次，所以会看到这样的效果，如果不想看到这样的结果，可以加命令选项-n抑制内存输出即可。</span></span><br></pre></td></tr></table></figure><h3 id="📌删除-d">📌删除  <code>d</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除文件test.txt中的所有数据</span></span><br><span class="line">$ sed <span class="string">&#x27;d&#x27;</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除文件test.txt中的第三行数据</span></span><br><span class="line">$ sed <span class="string">&#x27;3d&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除文件test.txt第三到第四行的数据</span></span><br><span class="line">$ sed <span class="string">&#x27;3,4d&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除文件test.txt中包含字符串&quot;3 the&quot;的行</span></span><br><span class="line">$ sed <span class="string">&#x27;/3 the/d&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br></pre></td></tr></table></figure><h3 id="📌增加-c-a-i">📌增加  <code>c</code> <code>a</code> <code>i</code></h3><p>这里只演示下 <code>a</code> 的用法，其它2个也是相同的语法。<code>a</code> <strong>在新的一行增加</strong>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在每行后追加一行新数据内容: append data &quot;haha&quot;</span></span><br><span class="line">$ sed <span class="string">&#x27;a\append data &quot;haha&quot;&#x27;</span> test.txt<span class="comment">#这里`\`可以用空格，个人习惯用反斜杠增加可读性</span></span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在第二行后新开一行追加数据: append data &quot;haha&quot;</span></span><br><span class="line">$  sed <span class="string">&#x27;2a\append data &quot;haha&quot;&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#在第二到四行每行后新开一行追加数据: append data &quot;haha&quot;</span></span><br><span class="line">$  sed <span class="string">&#x27;2,4a\append data &quot;haha&quot;&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#匹配字符串追加: 找到包含&quot;3 the&quot;的行，在其后新开一行追加内容: append data &quot;haha&quot;</span></span><br><span class="line">$  sed <span class="string">&#x27;/3 the/a\append data &quot;haha&quot;&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">append data <span class="string">&quot;haha&quot;</span></span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br></pre></td></tr></table></figure><h3 id="📌替换-s">📌替换  <code>s</code></h3><blockquote><table><thead><tr><th>flags</th><th>说明</th><th>指令示例</th><th>解释</th></tr></thead><tbody><tr><td>数字</td><td>表示新文本替换的模式</td><td>s###3</td><td>表示每行的第3个</td></tr><tr><td>g</td><td>表示用新文本替换现有文本的全部实例</td><td></td><td></td></tr><tr><td>p</td><td>表示打印原始的内容</td><td></td><td></td></tr><tr><td>w filename</td><td>将替换的结果写入文件</td><td></td><td></td></tr></tbody></table></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果一行中有多个符合的字符串，如果没有标志位定义，那么只会替换第一个字符串，其他的就被忽略掉了，为了能精确替换，可以使用数字位做定义。</span></span><br><span class="line"><span class="comment">#替换一行中的第二处dog为cat</span></span><br><span class="line">$ sed <span class="string">&#x27;s/dog/cat/2&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . <span class="built_in">cat</span></span><br><span class="line">2 the quick brown fox jumps over the lazy dog . <span class="built_in">cat</span></span><br><span class="line">3 the quick brown fox jumps over the lazy dog . <span class="built_in">cat</span></span><br><span class="line">4 the quick brown fox jumps over the lazy dog . <span class="built_in">cat</span></span><br><span class="line">5 the quick brown fox jumps over the lazy dog . <span class="built_in">cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#g标志:将一行中的所有符合的字符串全部执行替换</span></span><br><span class="line"><span class="comment">#将data1文件中的所有dog替换为cat</span></span><br><span class="line">$ sed <span class="string">&#x27;s/dog/cat/g&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . <span class="built_in">cat</span></span><br><span class="line">2 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . <span class="built_in">cat</span></span><br><span class="line">3 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . <span class="built_in">cat</span></span><br><span class="line">4 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . <span class="built_in">cat</span></span><br><span class="line">5 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . <span class="built_in">cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p标志：打印文本内容，类似于-p命令选项</span></span><br><span class="line">$ sed  <span class="string">&#x27;3s/dog/cat/p&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#w filename标志:将修改的内容存入filename文件中</span></span><br><span class="line">$ sed  <span class="string">&#x27;3s/dog/cat/w text&#x27;</span> test.txt</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy <span class="built_in">cat</span> . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br></pre></td></tr></table></figure><h3 id="⭐其它用法">⭐其它用法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#$=统计test.txt有多少行</span></span><br><span class="line">$ sed -n <span class="string">&#x27;$=&#x27;</span> test.txt</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印test.txt内容时加上行号</span></span><br><span class="line">$ sed  <span class="string">&#x27;=&#x27;</span> test.txt</span><br><span class="line">1</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出包含the的所在行的行号（= 用来输出行号）</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/the/=&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出以PI开头的行</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/^PI/p&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出以数字结尾的行</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/[0-9]$/p&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#输出包含单词wood的行 \&lt; ,\&gt;表示单词边界</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/\&lt;wood\&gt;/p&#x27;</span> test.txt </span><br><span class="line">a wood cross!</span><br><span class="line"></span><br><span class="line"><span class="comment">#每行开始添加#字符</span></span><br><span class="line">$ sed <span class="string">&#x27;s/^/#/&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#在包含the的每行行首添加#字符</span></span><br><span class="line">$ sed <span class="string">&#x27;/the/s/^/#/&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#在每行末尾添加EOF字符</span></span><br><span class="line">$ sed <span class="string">&#x27;s/$/EOF/&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#将3-5行所有的the替换为THE  </span></span><br><span class="line">$ sed <span class="string">&#x27;3,5s/the/THE/g&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#将包含the的行中的o替换为O</span></span><br><span class="line">$ sed <span class="string">&#x27;/the/s/o/O/g&#x27;</span> test.txt </span><br></pre></td></tr></table></figure><h3 id="⭐迁移符合条件的文本">⭐迁移符合条件的文本</h3><blockquote><p>H 复制到剪贴板；</p><p>g，G 将剪贴板中的数据覆盖/追加到指定行；</p><p>w保存为文件；</p><p>r读取指定文件；</p><p>a 追加指定内容。</p><p>l, i:忽略大小写</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将包含1的行迁移到行尾（H复制到剪贴板---d删除---$G追加到行尾---&quot;；&quot;用于多个操作)</span></span><br><span class="line">$ sed <span class="string">&#x27;/1/&#123;H;d&#125;;$G&#x27;</span> test.txt | sed <span class="string">&#x27;/^$/d&#x27;</span></span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#将1-3行迁移到5行后</span></span><br><span class="line">$ sed <span class="string">&#x27;1,3&#123;H;d&#125;;5G&#x27;</span> test.txt</span><br><span class="line">4 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">5 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line">1 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">2 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line">3 the quick brown fox jumps over the lazy dog . dog</span><br><span class="line"></span><br><span class="line"><span class="comment">#在包含the每行后添加文件hostname内容</span></span><br><span class="line">$ sed <span class="string">&#x27;/the/r /etc/hostname&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#在第3行后插入新行，内容为New</span></span><br><span class="line">$ sed <span class="string">&#x27;3aNew&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#在包含the的每行后插入新行</span></span><br><span class="line">$ sed <span class="string">&#x27;/the/aNew&#x27;</span> test.txt </span><br><span class="line"></span><br><span class="line"><span class="comment">#在第3行后插入多行（\n 换行符）</span></span><br><span class="line">$ sed <span class="string">&#x27;3aNew1\nNew2&#x27;</span> test.txt </span><br></pre></td></tr></table></figure><h3 id="⭐-后向引用，反向引用（括号先保护在使用）">⭐ <strong>后向引用</strong>，<strong>反向引用</strong>（括号先保护在使用）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 123456 | sed -r <span class="string">&#x27;s#(.*)#&lt;/1&gt;#g&#x27;</span></span><br><span class="line">&lt;123456&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="4）awk">4）awk</h1><h2 id="4-1-简介">4.1 简介</h2><p>awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p><h2 id="4-2-执行过程">4.2 执行过程</h2><p><span style="color:blue;">找谁{干啥}，条件{动作}，pattern{action}</span></p><h2 id="4-3-语法">4.3 语法</h2><p>📌<strong>语法</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;pattern&#123;action&#125;&#x27;</span> &#123;filenames&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4基础用法">4.4基础用法</h2><ul><li><p><strong>行row</strong>：在awk中叫记录（record）。每一行默认通过回车分割。</p></li><li><p><strong>列column</strong>：在awk中叫字段，域（field）。每一列默认通过空格分割。</p></li></ul><h3 id="📌取行">📌<strong>取行</strong></h3><table><thead><tr><th>内置变量</th><th>说明</th></tr></thead><tbody><tr><td>NR==1</td><td>取出第一行</td></tr><tr><td>NR&gt;=1 &amp;&amp; NR&lt;=5</td><td>取出第一行至第五行</td></tr><tr><td>/正则/</td><td>取出匹配条件的行</td></tr><tr><td>//，//</td><td>取出多条匹配条件，并逐行显示</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">&#x27;NR==1&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure><h3 id="📌取列">📌<strong>取列</strong></h3><table><thead><tr><th>内置变量</th><th>说明</th><th></th></tr></thead><tbody><tr><td>-F :</td><td>同<code>-v FS=:</code>读取时指定每一列的分隔符为<code>：</code>（默认空格，连续空格，tab）</td><td></td></tr><tr><td>$数字</td><td>取出某一列,awk中$只表示取列</td><td></td></tr><tr><td>$0</td><td>整行内容</td><td></td></tr><tr><td>$NF</td><td>取出最后一列</td><td></td></tr><tr><td>-vOFS=:</td><td>写入时格式化输出分隔符为<code>:</code></td><td></td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将末尾列和第一列对调</span></span><br><span class="line">$ awk -F: <span class="string">&#x27;NR==1 &#123;print $NF,$2,$3,$4,$5,$6,$1&#125;&#x27;</span> /etc/passwd</span><br><span class="line">/bin/bash x 0 0 root /root root</span><br></pre></td></tr></table></figure><h2 id="4-5-条件匹配">4.5 条件匹配</h2><table><caption>表 1 awk支持的主要条件类型</caption><tbody><tr><th>条件类型</th><th>条&nbsp;件</th><th>说&nbsp;明</th></tr><tr><td>awk保留字</td><td>BEGIN</td><td>在 awk 程序一开始，尚未读取任何数据之前执行。BEGIN 后的动作只在程序开始时执行一次</td></tr><tr><td>awk保留字</td><td>END</td><td>在 awk 程序处理完所有数据，即将结束时执行?END 后的动作只在程序结束时执行一次</td></tr><tr><td rowspan="8">关系运算符</td><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>==</td><td>等于。用于判断两个值是否相等。如果是给变童赋值，则使用"=”</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>A~B</td><td>判断字符串 A 中是否包含能匹配 B 表达式的子字符串</td></tr><tr><td>A!~B</td><td>判断字符串 A 中是否不包含能匹配 B 表达式的子字符串</td></tr><tr><td>正则表达式</td><td>/正则/</td><td>如果在“//”中可以写入字符，则也可以支持正则表达式</td></tr></tbody></table><h3 id="📌BEGIN">📌BEGIN</h3><p>BEGIN 是 awk 的保留字，是一种特殊的条件类型。BEGIN 的执行时机是&quot;在 awk 程序一开始，尚未读取任何数据之前&quot;。一旦 BEGIN 后的动作执行一次，当 awk 开始从文件中读入数据时，BEGIN 的条件就不再成立。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;BEGIN&#123;printf &quot;This is a transcript\n&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27;</span> student.txt</span><br><span class="line"><span class="comment">#awk命令只要检测不到完整的单引号就不会执行，所以这条命令的换行不用加入&quot;\&quot;，就是一行命令</span></span><br><span class="line"><span class="comment">#这里定义了两个动作</span></span><br><span class="line"><span class="comment">#第一个动作使用BEGIN条件，所以会在读入文件数据前打印&quot;这是一张成绩单&quot;（只会执行一次）</span></span><br><span class="line"><span class="comment">#第二个动作会打印文件的第二个字段和第六个字段</span></span><br><span class="line">This is a transcript</span><br><span class="line">Name Average</span><br><span class="line">Liming 87.66</span><br><span class="line">Sc 85.66</span><br><span class="line">Gao 91.66</span><br></pre></td></tr></table></figure><h3 id="📌END">📌END</h3><p>END 也是 awk 的保留字，不过刚好和 BEGIN 相反。END 是在 awk 程序处理完所有数据，即将结束时执行的。END 后的动作只在程序结束时执行一次。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;END&#123;printf &quot;The End&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27;</span> student.txt</span><br><span class="line"><span class="comment">#输出结尾输入&quot;The End&quot;，这并不是文档本身的内容，而且只会执行一次</span></span><br><span class="line">Name Average</span><br><span class="line">Liming 87.66</span><br><span class="line">Sc 85.66</span><br><span class="line">Gao 91.66</span><br><span class="line">The End</span><br></pre></td></tr></table></figure><h3 id="📌关系运算符">📌关系运算符</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> student.txt | grep -v Name |awk<span class="string">&#x27;$6 &gt;= 87 &#123;printf $2&#x27;</span>\n<span class="string">&quot;&#125;&#x27;</span></span><br><span class="line"><span class="string">#使用cat输出文件内容，用grep取反包含&quot;</span>Name<span class="string">&quot;的行</span></span><br><span class="line"><span class="string">#判断第六个字段（平均成绩）大于等于87分的行，如果判断式成立，则打印第六列（学员名）</span></span><br><span class="line"><span class="string">Liming</span></span><br><span class="line"><span class="string">Gao</span></span><br></pre></td></tr></table></figure><h3 id="📌正则表达式">📌正则表达式</h3><p>如果想让 awk 识别字符串，则必须使用&quot;//&quot;包含</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;/Liming/ &#123;print&#125;&#x27;</span> student.txt</span><br><span class="line"><span class="comment">#打印Liming的成绩</span></span><br><span class="line">1 Liming 82 95 86 87.66</span><br></pre></td></tr></table></figure><p>当使用 df 命令査看分区的使用情况时，如果我只想査看真正的系统分区的使用情况，而不想査看光盘和临时分区的使用情况，则可以这样做</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -h | awk <span class="string">&#x27;/sda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment">#查询包含&quot;sda数字&quot;的行，并打印第一个字段和第五个字段</span></span><br><span class="line">/dev/sda2       12%</span><br><span class="line">/dev/sda1       42%</span><br></pre></td></tr></table></figure><h2 id="4-6数组">4.6数组</h2><p>📌建立数组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[index] = value <span class="comment">#数组名array，下标index以及相应的值value。</span></span><br></pre></td></tr></table></figure><p>📌读取数组值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">for</span> (item <span class="keyword">in</span> array)  <span class="built_in">print</span> array[item]&#125; <span class="comment"># 输出的顺序是随机的</span></span><br><span class="line">&#123;<span class="keyword">for</span>(i=1;i&lt;=len;i++)  <span class="built_in">print</span> array[i]&#125; <span class="comment"># Len 是数组的长度</span></span><br></pre></td></tr></table></figure><p>4.7 循环</p><p>4.8 判断</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;1）三剑客的特点及应用场景&quot;&gt;1）三剑客的特点及应用场景&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;场景</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OpenWRT旁路由环境下使用Cloudflare动态DNS（DDNS）服务</title>
    <link href="https://blog.halfsummer.xyz/posts/80ad88a9.html"/>
    <id>https://blog.halfsummer.xyz/posts/80ad88a9.html</id>
    <published>2023-03-03T10:54:15.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>服务 -&gt; 动态dns -&gt; ipv4修改</strong>：（没有则自己新建）</p><p><img src="https://images.halfsummer.xyz/i/pictures/niubb/2023/20230303-640161d865334.png" alt="image-20230303105616266"></p><p><strong>基本设置</strong>：</p><ul><li>域名处要注意使用<code>@</code>符分割。</li><li>用户名使用登入邮箱</li><li>密码要使用全局秘钥</li></ul><p><img src="https://images.halfsummer.xyz/i/pictures/niubb/2023/20230303-6401631b56a31.png" alt="image-20230303110146012"></p><p><strong>高级设置</strong>：</p><p>旁路由模式需要修改为url。</p><p><img src="https://images.halfsummer.xyz/i/pictures/niubb/2023/20230303-640163c646e3e.png" alt="image-20230303110436747"></p><p><strong>保存修改即可</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;p&gt;&lt;strong&gt;服务 -&amp;gt; 动态dns -&amp;gt; ipv4修改&lt;/strong&gt;：（没有则自己新建）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.hal</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/7cb564cd.html"/>
    <id>https://blog.halfsummer.xyz/posts/7cb564cd.html</id>
    <published>2023-03-03T10:16:10.000Z</published>
    <updated>2023-03-13T17:11:01.902Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Regular-Expression（正则表达式）">Regular Expression（正则表达式）</h1><p><a href="https://jex.im/regulex/#!flags=&amp;re=%5E(a%7Cb)*%3F%24">可视化工具</a></p><h2 id="一、基础正则表达式">一、基础正则表达式</h2><h3 id="1-字符">1.字符</h3><table>  <tbody>    <tr>      <td><strong>表达式</strong></td>      <td><strong>描述</strong></td>    </tr>    <tr>      <td><code>[abc]</code></td>      <td>字符集。匹配集合中所含的任一字符。</td>    </tr>    <tr>      <td><code>[^abc]</code></td>      <td>否定字符集。匹配任何不在集合中的字符。</td>    </tr>    <tr>      <td><code>[a-z]</code></td>      <td>字符范围。匹配指定范围内的任意字符。</td>    </tr>    <tr>      <td><code>.</code></td>      <td>匹配除换行符以外的任何单个字符。</td>    </tr>    <tr>      <td><code>\</code></td>      <td>转义字符。</td>    </tr>    <tr>      <td><code>\w</code></td>      <td>匹配任何字母、数字，包括下划线（等价于<code>[A-Za-z0-9_]</code>）。</td>    </tr>    <tr>      <td><code>\W</code></td>      <td>匹配任何非字母、数字（等价于<code>[^A-Za-z0-9_]</code>）。</td>    </tr>    <tr>      <td><code>\d</code></td>      <td>数字。匹配任何数字。</td>    </tr>    <tr>      <td><code>\D</code></td>      <td>非数字。匹配任何非数字字符。</td>    </tr>    <tr>      <td><code>\s</code></td>      <td>空白。匹配任何空白字符，包括空格、制表符等。</td>    </tr>    <tr>      <td><code>\S</code></td>      <td>非空白。匹配任何非空白字符。</td>    </tr>  </tbody></table><h3 id="2-分组和引用">2.分组和引用</h3><table>  <tbody>    <tr>      <td><strong>表达式</strong></td>      <td><strong>描述</strong></td>    </tr>    <tr>      <td><code>(expression)</code></td>      <td>分组。匹配括号里的整个表达式。</td>    </tr>    <tr>      <td><code>(?:expression)</code></td>      <td>        非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。      </td>    </tr>    <tr>      <td><code>\num</code></td>      <td>        对前面所匹配分组的引用。比如<code>(\d)\1</code>可以匹配两个相同的数字，<code>(Code)(Sheep)\1\2</code>则可以匹配<code>CodeSheepCodeSheep</code>。      </td>    </tr>  </tbody></table><h3 id="3-锚点-边界">3.锚点/边界</h3><table>  <tbody>    <tr>      <td><strong>表达式</strong></td>      <td><strong>描述</strong></td>    </tr>    <tr>      <td><code>^</code></td>      <td>匹配字符串或行开头。</td>    </tr>    <tr>      <td><code>$</code></td>      <td>匹配字符串或行结尾。</td>    </tr>    <tr>      <td><code>\b</code></td>      <td>        匹配单词边界。比如<code>Sheep\b</code>可以匹配<code>CodeSheep</code>末尾的<code>Sheep</code>，不能匹配<code>CodeSheepCode</code>中的<code          >Sheep</code        >      </td>    </tr>    <tr>      <td><code>\B</code></td>      <td>        匹配非单词边界。比如<code>Code\B</code>可以匹配<code>HelloCodeSheep</code>中的<code>Code</code>，不能匹配<code>HelloCode</code>中的<code>Code</code>。      </td>    </tr>  </tbody></table><h3 id="4-数量表示">4.数量表示</h3><table>  <tbody>    <tr>      <td><strong>表达式</strong></td>      <td><strong>描述</strong></td>    </tr>    <tr>      <td><code>?</code></td>      <td>匹配前面的表达式0个或1个。即表示可选项。</td>    </tr>    <tr>      <td><code>+</code></td>      <td>匹配前面的表达式至少1个。</td>    </tr>    <tr>      <td><code>*</code></td>      <td>匹配前面的表达式0个或多个。</td>    </tr>    <tr>      <td><code>|</code></td>      <td>或运算符。并集，可以匹配符号前后的表达式。</td>    </tr>    <tr>      <td><code>&#123;m&#125;</code></td>      <td>匹配前面的表达式m个。</td>    </tr>    <tr>      <td><code>&#123;m,&#125;</code></td>      <td>匹配前面的表达式最少m个。</td>    </tr>    <tr>      <td><code>&#123;m,n&#125;</code></td>      <td>匹配前面的表达式最少m个，最多n个。</td>    </tr>  </tbody></table><h3 id="5-预查断言">5.预查断言</h3><table>  <tbody>    <tr>      <td><strong>表达式</strong></td>      <td><strong>描述</strong></td>    </tr>    <tr>      <td><code>(?=)</code></td>      <td>        正向预查。比如<code>Code(?=Sheep)</code>能匹配<code>CodeSheep</code>中的<code>Code</code>，但不能匹配<code>CodePig</code>中的<code>Code</code>。      </td>    </tr>    <tr>      <td><code>(?!)</code></td>      <td>        正向否定预查。比如<code>Code(?!Sheep)</code>不能匹配<code>CodeSheep</code>中的<code>Code</code>，但能匹配<code>CodePig</code>中的<code>Code</code>。      </td>    </tr>    <tr>      <td><code>(?&lt;=)</code></td>      <td>        反向预查。比如<code>(?&lt;=Code)Sheep</code>能匹配<code>CodeSheep</code>中的<code>Sheep</code>，但不能匹配<code>ReadSheep</code>中的<code>Sheep</code>。      </td>    </tr>    <tr>      <td><code>(?&lt;!)</code></td>      <td>        反向否定预查。比如<code>(?&lt;!Code)Sheep</code>不能匹配<code>CodeSheep</code>中的<code>Sheep</code>，但能匹配<code>ReadSheep</code>中的<code>Sheep</code>。      </td>    </tr>  </tbody></table><h3 id="6-特殊标志">6.特殊标志</h3><table>  <tbody>    <tr>      <td><strong>表达式</strong></td>      <td><strong>描述</strong></td>    </tr>    <tr>      <td><code>/.../i</code></td>      <td>忽略大小写。</td>    </tr>    <tr>      <td><code>/.../g</code></td>      <td>全局匹配。</td>    </tr>    <tr>      <td><code>/.../m</code></td>      <td>多行修饰符。用于多行匹配。</td>    </tr>  </tbody></table><h2 id="二、常用正则表达式">二、常用正则表达式</h2><h3 id="1-数字效验">1.数字效验</h3><table>  <tbody>    <tr>      <td><strong>描述</strong></td>      <td><strong>正则表达式</strong></td>      <td><strong>备注</strong></td>    </tr>    <tr>      <td>数字</td>      <td><code>^[0-9]*$</code></td>      <td></td>    </tr>    <tr>      <td>n位数字</td>      <td><code>^\d&#123;n&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>至少n位数字</td>      <td><code>^\d&#123;n,&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>m~n位数字</td>      <td><code>^\d&#123;m,n&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>整数</td>      <td><code>^(-?[1-9]\d*)$</code></td>      <td>非0开头，包括正整数和负整数</td>    </tr>    <tr>      <td>正整数</td>      <td><code>^[1-9]\d*$</code></td>      <td></td>    </tr>    <tr>      <td>负整数</td>      <td><code>^-[1-9]\d*$</code></td>      <td></td>    </tr>    <tr>      <td>非负整数</td>      <td><code>^(([1-9]\d*)|0)$</code></td>      <td></td>    </tr>    <tr>      <td>非正整数</td>      <td><code>^((-[1-9]\d*)|0)$</code></td>      <td></td>    </tr>    <tr>      <td>浮点数</td>      <td><code>^-?(?:[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0\.0+|0)$</code></td>      <td>包括正浮点数和负浮点数</td>    </tr>    <tr>      <td>正浮点数</td>      <td><code>^(?:[1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code></td>      <td></td>    </tr>    <tr>      <td>负浮点数</td>      <td><code>^-(?:[1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code></td>      <td></td>    </tr>    <tr>      <td>非正浮点数</td>      <td><code>^(?:-(?:[1-9]\d*\.\d+|0\.\d*[1-9]\d*)|0\.0+|0)$</code></td>      <td>包含0</td>    </tr>    <tr>      <td>非负浮点数</td>      <td><code>^(?:[1-9]\d*\.\d+|0\.\d+|0\.0+|0)$</code></td>      <td>包含0</td>    </tr>    <tr>      <td>仅一位小数</td>      <td><code>^-?(?:0|[1-9][0-9]*)\.[0-9]&#123;1&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>最少一位小数</td>      <td><code>^-?(?:0|[1-9][0-9]*)\.[0-9]&#123;1,&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>最多两位小数</td>      <td><code>^-?(?:0|[1-9][0-9]*)\.[0-9]&#123;1,2&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>连续重复的数字</td>      <td><code>^(\d)\1+$</code></td>      <td>例如：<code>111</code>，<code>222</code></td>    </tr>  </tbody></table><h3 id="2-字符校验">2.字符校验</h3><table>  <tbody>    <tr>      <td><strong>描述</strong></td>      <td><strong>正则表达式</strong></td>      <td><strong>备注</strong></td>    </tr>    <tr>      <td>中文</td>      <td><code>^[\u4E00-\u9FA5]+$</code></td>      <td></td>    </tr>    <tr>      <td>全角字符</td>      <td><code>^[\uFF00-\uFFFF]+$</code></td>      <td></td>    </tr>    <tr>      <td>半角字符</td>      <td><code>^[\u0000-\u00FF]+$</code></td>      <td></td>    </tr>    <tr>      <td>英文字符串（大写）</td>      <td><code>^[A-Z]+$</code></td>      <td></td>    </tr>    <tr>      <td>英文字符串（小写）</td>      <td><code>^[a-z]+$</code></td>      <td></td>    </tr>    <tr>      <td>英文字符串（不区分大小写）</td>      <td><code>^[A-Za-z]+$</code></td>      <td></td>    </tr>    <tr>      <td>中文和数字</td>      <td><code>^(?:[\u4E00-\u9FA5]&#123;0,&#125;|\d)+$</code></td>      <td></td>    </tr>    <tr>      <td>英文和数字</td>      <td><code>^[A-Za-z0-9]+$</code></td>      <td></td>    </tr>    <tr>      <td>数字、英文字母或者下划线组成的字符串</td>      <td><code>^\w+$</code></td>      <td></td>    </tr>    <tr>      <td>中文、英文、数字包括下划线</td>      <td><code>^[\u4E00-\u9FA5\w]+$</code></td>      <td></td>    </tr>    <tr>      <td>不含字母的字符串</td>      <td><code>^[^A-Za-z]*$</code></td>      <td></td>    </tr>    <tr>      <td>连续重复的字符串</td>      <td><code>^(.)\1+$</code></td>      <td>例如：<code>aa</code>，<code>bb</code></td>    </tr>    <tr>      <td>长度为n的字符串</td>      <td><code>^.&#123;n&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>ASCII</td>      <td><code>^[ -~]$</code></td>      <td></td>    </tr>  </tbody></table><h3 id="3-日期与时间校验">3.日期与时间校验</h3><table>  <tbody>    <tr>      <td><strong>描述</strong></td>      <td><strong>正则表达式</strong></td>      <td><strong>备注</strong></td>    </tr>    <tr>      <td>日期</td>      <td>        <code>^\d&#123;1,4&#125;-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\d|30|31)$</code>      </td>      <td>弱校验，例如：<code>2022-06-12</code></td>    </tr>    <tr>      <td>日期</td>      <td>        <code          >^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code        >      </td>      <td>严格校验，考虑平闰年</td>    </tr>    <tr>      <td>时间</td>      <td><code>^(?:1[0-2]|0?[1-9]):[0-5]\d:[0-5]\d$</code></td>      <td>12小时制，例如：<code>11:21:31</code></td>    </tr>    <tr>      <td>时间</td>      <td><code>^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$</code></td>      <td>24小时制，例如：<code>23:21:31</code></td>    </tr>    <tr>      <td>日期+时间</td>      <td>        <code          >^(\d&#123;1,4&#125;-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\d|30|31))          ((?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d)$</code        >      </td>      <td>例如：<code>2000-11-11 23:20:21</code></td>    </tr>  </tbody></table><h3 id="4-日常生活相关">4.日常生活相关</h3><table>  <tbody>    <tr>      <td><strong>描述</strong></td>      <td><strong>正则表达式</strong></td>      <td><strong>备注</strong></td>    </tr>    <tr>      <td>中文名</td>      <td><code>^[\u4E00-\u9FA5·]&#123;2,16&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>英文名</td>      <td><code>^[a-zA-Z][a-zA-Z\s]&#123;0,20&#125;[a-zA-Z]$</code></td>      <td></td>    </tr>    <tr>      <td>车牌号</td>      <td>        <code          >^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z][A-HJ-NP-Z0-9]&#123;4&#125;[A-HJ-NP-Z0-9挂学警港澳]$</code        >      </td>      <td>不含新能源</td>    </tr>    <tr>      <td>车牌号</td>      <td>        <code          >^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z](?:(?:[A-HJ-NP-Z0-9]&#123;4&#125;[A-HJ-NP-Z0-9挂学警港澳])|(?:(?:\d&#123;5&#125;[A-HJK])|(?:[A-HJK][A-HJ-NP-Z0-9][0-9]&#123;4&#125;)))$</code        >      </td>      <td>包含新能源</td>    </tr>    <tr>      <td>火车车次</td>      <td><code>^[GCDZTSPKXLY1-9]\d&#123;1,4&#125;$</code></td>      <td>例如：<code>G1234</code></td>    </tr>    <tr>      <td>手机号</td>      <td><code>^(?:(?:\+|00)86)?1[3-9]\d&#123;9&#125;$</code></td>      <td>弱匹配</td>    </tr>    <tr>      <td>手机号</td>      <td>        <code          >^(?:(?:\+|00)86)?1(?:(?:3[\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\d])|(?:9[189]))\d&#123;8&#125;$</code        >      </td>      <td>严格匹配</td>    </tr>    <tr>      <td>固话号码</td>      <td><code>^(?:(?:\d&#123;3&#125;-)?\d&#123;8&#125;|^(?:\d&#123;4&#125;-)?\d&#123;7,8&#125;)(?:-\d+)?$</code></td>      <td></td>    </tr>    <tr>      <td>手机IMEI码</td>      <td><code>^\d&#123;15,17&#125;$</code></td>      <td>一般是15位</td>    </tr>    <tr>      <td>邮编</td>      <td>        <code          >^(?:0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\d&#123;4&#125;$</code        >      </td>      <td>例如：<code>211100</code></td>    </tr>    <tr>      <td>统一社会信用代码</td>      <td><code>^[0-9A-HJ-NPQRTUWXY]&#123;2&#125;\d&#123;6&#125;[0-9A-HJ-NPQRTUWXY]&#123;10&#125;$</code></td>      <td></td>    </tr>    <tr>      <td>身份证号码(1代)</td>      <td>        <code>^[1-9]\d&#123;7&#125;(?:0\d|10|11|12)(?:0[1-9]|[1-2][\d]|30|31)\d&#123;3&#125;$</code>      </td>      <td>15位数字</td>    </tr>    <tr>      <td>身份证号码(2代)</td>      <td>        <code          >^[1-9]\d&#123;5&#125;(?:18|19|20)\d&#123;2&#125;(?:0[1-9]|10|11|12)(?:0[1-9]|[1-2]\d|30|31)\d&#123;3&#125;[0-9Xx]$</code        >      </td>      <td>18位数字</td>    </tr>    <tr>      <td>QQ号</td>      <td><code>^[1-9][0-9]&#123;4,&#125;$</code></td>      <td>一般是5到10位</td>    </tr>    <tr>      <td>微信号</td>      <td><code>^[a-zA-Z][-_a-zA-Z0-9]&#123;5,19&#125;$</code></td>      <td>一般6~20位，字母开头，可包含字母、数字、-、_，不含特殊字符</td>    </tr>    <tr>      <td>股票代码</td>      <td>        <code          >^(s[hz]|S[HZ])(000[\d]&#123;3&#125;|002[\d]&#123;3&#125;|300[\d]&#123;3&#125;|600[\d]&#123;3&#125;|60[\d]&#123;4&#125;)$</code        >      </td>      <td>A股，例如：<code>600519</code></td>    </tr>    <tr>      <td>银行卡卡号</td>      <td><code>^[1-9]&#123;1&#125;(?:\d&#123;15&#125;|\d&#123;18&#125;)$</code></td>      <td>一般为19位</td>    </tr>  </tbody></table><h3 id="5-互联网相关">5.互联网相关</h3><table>  <tbody>    <tr>      <td><strong>描述</strong></td>      <td><strong>正则表达式</strong></td>      <td><strong>备注</strong></td>    </tr>    <tr>      <td>域名</td>      <td>        <code          >^[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(?:\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+$</code        >      </td>      <td>例如：<code>r2coding.com</code></td>    </tr>    <tr>      <td>网址</td>      <td>        <code          >^(?:https?:\/\/)?[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(?:\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+$</code        >      </td>      <td>例如：<code>https://www.r2coding.com/</code></td>    </tr>    <tr>      <td>带端口号的网址(或IP)</td>      <td><code>^(?:https?:\/\/)?[\w-]+(?:\.[\w-]+)+:\d&#123;1,5&#125;\/?$</code></td>      <td>例如：<code>http://127.0.0.1:8888/</code></td>    </tr>    <tr>      <td>URL</td>      <td>        <code          >^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]&#123;1,256&#125;\.[a-zA-Z0-9()]&#123;1,6&#125;\b(?:[-a-zA-Z0-9()!@:%_\+.~#?&amp;\/\/=]*)$</code        >      </td>      <td>例如：<code>https://www.r2coding.com/#/README?id=1</code></td>    </tr>    <tr>      <td>邮箱email</td>      <td>        <code          >^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(?:\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+$</code        >      </td>      <td>支持中文，例如：<code>codesheep@cs.com</code></td>    </tr>    <tr>      <td>用户名</td>      <td><code>^[a-zA-Z0-9_-]&#123;4,20&#125;$</code></td>      <td>4到20位</td>    </tr>    <tr>      <td>弱密码</td>      <td><code>^[\w]&#123;6,16&#125;$</code></td>      <td>6~16位，包含大小写字母和数字的组合</td>    </tr>    <tr>      <td>强密码</td>      <td>        <code          >^.*(?=.&#123;6,&#125;)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@\.#$%^&amp;*?          ]).*$</code        >      </td>      <td>至少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</td>    </tr>    <tr>      <td>端口号</td>      <td>        <code          >^(?:[0-9]|[1-9][0-9]&#123;1,3&#125;|[1-5][0-9]&#123;4&#125;|6[0-4][0-9]&#123;3&#125;|65[0-4][0-9]&#123;2&#125;|655[0-2][0-9]|6553[0-5])$</code        >      </td>      <td>例如：<code>65535</code></td>    </tr>    <tr>      <td>IPv4地址</td>      <td>        <code          >^(?:(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])$</code        >      </td>      <td>例如：<code>192.168.31.1</code></td>    </tr>    <tr>      <td>IPv4地址+端口</td>      <td>        <code          >^(?:(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.)&#123;3&#125;(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(?::(?:[0-9]|[1-9][0-9]&#123;1,3&#125;|[1-5][0-9]&#123;4&#125;|6[0-4][0-9]&#123;3&#125;|65[0-4][0-9]&#123;2&#125;|655[0-2][0-9]|6553[0-5]))?$</code        >      </td>      <td>例如：<code>192.168.31.1:8080</code></td>    </tr>    <tr>      <td>IPv6地址</td>      <td>        <code          >^(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))$</code        >      </td>      <td>例如：<code>CDCD:910A:2222:5498:8475:1111:3900:2020</code></td>    </tr>    <tr>      <td>IPv6地址+端口</td>      <td>        <code          >^\[(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))\](?::(?:[0-9]|[1-9][0-9]&#123;1,3&#125;|[1-5][0-9]&#123;4&#125;|6[0-4][0-9]&#123;3&#125;|65[0-4][0-9]&#123;2&#125;|655[0-2][0-9]|6553[0-5]))?$</code        >      </td>      <td>例如：<code>[CDCD:910A:2222:5498:8475:1111:3900:2020]:9800</code></td>    </tr>    <tr>      <td>子网掩码</td>      <td>        <code          >^(?:254|252|248|240|224|192|128)\.0\.0\.0|255\.(?:254|252|248|240|224|192|128|0)\.0\.0|255\.255\.(?:254|252|248|240|224|192|128|0)\.0|255\.255\.255\.(?:255|254|252|248|240|224|192|128|0)$</code        >      </td>      <td>例如：<code>255.255.255.0</code></td>    </tr>    <tr>      <td>MAC地址</td>      <td>        <code          >^(?:(?:[a-f0-9A-F]&#123;2&#125;:)&#123;5&#125;|(?:[a-f0-9A-F]&#123;2&#125;-)&#123;5&#125;)[a-f0-9A-F]&#123;2&#125;$</code        >      </td>      <td></td>    </tr>    <tr>      <td>Version版本号</td>      <td><code>^\d+(?:\.\d+)&#123;2&#125;$</code></td>      <td>例如：<code>12.1.1</code></td>    </tr>    <tr>      <td>图片后缀</td>      <td><code>\.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)+</code></td>      <td>可按需增删扩展名集合</td>    </tr>    <tr>      <td>视频后缀</td>      <td><code>\.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)+</code></td>      <td>可按需增删扩展名集合</td>    </tr>    <tr>      <td>图片链接</td>      <td>        <code          >(?:https?:\/\/)?[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(?:\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+.+\.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)</code        >      </td>      <td>可按需增删扩展名集合</td>    </tr>    <tr>      <td>视频链接</td>      <td>        <code          >(?:https?:\/\/)?[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(?:\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+.+\.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)</code        >      </td>      <td>可按需增删扩展名集合</td>    </tr>    <tr>      <td>迅雷链接</td>      <td><code>thunderx?:\/\/[a-zA-Z\d]+=</code></td>      <td></td>    </tr>    <tr>      <td>ed2k链接</td>      <td><code>ed2k:\/\/\|file\|.+\|\/</code></td>      <td></td>    </tr>    <tr>      <td>磁力链接</td>      <td><code>magnet:\?xt=urn:btih:[0-9a-fA-F]&#123;40,&#125;.*</code></td>      <td></td>    </tr>  </tbody></table><h3 id="6-其它">6.其它</h3><table>  <tbody>    <tr>      <td><strong>描述</strong></td>      <td><strong>正则表达式</strong></td>      <td><strong>备注</strong></td>    </tr>    <tr>      <td>MD5格式</td>      <td><code>^(?:[a-f\d]&#123;32&#125;|[A-F\d]&#123;32&#125;)$</code></td>      <td>32位MD5，例如：<code>7552E7071B118CBFFEC8C930455B4297</code></td>    </tr>    <tr>      <td>BASE64格式</td>      <td>        <code          >^\s*data:(?:[a-z]+\/[a-z0-9-+.]+(?:;[a-z-]+=[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&amp;',()*+;=\-._~:@/?%\s]*?)\s*$</code        >      </td>      <td>例如：<code>data:image/jpeg;base64,xxxx==</code></td>    </tr>    <tr>      <td>UUID</td>      <td><code>^[a-f\d]&#123;4&#125;(?:[a-f\d]&#123;4&#125;-)&#123;4&#125;[a-f\d]&#123;12&#125;$</code></td>      <td>例如：<code>94f9d45a-71b0-4b3c-b69d-20c4bc9c8fdd</code></td>    </tr>    <tr>      <td>16进制</td>      <td><code>^[A-Fa-f0-9]+$</code></td>      <td>例如：<code>FFFFFF</code></td>    </tr>    <tr>      <td>16进制颜色</td>      <td><code>^#?([0-9a-fA-F]&#123;3&#125;|[0-9a-fA-F]&#123;6&#125;)$</code></td>      <td>例如：<code>#FFFFFF</code></td>    </tr>    <tr>      <td>SQL语句</td>      <td><code>^(?:select|drop|delete|create|update|insert).*$</code></td>      <td></td>    </tr>    <tr>      <td>Java包名</td>      <td><code>^(?:[a-zA-Z_]\w*)+(?:[.][a-zA-Z_]\w*)+$</code></td>      <td>例如：<code>com.r2coding.controller</code></td>    </tr>    <tr>      <td>文件扩展名</td>      <td><code>\.(?:doc|pdf|txt)</code></td>      <td>可按需增删扩展名集合</td>    </tr>    <tr>      <td>Windows文件路径</td>      <td>        <code>^[a-zA-Z]:(?:\\[\w\u4E00-\u9FA5\s]+)+[.\w\u4E00-\u9FA5\s]+$</code>      </td>      <td>例如：<code>C:\Users\Administrator\Desktop\a.txt</code></td>    </tr>    <tr>      <td>Windows文件夹路径</td>      <td><code>^[a-zA-Z]:(?:\\[\w\u4E00-\u9FA5\s]+)+$</code></td>      <td>例如：<code>C:\Users\Administrator\Desktop</code></td>    </tr>    <tr>      <td>Linux文件路径</td>      <td><code>^\/(?:[^/]+\/)*[^/]+$</code></td>      <td>例如：<code>/root/library/a.txt</code></td>    </tr>    <tr>      <td>Linux文件夹路径</td>      <td><code>^\/(?:[^/]+\/)*$</code></td>      <td>例如：<code>/root/library/</code></td>    </tr>  </tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;Regular-Expression（正则表达式）&quot;&gt;Regular Expression（正则表达式）&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://jex.im/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flask 学习笔记</title>
    <link href="https://blog.halfsummer.xyz/posts/b275d48c.html"/>
    <id>https://blog.halfsummer.xyz/posts/b275d48c.html</id>
    <published>2023-03-03T00:20:44.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1）简介">1）简介</h1><p><strong>Flask是一个轻量级的基于Python的web框架</strong>。</p><p>Flask依赖三个库：</p><ul><li>Jinja2 模板引擎</li><li>Werkzeub WSGI工具集</li><li>Itsdangerous 基于Django的签名模块</li></ul><hr><h1 id="2）安装">2）安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install Flask</span><br></pre></td></tr></table></figure><p>进入python交互模式看下Flask的介绍和版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; import flask</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(flask.__doc__)</span><br><span class="line">    flask</span><br><span class="line">    ~~~~~</span><br><span class="line"> </span><br><span class="line">    A microframework based on Werkzeug.  It<span class="string">&#x27;s extensively documented</span></span><br><span class="line"><span class="string">    and follows best practice patterns.</span></span><br><span class="line"><span class="string">    :copyright: © 2010 by the Pallets team.</span></span><br><span class="line"><span class="string">    :license: BSD, see LICENSE for more details.</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(flask.__version__)</span></span><br><span class="line"><span class="string">1.0.2</span></span><br></pre></td></tr></table></figure><hr><h1 id="3）基础">3）基础</h1><h2 id="3-1-Hello-World">3.1 Hello World</h2><p>📌<strong>建立Flask项目HelloWorld</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> HelloWorld</span><br><span class="line"><span class="built_in">mkdir</span> HelloWorld/static</span><br><span class="line"><span class="built_in">mkdir</span> HelloWorld/templates</span><br><span class="line"><span class="built_in">touch</span> HelloWorld/app.py</span><br></pre></td></tr></table></figure><p><code>static</code>和<code>templates</code>目录是默认配置，其中<code>static</code>用来存放静态资源，例如图片、js、css文件等。<code>templates</code>存放html模板文件。我们的网站逻辑基本在<code>app.py</code>文件中，当然，也可以给这个文件起其他的名字。</p><p>📌<strong>在<code>app.py</code>中加入以下内容</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>📌<strong>运行<code>app.py</code></strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 app.py </span><br><span class="line"> * Running on http://127.0.0.1:5000/</span><br></pre></td></tr></table></figure><p>打开浏览器访问<code>http://127.0.0.1:5000/</code>，浏览页面上将出现<code>Hello World!</code>。终端里会显示下面的信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [16/May/2014 10:29:08] <span class="string">&quot;GET / HTTP/1.1&quot;</span> 200 -</span><br></pre></td></tr></table></figure><p>变量app是一个Flask实例，通过下面的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure><p>当客户端访问<code>/</code>时，将响应<code>hello_world()</code>函数返回的内容。注意，这不是返回<code>Hello World!</code>这么简单，<code>Hello World!</code>只是HTTP响应报文的实体部分，状态码等信息既可以由Flask自动处理，也可以通过编程来制定。</p><h2 id="3-2-修改Flask的配置">3.2 修改Flask的配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure><p>上面的代码中，python内置变量<code>__name__</code>的值是字符串<code>__main__</code> 。Flask类将这个参数作为程序名称。当然这个是可以自定义的，比如<code>app = Flask(&quot;my-app&quot;)</code>。</p><p>Flask默认使用<code>static</code>目录存放静态资源，<code>templates</code>目录存放模板，这是可以通过设置参数更改的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(<span class="string">&quot;my-app&quot;</span>, static_folder=<span class="string">&quot;path1&quot;</span>, template_folder=<span class="string">&quot;path2&quot;</span>)</span><br></pre></td></tr></table></figure><p>更多参数请参考<code>__doc__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="built_in">print</span>(Flask.__doc__)</span><br></pre></td></tr></table></figure><h2 id="3-3-调试模式">3.3 调试模式</h2><p>上面的app.py中以<code>app.run()</code>方式运行，这种方式下，如果服务器端出现错误是不会在客户端显示的。但是在开发环境中，显示错误信息是很有必要的，要显示错误信息，应该以下面的方式运行Flask：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(debug=True)</span><br></pre></td></tr></table></figure><p>将<code>debug</code>设置为<code>True</code>的另一个好处是，程序启动后，会自动检测源码是否发生变化，若有变化则自动重启程序。这可以帮我们省下很多时间。</p><h3 id="3-4-绑定IP和端口">3.4 绑定IP和端口</h3><p>默认情况下，Flask绑定IP为<code>127.0.0.1</code>，端口为<code>5000</code>。我们也可以通过下面的方式自定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>0.0.0.0</code>代表电脑所有的IP。<code>80</code>是HTTP网站服务的默认端口。什么是默认？比如，我们访问网站<code>http://www.example.com</code>，其实是访问的<code>http://www.example.com:80</code>，只不过<code>:80</code>可以省略不写。</p><p>由于绑定了80端口，需要使用root权限运行<code>app.py</code>。也就是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python3 app.py</span><br></pre></td></tr></table></figure><h1 id="4）">4）</h1><h1 id="📌request">📌request</h1><p><strong>传递参数</strong>：</p><p><a href="http://app.py">app.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 带参数的url：将参数固定到path中</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/blog/&lt;int:blog_id&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blog_detail</span>(<span class="params">blog_id</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;您访问的是第 %s 号博客&quot;</span> % blog_id</span><br><span class="line"></span><br><span class="line"><span class="comment"># /book/list：会返回第一页的数据</span></span><br><span class="line"><span class="comment"># /book/list?page=2：会返回第二页的数据</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/book/list&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">book_list</span>():</span><br><span class="line">    <span class="comment"># argument:参数</span></span><br><span class="line">    <span class="comment"># request.args：类字典类型</span></span><br><span class="line">    page = request.args.get(<span class="string">&quot;page&quot;</span>, default=<span class="number">1</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;您获取的是<span class="subst">&#123;page&#125;</span>页！&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><h1 id="📌-render-template-封装了Jinja2">📌 render_template(封装了Jinja2)</h1><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>您访问的博客是： &#123;&#123; blog_id &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://app2.py">app2.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/blog/&lt;int:blog_id&gt;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">blog_detail</span>(<span class="params">blog_id</span>):</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;blog_detail.html&quot;</span>, blog_id=blog_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;1）简介&quot;&gt;1）简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Flask是一个轻量级的基于Python的web框架&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Flask依赖三个库：&lt;/p</summary>
      
    
    
    
    <category term="python" scheme="https://blog.halfsummer.xyz/categories/python/"/>
    
    <category term="flask" scheme="https://blog.halfsummer.xyz/categories/python/flask/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 安装 Alist</title>
    <link href="https://blog.halfsummer.xyz/posts/f463bb27.html"/>
    <id>https://blog.halfsummer.xyz/posts/f463bb27.html</id>
    <published>2023-02-27T01:31:30.000Z</published>
    <updated>2023-03-13T17:11:01.894Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p><a href="https://alist.nn.ci/zh/">Alist官网</a> <a href="https://github.com/alist-org/alist">Github</a></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230227074909040.png" alt="image-20230227074909040"></p></blockquote><h1 id="1）安装">1）安装</h1><h2 id="docker-cli">docker-cli</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=<span class="string">&quot;alist&quot;</span> xhofe/alist:latest</span><br></pre></td></tr></table></figure><h2 id="docker-compose">docker-compose</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">alist:</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;/etc/alist:/opt/alist/data&#x27;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&#x27;5244:5244&#x27;</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PUID=0</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PGID=0</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">UMASK=022</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">alist</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;xhofe/alist:latest&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="aria2版本">aria2版本</h2><p>如果你想使用aria2离线下载，推荐你使用这个下面这个版本，它预装了aria2。</p><p><a href="https://hub.docker.com/r/xhofe/alist-aria2">https://hub.docker.com/r/xhofe/alist-aria2</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=<span class="string">&quot;alist&quot;</span> xhofe/alist-aria2:latest</span><br></pre></td></tr></table></figure><h1 id="2）查询密码">2）查询密码</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it alist ./alist admin</span><br></pre></td></tr></table></figure><h1 id="3）更新">3）更新</h1><h2 id="docker-cli-v2">docker-cli</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop alist</span><br><span class="line">docker <span class="built_in">rm</span> alist</span><br><span class="line">docker pull xhofe/alist:latest</span><br></pre></td></tr></table></figure><p>然后再次输入安装命令</p><h2 id="docker-compose-v2">docker-compose</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br><span class="line">docker-compose pull</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Alist 一个支持多种存储的文件列表程序，使用 Gin 和 Solidjs。</summary>
    
    
    
    <category term="Tool" scheme="https://blog.halfsummer.xyz/categories/Tool/"/>
    
    
  </entry>
  
  <entry>
    <title>Debian设置为静态网络</title>
    <link href="https://blog.halfsummer.xyz/posts/559234b6.html"/>
    <id>https://blog.halfsummer.xyz/posts/559234b6.html</id>
    <published>2023-02-26T22:06:11.000Z</published>
    <updated>2023-03-13T17:11:01.894Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1）查看网卡">1）查看网卡</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure><h1 id="2）修改配置文件">2）修改配置文件</h1><p>查看配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/network/interfaces</span><br><span class="line"><span class="built_in">cd</span> /etc/network/interfaces/interfaces.d</span><br><span class="line">sudo <span class="built_in">touch</span> eth1</span><br><span class="line">vi eth1</span><br></pre></td></tr></table></figure><p>比如我要修改eth1：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto eth1</span><br><span class="line">iface eth1 inet static</span><br><span class="line">address 10.10.10.155</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.10.10.2</span><br><span class="line">dns-nameservers 8.8.4.4 8.8.8.8</span><br></pre></td></tr></table></figure><blockquote><p>auto eth1 #开机自动连接网络<br>iface eth1 inet static #static表示使用固定ip，dhcp表述使用动态ip<br>address 10.10.10.155 #设置ip地址<br>netmask 255.255.255.0 #设置子网掩码<br>gateway 10.10.10.2 #设置网关<br>dns-nameservers 8.8.4.4 8.8.8.8</p></blockquote><h1 id="3）重启系统服务">3）重启系统服务</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart NetworkManager.service</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;1）查看网卡&quot;&gt;1）查看网卡&lt;/h1&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="OS" scheme="https://blog.halfsummer.xyz/categories/OS/"/>
    
    <category term="Debian" scheme="https://blog.halfsummer.xyz/categories/OS/Debian/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 安装 openwrt</title>
    <link href="https://blog.halfsummer.xyz/posts/39dcc97.html"/>
    <id>https://blog.halfsummer.xyz/posts/39dcc97.html</id>
    <published>2023-02-26T21:32:20.000Z</published>
    <updated>2023-03-13T17:11:01.898Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="更新日志：">更新日志：</h1><p><strong>v1.0 Docker 安装openwrt（20230226）</strong></p><h1 id="1）打开网卡混杂模式">1）打开网卡混杂模式</h1><p>查看本机的网卡信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ip a</span><br></pre></td></tr></table></figure><ul><li><p><strong>临时打开</strong></p><p>打开<code>eth0</code>混杂模式：(根据自己的网卡修改)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc on</span><br></pre></td></tr></table></figure></li><li><p><strong>永久打开</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/rc.local</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> eth0 promisc on</span><br></pre></td></tr></table></figure></li></ul><p>打开后网卡信息：</p><p><img src="https://images.halfsummer.xyz/i/pictures/niubb/2023/20230305-64042600de3c3.png" alt="0"></p><hr><h1 id="2）在docker中为openwrt设定网络">2）在docker中为openwrt设定网络</h1><p>(根据自己的网卡修改<code>parent=eth0</code>)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d macvlan --subnet=192.168.123.0/24 --gateway=192.168.123.1 -o parent=eth0 openwrt</span><br></pre></td></tr></table></figure><hr><h1 id="3）启动openwrt容器">3）启动openwrt容器</h1><p>1️⃣查看自己机器的架构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure><p>选择合适的版本：</p><p>原项目地址：<a href="https://github.com/SuLingGG/OpenWrt-Docker">https://github.com/SuLingGG/OpenWrt-Docker</a></p><table><thead><tr><th align="center">支持设备/平台</th><th align="center">DockerHub</th><th align="center">阿里云镜像仓库 (上海)</th></tr></thead><tbody><tr><td align="center">树莓派 1B</td><td align="center">sulinggg/openwrt:rpi1</td><td align="center">registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi1</td></tr><tr><td align="center">树莓派 2B</td><td align="center">sulinggg/openwrt:rpi2</td><td align="center">registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi2</td></tr><tr><td align="center">树莓派 3B / 3B+</td><td align="center">sulinggg/openwrt:rpi3</td><td align="center">registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi3</td></tr><tr><td align="center">树莓派 4B</td><td align="center">sulinggg/openwrt:rpi4</td><td align="center">registry.cn-shanghai.aliyuncs.com/suling/openwrt:rpi4</td></tr><tr><td align="center">armv7</td><td align="center">sulinggg/openwrt:armv7</td><td align="center">registry.cn-shanghai.aliyuncs.com/suling/openwrt:armv7</td></tr><tr><td align="center">arm8/aarch64</td><td align="center">sulinggg/openwrt:armv8</td><td align="center">registry.cn-shanghai.aliyuncs.com/suling/openwrt:armv8</td></tr><tr><td align="center">x86_64/amd64</td><td align="center">sulinggg/openwrt:x86_64</td><td align="center">registry.cn-shanghai.aliyuncs.com/suling/openwrt:x86_64</td></tr></tbody></table><p>2️⃣启动openwrt容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --privileged=<span class="literal">true</span> --restart=always \</span><br><span class="line">--network=openwrt \</span><br><span class="line">--name openwrt \</span><br><span class="line">-v /data/openwrt/config:/etc/config</span><br><span class="line">-d registry.cn-shanghai.aliyuncs.com/suling/openwrt:armv8 \</span><br><span class="line">/sbin/init</span><br></pre></td></tr></table></figure><p>3️⃣进入容器进行网络设置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker <span class="built_in">exec</span> -it openwrt bash</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/config/network</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230226235724060.png" alt="image-20230226235724060"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#旁路由参考设置</span></span><br><span class="line">config interface <span class="string">&#x27;lan&#x27;</span></span><br><span class="line">        option ifname <span class="string">&#x27;eth0&#x27;</span></span><br><span class="line">        option proto <span class="string">&#x27;static&#x27;</span></span><br><span class="line">        option netmask <span class="string">&#x27;255.255.255.0&#x27;</span></span><br><span class="line">        option gateway <span class="string">&#x27;192.168.123.1&#x27;</span></span><br><span class="line">        option ip6assign <span class="string">&#x27;60&#x27;</span></span><br><span class="line">        option dns <span class="string">&#x27; 8.8.8.8 114.114.114.114&#x27;</span></span><br><span class="line">        option ipaddr <span class="string">&#x27;192.168.123.254&#x27;</span></span><br><span class="line">        option broadcast <span class="string">&#x27;192.168.123.255&#x27;</span></span><br></pre></td></tr></table></figure><p>按<code>i</code>修改，<code>Esc</code> <code>:wq</code>保存后退出</p><p>4️⃣重启网络并退出容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/network restart</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><hr><h1 id="4）设置openwrt">4）设置openwrt</h1><p>使用你设置的ip在浏览器进入openwrt登入界面，默认密码为<code>password</code></p><p>首先网络配置：</p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230227001542449.png" alt="image-20230227001542449"></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230227003458427.png" alt="image-20230227003458427"></p><p><img src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230227002329803.png" alt="image-20230227002329803"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;
&lt;h1 id=&quot;更新日志：&quot;&gt;更新日志：&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;v1.0 Docker 安装openwrt（20230226）&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;1）打</summary>
      
    
    
    
    <category term="openwrt" scheme="https://blog.halfsummer.xyz/categories/openwrt/"/>
    
    
  </entry>
  
  <entry>
    <title>常用 SSH 工具介绍</title>
    <link href="https://blog.halfsummer.xyz/posts/c671c1ec.html"/>
    <id>https://blog.halfsummer.xyz/posts/c671c1ec.html</id>
    <published>2023-02-26T17:12:09.000Z</published>
    <updated>2023-03-13T17:11:01.902Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1）Putty">1）Putty</h1><p>putty是最简单的SSH工具，无需安装，支持多系统版本，下载后就可以直接使用。</p><p>推荐指数：⭐⭐<br>下载地址：<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">https://www.chiark.greenend.org.uk/~sgtatham/putty/</a></p><h1 id="2）XShell">2）XShell</h1><p>XShell 功能较为强大，且操作方便简单，它选项卡式界面，可以同时在一个窗口显示连接多个主机，还有树状直观的主机连接管理。</p><p>推荐指数：⭐⭐⭐<br>下载地址：<a href="https://xshell.en.softonic.com/">https://xshell.en.softonic.com/</a></p><h1 id="3）Mobaxterm">3）Mobaxterm</h1><p>mobaxterm工具其 主要面向的用户是网络管理人员，但也可以用来当ssh工具使用。可以说这是我目前用过的最满意的一款SSH工具，可以说是一个神器，它本身支持SSH、FTP、SFTP浏览器、Xserver等系列工具，各位老爷感兴趣的可以自己去发掘。</p><p>推荐指数：⭐⭐⭐⭐⭐<br>下载地址：<a href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net/</a></p><h1 id="4）FinalShell">4）FinalShell</h1><p>高效，是我对这款软件的第一印象。软件打开时，层次分明，软件左侧是系统信息，包含服务器的IP地址、运行时间，负载均衡、以及CPU、内存与交换的直观展示。在软件的中部是命令操作界面，深色的底蕴加上白色的文字，显得恰到好处。下方是文件管理，不需要多余的操作就能方便的管理文件，直接拖拽就能上下载文件。而且，值得一说的这是国人开发的，不需要考虑汉化的问题。</p><p>推荐指数：⭐⭐⭐⭐<br>下载地址：<a href="http://www.hostbuf.com/">http://www.hostbuf.com/</a></p><h1 id="5）SecureCRT">5）SecureCRT</h1><p>SecureCRT这也是我用的比较长时间一款SSH工具，功能和xshell差不多，总的感觉就是比上不足、比下有余。</p><p>推荐指数：⭐⭐⭐<br>下载地址：<a href="https://www.vandyke.com/">https://www.vandyke.com/</a></p><h1 id="6）Rstudio">6）Rstudio</h1><p>现在的Rstudio能都连接本地终端，如果是在服务器端，就可以登录服务器。也就是不需要任何工具，只在任何浏览器中登录Rstudio-server，就可以直接连接服务器，非常方便。它的优势不言自明，无需携带安装你熟悉的工具，只需要通过浏览器登录既可访问服务器。</p><p>推荐指数：⭐⭐<br>下载地址：<a href="https://posit.co/products/open-source/rstudio/">https://posit.co/products/open-source/rstudio/</a></p>]]></content>
    
    
    <summary type="html">SSH 是建立在应用层基础上的安全协议，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。一款好的SSH工具，可以帮助我们更好的管理远程服务资源，接下来我这边推荐几款常用的SSH工具。</summary>
    
    
    
    <category term="Tool" scheme="https://blog.halfsummer.xyz/categories/Tool/"/>
    
    
  </entry>
  
</feed>
