<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>Shell编程 学习笔记 | 艾斯牛 Blog</title><meta name="author" content="aceniu,123354319@qq.com"><meta name="copyright" content="aceniu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Shell 1.Shell 脚本 1.第一个shell脚本 打开文本编辑器，新建一个文本文件，并命名为 test.sh。扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用php好了。 在 test.sh 中输入代码： 12#!&#x2F;bin&#x2F;bashecho &quot;Hello World !&quot;  #这是一条语句  第 1"><meta property="og:type" content="article"><meta property="og:title" content="Shell编程 学习笔记"><meta property="og:url" content="https://blog.halfsummer.xyz/posts/edc1b716.html"><meta property="og:site_name" content="艾斯牛 Blog"><meta property="og:description" content="Shell 1.Shell 脚本 1.第一个shell脚本 打开文本编辑器，新建一个文本文件，并命名为 test.sh。扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用php好了。 在 test.sh 中输入代码： 12#!&#x2F;bin&#x2F;bashecho &quot;Hello World !&quot;  #这是一条语句  第 1"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cos.halfsummer.xyz/pictures/niubb/2023/20230228-63fdc7d0ce7ba.jpeg"><meta property="article:published_time" content="2023-03-13T23:14:53.000Z"><meta property="article:modified_time" content="2023-03-13T17:11:01.902Z"><meta property="article:author" content="aceniu"><meta property="article:tag" content="aceniu,blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://cos.halfsummer.xyz/pictures/niubb/2023/20230228-63fdc7d0ce7ba.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.halfsummer.xyz/posts/edc1b716.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Shell编程 学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-13 17:11:01"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="艾斯牛 Blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://cos.halfsummer.xyz/pictures/niubb/2023/20230228-63fdc7d0ce7ba.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i> <span>List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/"><i class="fa-fw fa fa-images faa-tada"></i> <span>图床</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="艾斯牛 Blog"><span class="site-name">艾斯牛 Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i> <span>List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/"><i class="fa-fw fa fa-images faa-tada"></i> <span>图床</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Shell编程 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-13T23:14:53.000Z" title="发表于 2023-03-13 23:14:53">2023-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-13T17:11:01.902Z" title="更新于 2023-03-13 17:11:01">2023-03-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Shell编程 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"><h1 id="Shell">Shell</h1><h2 id="1-Shell-脚本">1.Shell 脚本</h2><h3 id="1-第一个shell脚本">1.第一个shell脚本</h3><p>打开文本编辑器，新建一个文本文件，并命名为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>。扩展名<code>sh</code>代表 shell，扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用<code>php</code>好了。</p><p>在 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> 中输入代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span>  <span class="comment">#这是一条语句</span></span><br></pre></td></tr></table></figure><blockquote><p>第 1 行的<code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的<code>/bin/bash</code>就是指明了解释器的具体位置。</p><p>第 2 行的 echo 命令用于向标准输出文件（Standard Output，stdout，一般就是指显示器）输出文本。在<code>.sh</code>文件中使用命令与在终端直接输入命令的效果是一样的。</p><p>第 2 行的<code>#</code>及其后面的内容是注释。Shell 脚本中所有以<code>#</code>开头的都是注释（当然以<code>#!</code>开头的除外）。写脚本的时候，多写注释是非常有必要的，以方便其他人能看懂你的脚本，也方便后期自己维护时看懂自己的脚本——实际上，即便是自己写的脚本，在经过一段时间后也很容易忘记。</p></blockquote><p>下面给出了一段稍微复杂的 Shell 脚本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Copyright (c) http://nb.com/shell/</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line"><span class="built_in">read</span> PERSON</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$PERSON</span>&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>第 5 行中表示从终端读取用户输入的数据，并赋值给 PERSON 变量。read 命令用来从标准输入文件（Standard Input，stdin，一般就是指键盘）读取用户输入的数据。</p><p>第 6 行表示输出变量 PERSON 的内容。注意在变量名前边要加上<code>$</code>，否则变量名会作为字符串的一部分处理。</p></blockquote><h3 id="2-执行Shell脚本">2.执行Shell脚本</h3><p>运行 Shell 脚本有两种方法，一种在新进程中运行，一种是在当前 Shell 进程中运行。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230203110803080.png" alt="image-20230203110803080"></p><ul><li><p><strong>在新进程中运行 Shell 脚本</strong></p><p>在新进程中运行 Shell 脚本有多种方法：</p><ol><li><p>将 Shell 脚本作为程序运行</p><p>Shell 脚本也是一种解释执行的程序，可以在终端直接调用（需要使用 chmod 命令给 Shell 脚本加上执行权限）如下所示:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo                <span class="comment">#切换到 test.sh 所在的目录</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">chmod</span> +x ./test.sh  <span class="comment">#给脚本添加执行权限</span></span><br><span class="line">[root@localhost demo]$ . ./test.sh           <span class="comment">#执行脚本文件</span></span><br><span class="line">Hello World !                                  <span class="comment">#运行结果</span></span><br></pre></td></tr></table></figure><blockquote><p>第 2 行中，<code>chmod +x</code>表示给 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> 增加执行权限。</p><p>第 3 行中，<code>./</code>表示当前目录，整条命令的意思是执行当前目录下的 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> 脚本。如果不写<code>./</code>，Linux 会到系统路径（由 PATH 环境变量指定）下查找 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，而系统路径下显然不存在这个脚本，所以会执行失败。</p></blockquote><p>通过这种方式运行脚本，脚本文件第一行的<code>#!/bin/bash</code>一定要写对，好让系统查找到正确的解释器。</p></li><li><p>将 Shell 脚本作为参数传递给 Bash 解释器</p><p>你也可以直接运行 Bash 解释器，将脚本文件的名字作为参数传递给 Bash，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo               <span class="comment">#切换到 test.sh 所在的目录</span></span><br><span class="line">[root@localhost demo]$ /bin/bash test.sh  <span class="comment">#使用Bash的绝对路径</span></span><br><span class="line">Hello World !                                 <span class="comment">#运行结果</span></span><br></pre></td></tr></table></figure><p>通过这种方式运行脚本，不需要在脚本文件的第一行指定解释器信息，写了也没用。</p><p>更加简洁的写法是运行 bash 命令。bash 是一个外部命令，Shell 会在 /bin 目录中找到对应的应用程序，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[root@localhost demo]$ bash test.sh</span><br><span class="line">Hello World !</span><br></pre></td></tr></table></figure><p>这两种写法在本质上是一样的：第一种写法给出了绝对路径，会直接运行 Bash 解释器；第二种写法通过 bash 命令找到 Bash 解释器所在的目录，然后再运行，只不过多了一个查找的过程而已。</p></li></ol><p>◇ <u>检测是否开启了新进程</u></p><p>Linux 中的每一个进程都有一个唯一的 ID，称为 PID，使用<code>$$</code>变量就可以获取当前进程的 PID。<code>$$</code>是 Shell 中的特殊变量。</p><p>首先编写如下的脚本文件，并命名为 <a target="_blank" rel="noopener" href="http://check.sh">check.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> $$  <span class="comment">#输出当前进程PID</span></span><br></pre></td></tr></table></figure><p>然后使用以上两种方式来运行 <a target="_blank" rel="noopener" href="http://check.sh">check.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">2861  <span class="comment">#当前进程的PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">chmod</span> +x ./check.sh</span><br><span class="line">[root@localhost demo]$ ./check.sh</span><br><span class="line">4597  <span class="comment">#新进程的PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">2861  <span class="comment">#当前进程的PID</span></span><br><span class="line">[root@localhost demo]$ /bin/bash check.sh</span><br><span class="line">4584  <span class="comment">#新进程的PID</span></span><br></pre></td></tr></table></figure><p>你看，进程的 PID 都不一样，当然就是两个进程了。</p></li><li><p><strong>在当前进程中运行 Shell 脚本</strong></p><p>这里需要引入一个新的命令——source 命令。source 是 Shell 内置命令的一种，它会读取脚本文件中的代码，并依次执行所有语句。你也可以理解为，source 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限。</p><p>source 命令的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> filename</span><br><span class="line"><span class="comment"># 也可以简写为：</span></span><br><span class="line">. filename</span><br></pre></td></tr></table></figure><p>两种写法的效果相同。对于第二种写法，注意点号<code>.</code>和文件名中间有一个空格。</p><p>例如，使用 source 运行上节的 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo              <span class="comment">#切换到test.sh所在的目录</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">source</span> ./test.sh  <span class="comment">#使用source</span></span><br><span class="line">Hello World !</span><br><span class="line">[root@localhost demo]$ <span class="built_in">source</span> test.sh    <span class="comment">#使用source</span></span><br><span class="line">Hello World !</span><br><span class="line">[root@localhost demo]$ . ./test.sh       <span class="comment">#使用点号</span></span><br><span class="line">Hello World !</span><br><span class="line">[root@localhost demo]$ . test.sh         <span class="comment">#使用点号</span></span><br><span class="line">Hello World !</span><br></pre></td></tr></table></figure><p>你看，使用 source 命令不用给脚本增加执行权限，并且写不写<code>./</code>都行，是不是很方便呢？</p><p>◇ <u>检测是否在当前 Shell 进程中</u></p><p>我们仍然借助<code>$$</code>变量来输出进程的 PID，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">5169  <span class="comment">#当前进程PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">source</span> ./check.sh</span><br><span class="line">5169  <span class="comment">#Shell脚本所在进程PID</span></span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> $$</span><br><span class="line">5169  <span class="comment">#当前进程PID</span></span><br><span class="line">[root@localhost demo]$ . ./check.sh</span><br><span class="line">5169  <span class="comment">#Shell脚本所在进程PID</span></span><br></pre></td></tr></table></figure><p>你看，进程的 PID 都是一样的，当然是同一个进程了。</p></li></ul><hr><h2 id="2-变量">2.变量</h2><p>变量是任何一种编程语言都必不可少的组成部分，变量用来存放各种数据。脚本语言在定义变量时通常不需要指明类型，直接赋值就可以，Shell 变量也遵循这个规则。</p><p>在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</p><p>这意味着，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。例如在C语言或者 C++ 中，变量分为整数、小数、字符串、布尔等多种类型。</p><p>当然，如果有必要，你也可以使用 <code>Shell declare</code> 关键字显式定义变量的类型，但在一般情况下没有这个需求，Shell 开发者在编写代码时自行注意值的类型即可。</p><h3 id="1-定义变量">1.定义变量</h3><p>Shell 支持以下三种定义变量的方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br><span class="line">variable=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">variable=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure><p>variable 是变量名，value 是赋给变量的值。如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来。使用单引号和使用双引号也是有区别的，稍后我们会详细说明。</p><p><font style="color:red">注意，赋值号<code>=</code>的周围不能有空格，这可能和你熟悉的大部分编程语言都不一样。</font></p><p>Shell 变量的命名规范和大部分编程语言都一样：</p><ul><li>变量名由数字、字母、下划线组成；</li><li>必须以字母或者下划线开头；</li><li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li></ul><p>变量定义举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://niu.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$url</span></span><br><span class="line">name=<span class="string">&#x27;niu&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">author=<span class="string">&quot;niu&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$author</span></span><br></pre></td></tr></table></figure><h3 id="2-使用变量">2.使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号<code>$</code>即可，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">author=<span class="string">&quot;niu&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$author</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;author&#125;</span></span><br></pre></td></tr></table></figure><p>变量名外面的花括号<code>&#123; &#125;</code>是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skill=<span class="string">&quot;Java&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am good at <span class="variable">$&#123;skill&#125;</span>Script&quot;</span></span><br></pre></td></tr></table></figure><p>如果不给 skill 变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把 $skillScript 当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p><font style="color:red">推荐给所有变量加上花括号<code>&#123;&#125;</code>，这是个良好的编程习惯。</font></p><ul><li><p>修改变量的值</p><p>已定义的变量，可以被重新赋值，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=<span class="string">&quot;http://niu.com&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url&#125;</span></span><br><span class="line">url=<span class="string">&quot;http://niu.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;url&#125;</span></span><br></pre></td></tr></table></figure><p>第二次对变量赋值时不能在变量名前加<code>$</code>，只有在使用变量时才能加<code>$</code>。</p></li><li><p>单引号和双引号的区别</p><p>前面我们还留下一个疑问，定义变量时，变量的值可以由单引号<code>' '</code>包围，也可以由双引号<code>&quot; &quot;</code>包围，它们到底有什么区别呢？不妨以下面的代码为例来说明：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://niu.net&quot;</span></span><br><span class="line">website1=<span class="string">&#x27;niubb：$&#123;url&#125;&#x27;</span></span><br><span class="line">website2=<span class="string">&quot;niubb：<span class="variable">$&#123;url&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$website1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$website2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">niubb：<span class="variable">$&#123;url&#125;</span></span><br><span class="line">niubb：niu.net</span><br></pre></td></tr></table></figure><p>以单引号<code>' '</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p><p>以双引号<code>&quot; &quot;</code>包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p><p><font style="color:red">我的建议：如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</font></p></li><li><p>将命令的结果赋值给变量</p><p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`<span class="built_in">command</span>`</span><br><span class="line">variable=$(<span class="built_in">command</span>)</span><br></pre></td></tr></table></figure><p>第一种方式把命令用反引号<code></code> （位于 Esc 键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</p><p>例如，我在 demo 目录中创建了一个名为 log.txt 的文本文件，用来记录我的日常工作。下面的代码中，使用 cat 命令将 log.txt 的内容读取出来，并赋值给一个变量，然后使用 echo 命令输出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[root@localhost demo]$ <span class="built_in">log</span>=$(<span class="built_in">cat</span> log.txt)</span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> <span class="variable">$log</span></span><br><span class="line">严长生正在编写Shell教程，教程地址：http://nb.com/shell/</span><br><span class="line">[root@localhost demo]$ <span class="built_in">log</span>=`<span class="built_in">cat</span> log.txt`</span><br><span class="line">[root@localhost demo]$ <span class="built_in">echo</span> <span class="variable">$log</span></span><br><span class="line">严长生正在编写Shell教程，教程地址：http://nb.com/shell/</span><br></pre></td></tr></table></figure></li><li><p>只读变量</p><p>使用 <strong>readonly</strong> 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>下面的例子尝试更改只读变量，结果报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">myUrl=<span class="string">&quot;http://nb.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">&quot;http://nb.com/shell/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，结果如下：</span></span><br><span class="line">bash: myUrl: This variable is <span class="built_in">read</span> only.</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-删除变量">3.删除变量</h3><p>使用 <strong>unset</strong> 命令可以删除变量。语法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure><p>变量被删除后不能再次使用；unset 命令不能删除只读变量。</p><p>举个例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">myUrl=<span class="string">&quot;http://nb.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">unset</span> myUrl</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$myUrl</span></span><br></pre></td></tr></table></figure><p>上面的脚本没有任何输出。</p><h3 id="4-变量的作用域">4.变量的作用域</h3><p>Shell 变量的作用域可以分为三种：</p><p>有的变量只能在函数内部使用，这叫做局部变量（local variable）；有的变量可以在当前 Shell 进程中使用，这叫做全局变量（global variable）；而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）。</p><ol><li><h4 id="局部变量">局部变量</h4><p>Shell 也支持自定义函数，但是 Shell 函数和 C++、Java、C# 等其他编程语言函数的一个不同点就是：在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果。请看下面的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># vim local.sh </span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"></span><br><span class="line">[root@www ~]<span class="comment"># chmod o+x local.sh </span></span><br><span class="line">[root@www ~]<span class="comment"># ./local.sh </span></span><br><span class="line">99</span><br></pre></td></tr></table></figure><p>a 是在函数内部定义的，但是在函数外部也可以得到它的值，证明它的作用域是全局的，而不是仅限于函数内部。</p><p>要想变量的作用域仅限于函数内部，可以在定义时加上local命令，此时该变量就成了局部变量。请看下面的代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">local</span> a=99</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func</span><br><span class="line"><span class="comment">#输出函数内部的变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure><p>输出结果为空，表明变量 a 在函数外部无效，是一个局部变量。</p><p>Shell 变量的这个特性和 <code>JavaScript</code> 中的变量是类似的。在 <code>JavaScript</code> 函数内部定义的变量，默认也是全局变量，只有加上<code>var</code>关键字，它才会变成局部变量。</p></li><li><h4 id="全局变量">全局变量</h4><p>所谓全局变量，就是指变量在当前的整个 Shell 进程中都有效。每个 Shell 进程都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。</p><p>想要实际演示全局变量在不同 Shell 进程中的互不相关性，可在图形界面下同时打开两个 Shell，或使用两个终端远程连接到服务器（SSH）。</p><p>首先打开一个 Shell 窗口，定义一个变量 a 并赋值为 99，然后打印，这时在同一个 Shell 窗口中是可正确打印变量 a 的值的。然后再打开一个新的 Shell 窗口，同样打印变量 a 的值，但结果却为空，如图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230203112522488.png" alt="image-20230203112522488"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230203112254433.png" alt="image-20230203112254433"></p><p>这说明全局变量 a 仅仅在定义它的第一个 Shell 进程中有效，对新的 Shell 进程没有影响。这很好理解，就像小王家和小徐家都有一部电视机（变量名相同），但是同一时刻小王家和小徐家的电视中播放的节目可以是不同的（变量值不同）。</p><p>需要强调的是，全局变量的作用范围是当前的 Shell 进程，而不是当前的 Shell 脚本文件，它们是不同的概念。打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID。在一个 Shell 进程中可以使用 source 命令执行多个 Shell 脚本文件，此时全局变量在这些脚本文件中都有效。</p><p>例如，现在有两个 Shell 脚本文件，分别是 <a target="_blank" rel="noopener" href="http://a.sh">a.sh</a> 和 <a target="_blank" rel="noopener" href="http://b.sh">b.sh</a>。<a target="_blank" rel="noopener" href="http://a.sh">a.sh</a> 的代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">b=200</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://b.sh">b.sh</a> 的代码如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$b</span></span><br></pre></td></tr></table></figure><p>打开一个 Shell 窗口，输入以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># a=99</span></span><br><span class="line">[root@localhost ~]<span class="comment"># . ./a.sh</span></span><br><span class="line">99</span><br><span class="line">[root@localhost ~]<span class="comment"># . ./b.sh</span></span><br><span class="line">200</span><br></pre></td></tr></table></figure><p>这三条命令都是在一个进程中执行的，从输出结果可以发现，在 Shell 窗口中以命令行的形式定义的变量 a，在 <a target="_blank" rel="noopener" href="http://a.sh">a.sh</a> 中有效；在 <a target="_blank" rel="noopener" href="http://a.sh">a.sh</a> 中定义的变量 b，在 <a target="_blank" rel="noopener" href="http://b.sh">b.sh</a> 中也有效，变量 b 的作用范围已经超越了 <a target="_blank" rel="noopener" href="http://a.sh">a.sh</a>。</p><p>注意，必须在当前进程中运行 Shell 脚本，不能在新进程中运行 Shell 脚本。</p></li><li><h4 id="Shell-环境变量">Shell 环境变量</h4></li></ol><p>全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用<code>export</code>命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</p><p>环境变量被创建时所处的 Shell 进程称为父进程，如果在父进程中再创建一个新的进程来执行 Shell 命令，那么这个新的进程被称作 Shell 子进程。当 Shell 子进程产生时，它会继承父进程的环境变量为自己所用，所以说环境变量可从父进程传给子进程。不难理解，环境变量还可以传递给孙进程。</p><p>注意，两个没有父子关系的 Shell 进程是不能传递环境变量的，并且环境变量只能向下传递而不能向上传递，即“传子不传父”。</p><p>创建 Shell 子进程最简单的方式是运行 bash 命令，如图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1-1Z41QJGN02.gif" alt="进入Shell子进程"></p><p>通过<code>exit</code>命令可以一层一层地退出 Shell。</p><p>下面演示一下环境变量的使用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># a=22       #定义一个全局变量</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $a    #在当前Shell中输出a，成功</span></span><br><span class="line">22</span><br><span class="line">[root@localhost ~]<span class="comment"># bash       #进入Shell子进程</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $a    #在子进程中输出a，失败</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># exit       #退出Shell子进程，返回上一级Shell</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost ~]<span class="comment"># export a   #将a导出为环境变量</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash       #重新进入Shell子进程</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo $a    #在子进程中再次输出a，成功</span></span><br><span class="line">22</span><br><span class="line">[root@localhost ~]<span class="comment"># exit       #退出Shell子进程</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@localhost ~]<span class="comment"># exit       #退出父进程，结束整个Shell会话</span></span><br></pre></td></tr></table></figure><p>可以发现，默认情况下，a 在 Shell 子进程中是无效的；使用 export 将 a 导出为环境变量后，在子进程中就可以使用了。</p><p><code>export a</code>这种形式是在定义变量 a 以后再将它导出为环境变量，如果想在定义的同时导出为环境变量，可以写作<code>export a=22</code>。</p><p>我们一直强调的是环境变量在 Shell 子进程中有效，并没有说它在所有的 Shell 进程中都有效；如果你通过终端创建了一个新的 Shell 窗口，那它就不是当前 Shell 的子进程，环境变量对这个新的 Shell 进程仍然是无效的。请看下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1-1Z41QKS3523.gif" alt="环境变量在不同的Shell窗口中无效"></p><p>第一个窗口中的环境变量 a 在第二个窗口中就无效。</p><p><strong>环境变量也是临时的</strong></p><p>通过 export 导出的环境变量只对当前 Shell 进程以及所有的子进程有效，如果最顶层的父进程被关闭了，那么环境变量也就随之消失了，其它的进程也就无法使用了，所以说环境变量也是临时的。</p><p>有读者可能会问，如果我想让一个变量在所有 Shell 进程中都有效，不管它们之间是否存在父子关系，该怎么办呢？</p><p>只有将变量写入 Shell 配置文件中才能达到这个目的！Shell 进程每次启动时都会执行配置文件中的代码做一些初始化工作，如果将变量放在配置文件中，那么每次启动进程都会定义这个变量。</p><h3 id="5-Shell特殊变量-、-、-、-、">5.Shell特殊变量 <code>$#、$*、$@、$?、$$</code></h3><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名。</td></tr><tr><td>$n（n≥1）</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数。</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。当被双引号<code>&quot; &quot;</code>包含时，$@ 与 $* 稍有不同。</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</td></tr></tbody></table><ol><li><p>给脚本文件传递参数</p><p>编写下面的代码，并保存为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Process ID: $$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;File Name: <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;First Parameter : <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Second Parameter : <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 1: <span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 2: $*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total: <span class="variable">$#</span>&quot;</span></span><br></pre></td></tr></table></figure><p>运行 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，并附带参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ . ./test.sh Shell Linux</span><br><span class="line">Process ID: 5943</span><br><span class="line">File Name: bash</span><br><span class="line">First Parameter : Shell</span><br><span class="line">Second Parameter : Linux</span><br><span class="line">All parameters 1: Shell Linux</span><br><span class="line">All parameters 2: Shell Linux</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure></li><li><p>给函数传递参数</p><p>编写下面的代码，并保存为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Language: <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;First Parameter : <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Second Parameter : <span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;All parameters 1: <span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;All parameters 2: $*&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Total: <span class="variable">$#</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func Java http://c.biancheng.net/java/</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果为：</span></span><br><span class="line">Language: Java</span><br><span class="line">URL: http://c.biancheng.net/java/</span><br><span class="line">First Parameter : Java</span><br><span class="line">Second Parameter : http://c.biancheng.net/java/</span><br><span class="line">All parameters 1: Java http://c.biancheng.net/java/</span><br><span class="line">All parameters 2: Java http://c.biancheng.net/java/</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><code>$*</code>和<code>$@</code>之间的区别</p><p><code>$*</code>和<code>$@</code>都表示传递给参数或者脚本全部参数。当<code>$*</code>和<code>$@</code>不加双引号时，两者没有任何区别，都表示将接收到的每一个参数当做每一份数据，每个参数之间用空格来分开。</p><p>当<code>$*</code>和<code>$@</code>加上双引号，则两者就存在一下区别：</p><p>​ <code>&quot;$*&quot;</code> 表示将传入的多个参数从整体上当做一份数据，以<code>&quot;$1 $2 … $n&quot;</code>的形式输出所有参数。</p><p>​ <code>&quot;$@&quot;</code> 表示仍然将传入的多个参数当做多份数据，空格区分，彼此之间独立，以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n</code>&quot; 的形式输出所有参数。</p><p>编写下面的代码，并保存为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;print each param from \&quot;\$*\&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;print each param from \&quot;\$@\&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$var</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>运行 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，并附带参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ . ./test.sh a b c d</span><br><span class="line"><span class="built_in">print</span> each param from <span class="string">&quot;$*&quot;</span></span><br><span class="line">a b c d</span><br><span class="line"><span class="built_in">print</span> each param from <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>从运行结果可以发现，对于<code>&quot;$*&quot;</code>，只循环了 1 次，因为它只有 1 分数据；对于<code>&quot;$@&quot;</code>，循环了 5 次，因为它有 5 份数据。</p></li><li><p><code>$?</code></p><p><code>$?</code> 是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。</p><p>所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1，这和C语言的 main() 函数是类似的。</p><p>不过，也有一些命令返回其他值，表示不同类型的错误。</p><ol><li><p><code>$?</code> 获取上一个命令的退出状态</p><p>编写下面的代码，并保存为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">exit</span> 0  <span class="comment">#参数正确，退出状态为0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">exit</span> 1  <span class="comment">#参数错误，退出状态1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>exit</code>表示退出当前 Shell 进程，我们必须在新进程中运行 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法取得它的退出状态了。</p><p>例如，运行 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> 时传递参数 100：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ <span class="built_in">cd</span> demo</span><br><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 100  <span class="comment">#作为一个新进程运行</span></span><br><span class="line">[mozhiyan@localhost demo]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>再如，运行 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a> 时传递参数 89：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 89  <span class="comment">#作为一个新进程运行</span></span><br><span class="line">[mozhiyan@localhost demo]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure></li><li><p><code>$?</code> 获取函数的返回值</p><p>编写下面的代码，并保存为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#得到两个数相加的和</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> `<span class="built_in">expr</span> <span class="variable">$1</span> + <span class="variable">$2</span>`</span><br><span class="line">&#125;</span><br><span class="line">add 23 50  <span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment">#获取函数返回值</span></span><br></pre></td></tr></table></figure><p>运行结果：<br>73</p><p>有 C++、C#、Java 等编程经验的读者请注意：严格来说，Shell 函数中的 return 关键字用来表示函数的退出状态，而不是函数的返回值；Shell 不像其它编程语言，没有专门处理返回值的关键字。</p><p>以上处理方案在其它编程语言中没有任何问题，但是在 Shell 中是非常错误的，Shell 函数的返回值和其它编程语言大有不同，</p></li></ol></li></ul><hr><h2 id="3-命令">3.命令</h2><h3 id="1-命令替换">1.命令替换</h3><p>Shell 命令替换是指将命令的输出结果赋值给某个变量。比如，在某个目录中输入 ls 命令可查看当前目录中所有的文件，但如何将输出内容存入某个变量中呢？这就需要使用命令替换了，这也是 Shell 编程中使用非常频繁的功能。</p><p>Shell 中有两种方式可以完成命令替换，一种是反引号<code></code> ，一种是<code>$()</code>，使用方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`commands`</span><br><span class="line">variable=$(commands)</span><br></pre></td></tr></table></figure><p>其中，variable 是变量名，commands 是要执行的命令。commands 可以只有一个命令，也可以有多个命令，多个命令之间以分号<code>;</code>分隔。</p><p>例如，date 命令用来获得当前的系统时间，使用命令替换可以将它的结果赋值给一个变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">begin_time=`<span class="built_in">date</span>`    <span class="comment">#开始时间，使用``替换</span></span><br><span class="line"><span class="built_in">sleep</span> 20s            <span class="comment">#休眠20秒</span></span><br><span class="line">finish_time=$(<span class="built_in">date</span>)  <span class="comment">#结束时间，使用$()替换</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Begin time: <span class="variable">$begin_time</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Finish time: <span class="variable">$finish_time</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，20 秒后可以看到输出结果：</span></span><br><span class="line">Begin time: 2019年 04月 19日 星期五 09:59:58 CST</span><br><span class="line">Finish time: 2019年 04月 19日 星期五 10:00:18 CST</span><br></pre></td></tr></table></figure><p>使用 data 命令的<code>%s</code>格式控制符可以得到当前的 UNIX 时间戳，这样就可以直接计算脚本的运行时间了。UNIX 时间戳是指从 1970 年 1 月 1 日 00:00:00 到目前为止的秒数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">begin_time=`<span class="built_in">date</span> +%s`    <span class="comment">#开始时间，使用``替换</span></span><br><span class="line"><span class="built_in">sleep</span> 20s                <span class="comment">#休眠20秒</span></span><br><span class="line">finish_time=$(<span class="built_in">date</span> +%s)  <span class="comment">#结束时间，使用$()替换</span></span><br><span class="line">run_time=$((finish_time - begin_time))  <span class="comment">#时间差</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;begin time: <span class="variable">$begin_time</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;finish time: <span class="variable">$finish_time</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run time: <span class="variable">$&#123;run_time&#125;</span>s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，20 秒后可以看到输出结果：</span></span><br><span class="line">begin time: 1555639864</span><br><span class="line">finish time: 1555639884</span><br><span class="line">run time: 20s</span><br></pre></td></tr></table></figure><p>第 6 行代码中的<code>(( ))</code>是 Shell 数学计算命令。和 <a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a>、<a target="_blank" rel="noopener" href="http://c.biancheng.net/csharp/">C#</a>、<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 等编程语言不同，在 Shell 中进行数据计算不那么方便，必须使用专门的数学计算命令，<code>(( ))</code>就是其中之一。</p><p>注意，如果被替换的命令的输出内容包括多行（也即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个。请看下面的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">LSL=`<span class="built_in">ls</span> -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LSL</span>  <span class="comment">#不使用双引号包围</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--------------------------&quot;</span>  <span class="comment">#输出分隔符</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$LSL</span>&quot;</span>  <span class="comment">#使用引号包围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果:</span></span><br><span class="line">total 8 drwxr-xr-x. 2 root root 21 7月 1 2016 abc -rw-rw-r--. 1 root root 147 10月 31 10:29 demo.sh -rw-rw-r--. 1 root root 35 10月 31 10:20 demo.sh~</span><br><span class="line">--------------------------</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x. 2 root     root      21 7月   1 2016 abc</span><br><span class="line">-rw-rw-r--. 1 root root 147 10月 31 10:29 demo.sh</span><br><span class="line">-rw-rw-r--. 1 root root  35 10月 31 10:20 demo.sh~</span><br></pre></td></tr></table></figure><p>所以，为了防止出现格式混乱的情况，我建议在输出变量时加上双引号。</p><p><strong>再谈反引号和 $()</strong></p><p>原则上讲，上面提到的两种变量替换的形式是等价的，可以随意使用；但是，反引号毕竟看起来像单引号，有时候会对查看代码造成困扰，而使用 $() 就相对清晰，能有效避免这种混乱。而且有些情况必须使用 $()：$() 支持嵌套，反引号不行。</p><p>下面的例子演示了使用计算 ls 命令列出的第一个文件的行数，这里使用了两层嵌套。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># Fir_File_Lines=$(wc -l $(ls | sed -n &#x27;1p&#x27;))</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo &quot;$Fir_File_Lines&quot;</span></span><br><span class="line">36 anaconda-ks.cfg</span><br></pre></td></tr></table></figure><p>要注意的是，$() 仅在 Bash Shell 中有效，而反引号可在多种 Shell 中使用。所以这两种命令替换的方式各有特点，究竟选用哪种方式全看个人需求。</p><h3 id="2-内置命令">2.内置命令</h3><p>所谓 Shell 内建命令，就是由 Bash 自身提供的命令，而不是文件系统中的某个可执行文件。</p><p>例如，用于进入或者切换目录的 cd 命令，虽然我们一直在使用它，但如果不加以注意很难意识到它与普通命令的性质是不一样的：该命令并不是某个外部文件，只要在 Shell 中你就一定可以运行这个命令。</p><p>可以使用 type 来确定一个命令是否是内建命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a Shell <span class="built_in">builtin</span></span><br><span class="line">[root@localhost ~]<span class="comment"># type ifconfig</span></span><br><span class="line">ifconfig is /sbin/ifconfig</span><br></pre></td></tr></table></figure><p>由此可见，cd 是一个 Shell 内建命令，而 ifconfig 是一个外部文件，它的位置是<code>/sbin/ifconfig</code>。</p><p>还记得系统变量 <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/962.html">$PATH</a> 吗？$PATH 变量包含的目录中几乎聚集了系统中绝大多数的可执行命令，它们都是外部命令。</p><p>通常来说，内建命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘 I/O，还需要 fork 出一个单独的进程来执行，执行完成后再退出。而执行内建命令相当于调用当前 Shell 进程的一个函数。</p><ul><li><p>Bash Shell 中直接可用的内建命令:</p><table><caption>Bash Shell 内建命令</caption><tbody><tr><th>命令</th><th>说明</th></tr><tr><td>:</td><td>扩展参数列表，执行重定向操作</td></tr><tr><td>.</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>alias</td><td>为指定命令定义一个别名</td></tr><tr><td>bg</td><td>将作业以后台模式运行</td></tr><tr><td>bind</td><td>将键盘序列绑定到一个 readline 函数或宏</td></tr><tr><td>break</td><td>退出 for、while、select 或 until 循环</td></tr><tr><td>builtin</td><td>执行指定的 shell 内建命令</td></tr><tr><td>caller</td><td>返回活动子函数调用的上下文</td></tr><tr><td>cd</td><td>将当前目录切换为指定的目录</td></tr><tr><td>command</td><td>执行指定的命令，无需进行通常的 shell 查找</td></tr><tr><td>compgen</td><td>为指定单词生成可能的补全匹配</td></tr><tr><td>complete</td><td>显示指定的单词是如何补全的</td></tr><tr><td>compopt</td><td>修改指定单词的补全选项</td></tr><tr><td>continue</td><td>继续执行 for、while、select 或 until 循环的下一次迭代</td></tr><tr><td>declare</td><td>声明一个变量或变量类型。</td></tr><tr><td>dirs</td><td>显示当前存储目录的列表</td></tr><tr><td>disown</td><td>从进程作业表中刪除指定的作业</td></tr><tr><td>echo</td><td>将指定字符串输出到 STDOUT</td></tr><tr><td>enable</td><td>启用或禁用指定的内建shell命令</td></tr><tr><td>eval</td><td>将指定的参数拼接成一个命令，然后执行该命令</td></tr><tr><td>exec</td><td>用指定命令替换 shell 进程</td></tr><tr><td>exit</td><td>强制 shell 以指定的退出状态码退出</td></tr><tr><td>export</td><td>设置子 shell 进程可用的变量</td></tr><tr><td>fc</td><td>从历史记录中选择命令列表</td></tr><tr><td>fg</td><td>将作业以前台模式运行</td></tr><tr><td>getopts</td><td>分析指定的位置参数</td></tr><tr><td>hash</td><td>查找并记住指定命令的全路径名</td></tr><tr><td>help</td><td>显示帮助文件</td></tr><tr><td>history</td><td>显示命令历史记录</td></tr><tr><td>jobs</td><td>列出活动作业</td></tr><tr><td>kill</td><td>向指定的进程 ID(PID) 发送一个系统信号</td></tr><tr><td>let</td><td>计算一个数学表达式中的每个参数</td></tr><tr><td>local</td><td>在函数中创建一个作用域受限的变量</td></tr><tr><td>logout</td><td>退出登录 shell</td></tr><tr><td>mapfile</td><td>从 STDIN 读取数据行，并将其加入索引数组</td></tr><tr><td>popd</td><td>从目录栈中删除记录</td></tr><tr><td>printf</td><td>使用格式化字符串显示文本</td></tr><tr><td>pushd</td><td>向目录栈添加一个目录</td></tr><tr><td>pwd</td><td>显示当前工作目录的路径名</td></tr><tr><td>read</td><td>从 STDIN 读取一行数据并将其赋给一个变量</td></tr><tr><td>readarray</td><td>从 STDIN 读取数据行并将其放入索引数组</td></tr><tr><td>readonly</td><td>从 STDIN 读取一行数据并将其赋给一个不可修改的变量</td></tr><tr><td>return</td><td>强制函数以某个值退出，这个值可以被调用脚本提取</td></tr><tr><td>set</td><td>设置并显示环境变量的值和 shell 属性</td></tr><tr><td>shift</td><td>将位置参数依次向下降一个位置</td></tr><tr><td>shopt</td><td>打开/关闭控制 shell 可选行为的变量值</td></tr><tr><td>source</td><td>读取并执行指定文件中的命令（在当前 shell 环境中）</td></tr><tr><td>suspend</td><td>暂停 Shell 的执行，直到收到一个 SIGCONT 信号</td></tr><tr><td>test</td><td>基于指定条件返回退出状态码 0 或 1</td></tr><tr><td>times</td><td>显示累计的用户和系统时间</td></tr><tr><td>trap</td><td>如果收到了指定的系统信号，执行指定的命令</td></tr><tr><td>type</td><td>显示指定的单词如果作为命令将会如何被解释</td></tr><tr><td>typeset</td><td>声明一个变量或变量类型。</td></tr><tr><td>ulimit</td><td>为系统用户设置指定的资源的上限</td></tr><tr><td>umask</td><td>为新建的文件和目录设置默认权限</td></tr><tr><td>unalias</td><td>刪除指定的别名</td></tr><tr><td>unset</td><td>刪除指定的环境变量或 shell 属性</td></tr><tr><td>wait</td><td>等待指定的进程完成，并返回退出状态码</td></tr></tbody></table></li></ul><h3 id="3-alias-给命令创建别名">3.alias 给命令创建别名</h3><p>alisa 用来给命令创建一个别名。若直接输入该命令且不带任何参数，则列出当前 Shell 进程中使用了哪些别名。现在你应该能理解类似<code>ll</code>这样的命令为什么与<code>ls -l</code>的效果是一样的吧。</p><p>下面让我们来看一下有哪些命令被默认创建了别名：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">&#x27;ls -d .* --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=tty&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">which</span>=<span class="string">&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span></span><br></pre></td></tr></table></figure><p>你看，为了让我们使用方便，Shell 会给某些命令默认创建别名。</p><ul><li><p>使用 alias 命令自定义别名</p><p>使用 alias 命令自定义别名的语法格式为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> new_name=<span class="string">&#x27;command&#x27;</span></span><br></pre></td></tr></table></figure><p>比如，一般的关机命令是<code>shutdown-h now</code>，写起来比较长，这时可以重新定义一个关机命令，以后就方便多了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> myShutdown=<span class="string">&#x27;shutdown -h now&#x27;</span></span><br></pre></td></tr></table></figure><p>再如，通过 date 命令可以获得当前的 UNIX 时间戳，具体写法为<code>date +%s</code>，如果你嫌弃它太长或者不容易记住，那可以给它定义一个别名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> timestamp=<span class="string">&#x27;date +%s&#x27;</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">alias</span> timestamp=<span class="string">&#x27;date +%s&#x27;</span></span><br><span class="line">begin=`timestamp`  </span><br><span class="line"><span class="built_in">sleep</span> 20s</span><br><span class="line">finish=$(timestamp)</span><br><span class="line">difference=$((finish - begin))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run time: <span class="variable">$&#123;difference&#125;</span>s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行脚本，20 秒后看到输出结果：</span></span><br><span class="line">run time: 20s</span><br></pre></td></tr></table></figure><p><strong>别名只是临时的</strong>，在代码中使用 alias 命令定义的别名只能在当前 Shell 进程中使用，在子进程和其它进程中都不能使用。当前 Shell 进程结束后，别名也随之消失。要想让别名对所有的 Shell 进程都有效，就得把别名写入 Shell 配置文件。Shell 进程每次启动时都会执行配置文件中的代码做一些初始化工作，将别名放在配置文件中，那么每次启动进程都会定义这个别名。</p></li><li><p>使用 unalias 命令删除别名</p><p>使用 unalias 内建命令可以删除当前 Shell 进程中的别名。unalias 有两种使用方法：</p><ul><li>第一种用法是在命令后跟上某个命令的别名，用于删除指定的别名。</li><li>第二种用法是在命令后接<code>-a</code>参数，删除当前 Shell 进程中所有的别名。</li></ul><p>同样，这两种方法都是在当前 Shell 进程中生效的。要想永久删除配置文件中定义的别名，只能进入该文件手动删除。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 ll 别名</span></span><br><span class="line">[root@localhost ~]$ <span class="built_in">unalias</span> ll</span><br><span class="line"><span class="comment"># 再次运行该命令时，报“找不到该命令”的错误，说明该别名被删除了</span></span><br><span class="line">[root@localhost ~]$ ll</span><br><span class="line">-bash: ll: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-echo-输出字符串">4.echo 输出字符串</h3><h3 id="5-read-读取从键盘输入的数据">5.read 读取从键盘输入的数据</h3><h3 id="6-exit-退出当前进程">6.exit 退出当前进程</h3><h3 id="7-declare-typeset-设置变量属性">7.declare(typeset) 设置变量属性</h3><p>declare 和 typeset 都是 Shell 内建命令，它们的用法相同，都用来设置变量的属性。不过 typeset 已经被弃用了，建议使用 declare 代替。</p><p>declare 命令的用法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare [+/-] [aAfFgilprtux] [变量名=变量值]</span><br></pre></td></tr></table></figure><p>其中，<code>-</code>表示设置属性，<code>+</code>表示取消属性，<code>aAfFgilprtux</code>都是具体的选项，它们的含义如下表所示：</p><table><tbody><tr><th>选项</th><th>含义</th></tr><tr><td>-f [name]</td><td>列出之前由用户在脚本中定义的函数名称和函数体。</td></tr><tr><td>-F [name]</td><td>仅列出自定义函数名称。</td></tr><tr><td>-g name</td><td>在 Shell 函数内部创建全局变量。</td></tr><tr><td>-p [name]</td><td>显示指定变量的属性和值。</td></tr><tr><td>-a name</td><td>声明变量为普通数组。</td></tr><tr><td>-A name</td><td>声明变量为关联数组（支持索引下标为字符串）。</td></tr><tr><td>-i name&nbsp;</td><td>将变量定义为整数型。</td></tr><tr><td>-r name[=value]&nbsp;</td><td>将变量定义为只读（不可修改和删除），等价于 readonly name。</td></tr><tr><td>-x name[=value]</td><td>将变量设置为环境变量，等价于&nbsp;export name[=value]。</td></tr></tbody></table><p>【实例1】将变量声明为整数并进行计算。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -i m n ret  <span class="comment">#将多个变量声明为整数</span></span><br><span class="line">m=10</span><br><span class="line">n=30</span><br><span class="line">ret=<span class="variable">$m</span>+<span class="variable">$n</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">40</span><br></pre></td></tr></table></figure><p>【实例2】将变量定义为只读变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ <span class="built_in">declare</span> -r n=10</span><br><span class="line">[c.biancheng.net]$ n=20</span><br><span class="line">bash: n: 只读变量</span><br><span class="line">[c.biancheng.net]$ <span class="built_in">echo</span> <span class="variable">$n</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>【实例3】显示变量的属性和值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[c.biancheng.net]$ <span class="built_in">declare</span> -r n=10</span><br><span class="line">[c.biancheng.net]$ <span class="built_in">declare</span> -p n</span><br><span class="line"><span class="built_in">declare</span> -r n=<span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><h3 id="8-test-检测某个条件是否成立-a-id-test-anchor-a">8.test([ ]) 检测某个条件是否成立<a id="test_anchor"></a></h3><p>test 是 Shell 内置命令，用来检测某个条件是否成立。test 通常和 if 语句一起使用，并且大部分 if 语句都依赖 test。</p><p>test 命令有很多选项，可以进行数值、字符串和文件三个方面的检测。</p><p>Shell test 命令的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> expression</span><br></pre></td></tr></table></figure><p>当 test 判断 expression 成立时，退出状态为 0，否则为非 0 值。</p><p>test 命令也可以简写为<code>[]</code>，它的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ expression ]</span><br></pre></td></tr></table></figure><p>==注意<code>[]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。<code>[]</code>的写法更加简洁，比 test 使用频率高。==</p><p>例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> age</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$age</span> -le 2; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;婴儿&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> <span class="variable">$age</span> -ge 3 &amp;&amp; <span class="built_in">test</span> <span class="variable">$age</span> -le 8; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;幼儿&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$age</span> -ge 9 ] &amp;&amp; [ <span class="variable">$age</span> -le 17 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;少年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$age</span> -ge 18 ] &amp;&amp; [ <span class="variable">$age</span> -le 25 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;成年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> <span class="variable">$age</span> -ge 26 &amp;&amp; <span class="built_in">test</span> <span class="variable">$age</span> -le 40; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;青年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> <span class="variable">$age</span> -ge 41 &amp;&amp; [ <span class="variable">$age</span> -le 60 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;中年&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;老年&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>其中，<code>-le</code>选项表示小于等于，<code>-ge</code>选项表示大于等于，<code>&amp;&amp;</code>是逻辑与运算符。</p><p>学习 test 命令，重点是学习它的各种选项，下面我们就逐一讲解。</p><h4 id="1）与文件检测相关">1）与文件检测相关</h4><table><caption>表1：test 文件检测相关选项列表</caption><tbody><tr><th colspan="2">文件类型判断</th></tr><tr><th>选 项</th><th>作 用</th></tr><tr><td>-b filename</td><td>判断文件是否存在，并且是否为块设备文件。</td></tr><tr><td>-c filename</td><td>判断文件是否存在，并且是否为字符设备文件。</td></tr><tr><td>-d filename</td><td>判断文件是否存在，并且是否为目录文件。</td></tr><tr><td>-e filename</td><td>判断文件是否存在。</td></tr><tr><td>-f filename</td><td>判断文件是否存在，井且是否为普通文件。</td></tr><tr><td>-L filename</td><td>判断文件是否存在，并且是否为符号链接文件。</td></tr><tr><td>-p&nbsp;filename</td><td>判断文件是否存在，并且是否为管道文件。</td></tr><tr><td>-s filename</td><td>判断文件是否存在，并且是否为非空。</td></tr><tr><td>-S filename</td><td>判断该文件是否存在，并且是否为套接字文件。</td></tr><tr><th colspan="2">文件权限判断</th></tr><tr><th>选 项</th><th>作&nbsp;用</th></tr><tr><td>-r filename</td><td>判断文件是否存在，并且是否拥有读权限。</td></tr><tr><td>-w filename</td><td>判断文件是否存在，并且是否拥有写权限。</td></tr><tr><td>-x filename</td><td>判断文件是否存在，并且是否拥有执行权限。</td></tr><tr><td>-u filename</td><td>判断文件是否存在，并且是否拥有 SUID 权限。</td></tr><tr><td>-g filename</td><td>判断文件是否存在，并且是否拥有 SGID 权限。</td></tr><tr><td>-k filename</td><td>判断该文件是否存在，并且是否拥有 SBIT 权限。</td></tr><tr><th colspan="2">文件比较</th></tr><tr><th>选 项</th><th>作&nbsp;用</th></tr><tr><td>filename1 -nt filename2</td><td>判断 filename1 的修改时间是否比 filename2 的新。</td></tr><tr><td>filename -ot filename2</td><td>判断 filename1 的修改时间是否比 filename2 的旧。</td></tr><tr><td>filename1 -ef filename2</td><td>判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td></tr></tbody></table><p>Shell test 文件检测举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> filename</span><br><span class="line"><span class="built_in">read</span> url</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -w <span class="variable">$filename</span> &amp;&amp; <span class="built_in">test</span> -n <span class="variable">$url</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$url</span> &gt; <span class="variable">$filename</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;写入成功&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;写入失败&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在 Shell 脚本文件所在的目录新建一个文本文件并命名为 urls.txt，然后运行 Shell 脚本，运行结果为：</span></span><br><span class="line">urls.txt↙</span><br><span class="line">http://c.biancheng.net/shell/↙</span><br><span class="line">写入成功</span><br></pre></td></tr></table></figure><h4 id="2）与数值比较相关">2）与数值比较相关</h4><table><caption>表2：test 数值比较相关选项列表</caption><tbody><tr><th>选 项</th><th>作&nbsp;用</th></tr><tr><td>num1 -eq num2</td><td>判断 num1 是否和 num2 相等。</td></tr><tr><td>num1 -ne num2</td><td>判断 num1 是否和 num2 不相等。</td></tr><tr><td>num1 -gt num2</td><td>判断 num1 是否大于 num2 。</td></tr><tr><td>num1 -lt num2</td><td>判断 num1 是否小于 num2。</td></tr><tr><td>num1 -ge num2</td><td>判断 num1 是否大于等于 num2。</td></tr><tr><td>num1 -le num2</td><td>判断 num1 是否小于等于 num2。</td></tr></tbody></table><p>注意，test 只能用来比较整数，小数相关的比较还得依赖 <a href="#bc_anchor">bc 命令</a>。</p><p>Shell test 数值比较举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a b</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$a</span> -eq <span class="variable">$b</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数相等&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个数不相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果1：</span></span><br><span class="line">10 10</span><br><span class="line">两个数相等</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果2：</span></span><br><span class="line">10 20</span><br><span class="line">两个数不相等</span><br></pre></td></tr></table></figure><h4 id="3）与字符串判断相关">3）与字符串判断相关</h4><table><caption>表3：test 字符串判断相关选项列表</caption><tbody><tr><th>选 项</th><th>作&nbsp;用</th></tr><tr><td>-z str</td><td>判断字符串 str 是否为空。</td></tr><tr><td>-n str</td><td>判断宇符串 str 是否为非空。</td></tr><tr><td>str1 = str2<br>str1 == str2</td><td><code>=</code>和<code>==</code>是等价的，都用来判断 str1 是否和 str2 相等。</td></tr><tr><td>str1 != str2</td><td>判断 str1 是否和 str2 不相等。</td></tr><tr><td>str1 \&gt; str2</td><td>判断 str1 是否大于 str2。<code>\&gt;</code>是<code>&gt;</code>的转义字符，这样写是为了防止<code>&gt;</code>被误认为成重定向运算符。</td></tr><tr><td>str1 \&lt; str2</td><td>判断 str1 是否小于 str2。同样，<code>\&lt;</code>也是转义字符。</td></tr></tbody></table><p><code>==、&gt;、&lt;</code> 在大部分编程语言中都用来比较数字，而在 Shell 中，它们只能用来比较字符串，不能比较数字，这是非常奇葩的，大家要习惯。</p><p>其次，不管是比较数字还是字符串，Shell 都不支持 &gt;= 和 &lt;= 运算符，切记。</p><p>Shell test 字符串比较举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> str1</span><br><span class="line"><span class="built_in">read</span> str2</span><br><span class="line"><span class="comment">#检测字符串是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> ] || [ -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;字符串不能为空&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#比较字符串</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$str1</span> = <span class="variable">$str2</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串相等&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串不相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">http://c.biancheng.net/</span><br><span class="line">http://c.biancheng.net/shell/</span><br><span class="line">两个字符串不相等</span><br></pre></td></tr></table></figure><p>变量 <code>$str1</code> 和 <code>$str2</code> 都被双引号包围起来，这样做是为了防止 <code>$str1</code> 或者 <code>$str2</code> 是空字符串时出现错误。</p><h4 id="4）与逻辑运算相关">4）与逻辑运算相关</h4><table><caption>表4：test 逻辑运算相关选项列表</caption><tbody><tr><th>选 项</th><th>作&nbsp;用</th></tr><tr><td>expression1 -a expression</td><td>逻辑与，表达式 expression1 和 expression2 都成立，最终的结果才是成立的。</td></tr><tr><td>expression1 -o expression2</td><td>逻辑或，表达式 expression1 和 expression2 有一个成立，最终的结果就成立。</td></tr><tr><td>!expression</td><td>逻辑非，对 expression 进行取反。</td></tr></tbody></table><p>改写上面的代码，使用逻辑运算选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> str1</span><br><span class="line"><span class="built_in">read</span> str2</span><br><span class="line"><span class="comment">#检测字符串是否为空</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> -o -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]  <span class="comment">#使用 -o 选项取代之前的 ||</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;字符串不能为空&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#比较字符串</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$str1</span> = <span class="variable">$str2</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串相等&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;两个字符串不相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>前面的代码我们使用两个<code>[]</code>命令，并使用<code>||</code>运算符将它们连接起来，这里我们改成<code>-o</code>选项，只使用一个<code>[]</code>命令就可以了。</p><ul><li><p>在 test 中使用变量建议用双引号包围起来</p><p>test 和 [] 都是命令，一个命令本质上对应一个程序或者一个函数。即使是一个程序，它也有入口函数，例如C语言程序的入口函数是 main()，运行C语言程序就从 main() 函数开始，所以也可以将一个程序等效为一个函数，这样我们就不用再区分函数和程序了，直接将一个命令和一个函数对应起来即可。</p><p>有了以上认知，就很容易看透命令的本质了：使用一个命令其实就是调用一个函数，命令后面附带的选项和参数最终都会作为实参传递给函数。</p><p>假设 test 命令对应的函数是 func()，使用<code>test -z $str1</code>命令时，会先将变量 $str1 替换成字符串：</p><ul><li>如果 $str1 是一个正常的字符串，比如 abc123，那么替换后的效果就是<code>test -z abc123</code>，调用 func() 函数的形式就是<code>func(&quot;-z abc123&quot;)</code>。test 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数。</li><li>如果 $str1 是一个空字符串，那么替换后的效果就是<code>test -z</code>，调用 func() 函数的形式就是<code>func(&quot;-z &quot;)</code>，这就比较奇怪了，因为<code>-z</code>选项没有和参数成对出现，func() 在分析时就会出错。</li></ul><p>如果我们给 $str1 变量加上双引号，当 $str1 是空字符串时，<code>test -z &quot;$str1&quot;</code>就会被替换为<code>test -z &quot;&quot;</code>，调用 func() 函数的形式就是<code>func(&quot;-z \&quot;\&quot;&quot;)</code>，很显然，<code>-z</code>选项后面跟的是一个空字符串（<code>\&quot;</code>表示转义字符），这样 func() 在分析时就不会出错了。</p><p>所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号<code>&quot;&quot;</code>包围起来，这样能避免变量为空值时导致的很多奇葩问题。</p></li><li><p>总结</p><p>test 命令比较奇葩，&gt;、&lt;、== 只能用来比较字符串，不能用来比较数字，比较数字需要使用 -eq、-gt 等选项；不管是比较字符串还是数字，test 都不支持 &gt;= 和 &lt;=。有经验的程序员需要慢慢习惯 test 命令的这些奇葩用法。</p><p>对于整型数字的比较，我建议大家使用 (())。(()) 支持各种运算符，写法也符合数学规则，用起来更加方便，何乐而不为呢？</p><p>几乎完全兼容 test ，并且比 test 更加强大，比 test 更加灵活的是<code>[[ ]]</code>；<code>[[ ]]</code>不是命令，是关键字。</p></li></ul><h3 id="9-检测某个条件是否成立">9.[[ ]] 检测某个条件是否成立</h3><p><code>[[ ]]</code>是 Shell 内置==关键字==，放到命令中来讲是因为 text 功能相近，也用来检测某个条件是否成立。</p><p>test 能做到的，<code>[[ ]]</code> 也能做到，而且 <code>[[ ]]</code> 做的更好；test 做不到的，<code>[[ ]]</code> 还能做到。可以认为 <code>[[ ]]</code> 是 test 的升级版，对细节进行了优化，并且扩展了一些功能。</p><p>[[ ]] 的用法为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure><p>当 <code>[[ ]]</code> 判断 expression 成立时，退出状态为 0，否则为非 0 值。注意<code>[[ ]]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。</p><h4 id="1）不需要注意某些细枝末节">1）不需要注意某些细枝末节</h4><p><code>[[ ]]</code> 是 Shell 内置关键字，不是命令，在使用时没有给函数传递参数的过程，所以 test 命令的某些注意事项在 <code>[[ ]]</code> 中就不存在了，具体包括：</p><ul><li>不需要把变量名用双引号<code>&quot;&quot;</code>包围起来，即使变量是空值，也不会出错。</li><li>不需要、也不能对 &gt;、&lt; 进行转义，转义后会出错。</li></ul><p>请看下面的演示代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> str1</span><br><span class="line"><span class="built_in">read</span> str2</span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$str1</span> ]] || [[ -z <span class="variable">$str2</span> ]]  <span class="comment">#不需要对变量名加双引号</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;字符串不能为空&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$str1</span> &lt; <span class="variable">$str2</span> ]]  <span class="comment">#不需要也不能对 &lt; 进行转义</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;str1 &lt; str2&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;str1 &gt;= str2&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">http://c.biancheng.net/shell/</span><br><span class="line">http://data.biancheng.net/</span><br><span class="line">str1 &lt; str2</span><br></pre></td></tr></table></figure><h4 id="2）支持逻辑运算符">2）支持逻辑运算符</h4><p>对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> ] || [ -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]</span><br></pre></td></tr></table></figure><p>你也可以借助选项把多个表达式写在一个 test 命令中，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ -z <span class="string">&quot;<span class="variable">$str1</span>&quot;</span> -o -z <span class="string">&quot;<span class="variable">$str2</span>&quot;</span> ]</span><br></pre></td></tr></table></figure><p>但是，这两种写法都有点“别扭”，完美的写法是在一个命令中使用逻辑运算符将多个表达式连接起来。我们的这个愿望在 <code>[[ ]]</code> 中实现了，<code>[[ ]]</code> 支持 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 三种逻辑运算符。</p><p>使用 <code>[[ ]]</code> 对上面的语句进行改进：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z <span class="variable">$str1</span> || -z <span class="variable">$str2</span> ]]</span><br></pre></td></tr></table></figure><p>这种写法就比较简洁漂亮了。</p><p>注意，<code>[[ ]]</code> 剔除了 test 命令的<code>-o</code>和<code>-a</code>选项，你只能使用 <code>||</code> 和 <code>&amp;&amp;</code>。这意味着，你不能写成下面的形式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z <span class="variable">$str1</span> -o -z <span class="variable">$str2</span> ]]</span><br></pre></td></tr></table></figure><p>当然，使用逻辑运算符将多个 [[ ]] 连接起来依然是可以的，因为这是 Shell 本身提供的功能，跟 [[ ]] 或者 test 没有关系，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -z <span class="variable">$str1</span> ]] || [[ -z <span class="variable">$str2</span> ]]</span><br></pre></td></tr></table></figure><table><caption>该表总结了各种写法的对错</caption><tbody><tr><th colspan="2">test 或&nbsp;[]</th><th colspan="2">[[ ]]</th></tr><tr><td>[ -z "$str1" ] || [ -z "$str2" ]</td><td><span style="color:green"><b>√</b></span></td><td>[[ -z $str1 ]] || [[ -z $str2 ]]</td><td><b><span style="color:green">√</span></b></td></tr><tr><td>[ -z "$str1" -o -z "$str2" ]</td><td><b><span style="color:green">√</span></b></td><td>[[ -z $str1 -o -z $str2 ]]</td><td><b><span style="color:red">×</span></b></td></tr><tr><td>[&nbsp;-z $str1 || -z $str2 ]</td><td><span style="color:red"><b>×</b></span></td><td>[[ -z $str1 || -z $str2 ]]</td><td><b><span style="color:green">√</span></b></td></tr></tbody></table><h4 id="3）支持正则表达式">3）支持正则表达式</h4><p>在 Shell <code>[[ ]]</code> 中，可以使用<code>=~</code>来检测字符串是否符合某个正则表达式，它的用法为：</p><p>str 表示字符串，regex 表示正则表达式。</p><p>下面的代码检测一个字符串是否是手机号：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> tel</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$tel</span> =~ ^1[0-9]&#123;10&#125;$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;你输入的是手机号码&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;你输入的不是手机号码&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果1：</span></span><br><span class="line">13203451100</span><br><span class="line">你输入的是手机号码</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果2：</span></span><br><span class="line">132034511009</span><br><span class="line">你输入的不是手机号码</span><br></pre></td></tr></table></figure><blockquote><p>对<code>^1[0-9]&#123;10&#125;$</code>的说明：</p><ul><li><code>^</code>匹配字符串的开头（一个位置）；</li><li><code>[0-9]&#123;10&#125;</code>匹配连续的十个数字；</li><li><code>$</code>匹配字符串的末尾（一个位置）。</li></ul></blockquote><ul><li><p>总结</p><p>有了 <code>[[ ]]</code>，你还有什么理由使用 <code>test</code> 或者 <code>[ ]</code>，<code>[[ ]]</code> 完全可以替代之，而且更加方便，更加强大。</p><p>但是 <code>[[ ]]</code> 对数字的比较仍然不友好，所以我建议，以后大家使用 if 判断条件时，==用 <code>(())</code> 来处理整型数字，用 <code>[[ ]]</code> 来处理字符串或者文件==。</p></li></ul><hr><h2 id="4-位置参数">4.位置参数</h2><p>Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用<code>$n</code>的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><p>同样，在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用<code>$n</code>的形式接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p><p>这种通过<code>$n</code>的形式来接收的参数，在 Shell 中称为位置参数。</p><p>变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“特殊变量”。</p><p>除了 <code>$n</code>，Shell 中还有 <code>$#、$*、$@、$?、$$</code> 几个特殊参数。</p><h3 id="1-给脚本文件传递位置参数">1.给脚本文件传递位置参数</h3><p>请编写下面的代码，并命名为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Language: <span class="variable">$1</span>&quot;</span><span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span><br></pre></td></tr></table></figure><p>运行 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>，并附带参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ cd demo</span><br><span class="line">[root@localhost demo]$ . ./test.sh Shell http://nb.com/shell/</span><br><span class="line">Language: Shell</span><br><span class="line">URL: http://nb.com/shell/</span><br></pre></td></tr></table></figure><p>其中<code>Shell</code>是第一个位置参数，<code>http://nb.com/shell/</code>是第二个位置参数，两者之间以空格分隔。</p><h3 id="2-给函数传递位置参数">2.给函数传递位置参数</h3><p>请编写下面的代码，并命名为 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#定义函数</span><br><span class="line">function func()&#123;</span><br><span class="line">	echo &quot;Language: $1&quot;</span><br><span class="line">    echo &quot;URL: $2&quot;&#125;</span><br><span class="line">    </span><br><span class="line">#调用函数</span><br><span class="line">func C++ http://nb.com/cplus/</span><br></pre></td></tr></table></figure><p>运行 <a target="_blank" rel="noopener" href="http://test.sh">test.sh</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ cd demo</span><br><span class="line">[root@localhost demo]$ . ./test.sh</span><br><span class="line">Language: C++</span><br><span class="line">URL: http://nb.com//cplus/</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项</strong></p><p>如果参数个数太多，达到或者超过了 10 个，那么就得用<code>$&#123;n&#125;</code>的形式来接收了，例如 ${10}、${23}。<code>&#123; &#125;</code>的作用是为了帮助解释器识别参数的边界，这跟使用变量时加<code>&#123; &#125;</code>是一样的效果。</p></blockquote><hr><h2 id="5-字符串">5.字符串</h2><h3 id="1-定义">1.定义</h3><p>字符串（String）就是一系列字符的组合。字符串是 Shell 编程中最常用的数据类型之一（除了数字和字符串，也没有其他类型了）。</p><p>字符串可以由单引号<code>' '</code>包围，也可以由双引号<code>&quot; &quot;</code>包围，也可以不用引号。它们之间是有区别的。</p><p>下面我们说一下三种形式的区别：</p><ol><li><p>由单引号<code>' '</code>包围的字符串：</p><ul><li>任何字符都会原样输出，在其中使用变量是无效的。</li><li>字符串中不能出现单引号，即使对单引号进行转义也不行。</li></ul></li><li><p>由双引号<code>&quot; &quot;</code>包围的字符串：</p><ul><li>如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。</li><li>字符串中可以出现双引号，只要它被转义了就行。</li></ul></li><li><p>不被引号包围的字符串</p><ul><li>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号<code>&quot; &quot;</code>包围的字符串一样。</li><li>字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。</li></ul></li></ol><p>我们通过代码来演示一下三种形式的区别：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">n=74</span><br><span class="line">str1=c.biancheng.net<span class="variable">$n</span> </span><br><span class="line">str2=<span class="string">&quot;shell \&quot;script\&quot; <span class="variable">$n</span>&quot;</span></span><br><span class="line">str3=<span class="string">&#x27;C语言中文网 $n&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行结果：</span></span><br><span class="line">c.biancheng.net74</span><br><span class="line">shell <span class="string">&quot;script&quot;</span> 74</span><br><span class="line">C语言中文网 <span class="variable">$n</span></span><br></pre></td></tr></table></figure><p>str1 中包含了<code>$n</code>，它被解析为变量 n 的引用。<code>$n</code>后边有空格，紧随空格的是 str2；Shell 将 str2 解释为一个新的变量名，而不是作为字符串 str1 的一部分。</p><p>str2 中包含了引号，但是被转义了（由反斜杠<code>\</code>开头的表示转义字符）。str2 中也包含了<code>$n</code>，它也被解析为变量 n 的引用。</p><p>str3 中也包含了<code>$n</code>，但是仅仅是作为普通字符，并没有解析为变量 n 的引用。</p><h3 id="2-获取字符串长度">2.获取字符串长度</h3><p>在 Shell 中获取字符串长度很简单，具体方法如下：</p><p>$</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.halfsummer.xyz">aceniu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.halfsummer.xyz/posts/edc1b716.html">https://blog.halfsummer.xyz/posts/edc1b716.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.halfsummer.xyz" target="_blank">艾斯牛 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="http://cos.halfsummer.xyz/pictures/niubb/2023/20230228-63fdc7d0ce7ba.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/520fef84.html" title="MySQL 学习笔记"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL 学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/920e92d1.html" title="Docker 学习笔记"><div class="cover" style="background:var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker 学习笔记</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://cos.halfsummer.xyz/pictures/niubb/2023/20230228-63fdc7d0ce7ba.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">aceniu</div><div class="author-info__description">Love 33 & Yilia</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aceniu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/aceniu" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-icon_github-circle"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=123354319@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-Rss"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/289493392" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=123354319&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-icon_qq-circle"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Shell"><span class="toc-text">Shell</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Shell-%E8%84%9A%E6%9C%AC"><span class="toc-text">1.Shell 脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E4%B8%AAshell%E8%84%9A%E6%9C%AC"><span class="toc-text">1.第一个shell脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC"><span class="toc-text">2.执行Shell脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F"><span class="toc-text">2.变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-text">1.定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-text">2.使用变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E5%8F%98%E9%87%8F"><span class="toc-text">3.删除变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">4.变量的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shell-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">Shell 环境变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Shell%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F-%E3%80%81-%E3%80%81-%E3%80%81-%E3%80%81"><span class="toc-text">5.Shell特殊变量 $#、$*、$@、$?、$$</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%91%BD%E4%BB%A4"><span class="toc-text">3.命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2"><span class="toc-text">1.命令替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="toc-text">2.内置命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-alias-%E7%BB%99%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E5%88%AB%E5%90%8D"><span class="toc-text">3.alias 给命令创建别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-echo-%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.echo 输出字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-read-%E8%AF%BB%E5%8F%96%E4%BB%8E%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">5.read 读取从键盘输入的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-exit-%E9%80%80%E5%87%BA%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.exit 退出当前进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-declare-typeset-%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">7.declare(typeset) 设置变量属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-test-%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E6%9D%A1%E4%BB%B6%E6%98%AF%E5%90%A6%E6%88%90%E7%AB%8B-a-id-test-anchor-a"><span class="toc-text">8.test([ ]) 检测某个条件是否成立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E7%9B%B8%E5%85%B3"><span class="toc-text">1）与文件检测相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E4%B8%8E%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83%E7%9B%B8%E5%85%B3"><span class="toc-text">2）与数值比较相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD%E7%9B%B8%E5%85%B3"><span class="toc-text">3）与字符串判断相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3"><span class="toc-text">4）与逻辑运算相关</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E6%9D%A1%E4%BB%B6%E6%98%AF%E5%90%A6%E6%88%90%E7%AB%8B"><span class="toc-text">9.[[ ]] 检测某个条件是否成立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E4%B8%8D%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E6%9F%90%E4%BA%9B%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82"><span class="toc-text">1）不需要注意某些细枝末节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%94%AF%E6%8C%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2）支持逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3）支持正则表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">4.位置参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%99%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%92%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">1.给脚本文件传递位置参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%99%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">2.给函数传递位置参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">5.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-text">2.获取字符串长度</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/c1c5e0d7.html" title="Tomcat 学习笔记">Tomcat 学习笔记</a><time datetime="2023-03-13T23:19:24.000Z" title="发表于 2023-03-13 23:19:24">2023-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/c1020521.html" title="Nginx 学习笔记">Nginx 学习笔记</a><time datetime="2023-03-13T23:16:34.000Z" title="发表于 2023-03-13 23:16:34">2023-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/fa17c65a.html" title="Redis 学习笔记">Redis 学习笔记</a><time datetime="2023-03-13T23:16:24.000Z" title="发表于 2023-03-13 23:16:24">2023-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/520fef84.html" title="MySQL 学习笔记">MySQL 学习笔记</a><time datetime="2023-03-13T23:15:45.000Z" title="发表于 2023-03-13 23:15:45">2023-03-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/edc1b716.html" title="Shell编程 学习笔记">Shell编程 学习笔记</a><time datetime="2023-03-13T23:14:53.000Z" title="发表于 2023-03-13 23:14:53">2023-03-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By aceniu</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://hexo-twikoo.halfsummer.xyz/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://hexo-twikoo.halfsummer.xyz/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>