<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>Linux 学习手册 | 艾斯牛 Blog</title><meta name="author" content="aceniu,123354319@qq.com"><meta name="copyright" content="aceniu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux 全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。"><meta property="og:type" content="article"><meta property="og:title" content="Linux 学习手册"><meta property="og:url" content="https://blog.halfsummer.xyz/posts/52702296.html"><meta property="og:site_name" content="艾斯牛 Blog"><meta property="og:description" content="Linux 全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img01.anzhiy.cn/useruploads/0/2023/02/13/63e915ae124a2.png"><meta property="article:published_time" content="2023-01-10T20:52:00.000Z"><meta property="article:modified_time" content="2023-02-12T22:48:00.000Z"><meta property="article:author" content="aceniu"><meta property="article:tag" content="编程"><meta property="article:tag" content="运维"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img01.anzhiy.cn/useruploads/0/2023/02/13/63e915ae124a2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.halfsummer.xyz/posts/52702296.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Linux 学习手册",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-02-12 22:48:00"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="艾斯牛 Blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/12/63e7dea41c063.gif" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg> <span>追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://img01.anzhiy.cn/useruploads/0/2023/02/13/63e915ae124a2.png)"><nav id="nav"><span id="blog-info"><a href="/" title="艾斯牛 Blog"><span class="site-name">艾斯牛 Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg> <span>追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux 学习手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-10T20:52:00.000Z" title="发表于 2023-01-10 20:52:00">2023-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-12T22:48:00.000Z" title="更新于 2023-02-12 22:48:00">2023-02-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Note/">Note</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Note/Program/">Program</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Linux 学习手册"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"><h1 id="swig￼440"><p class="p cyan huge center">Linux 概述<sup>(1)</sup></p></h1><ul><li><p>Linux 全称GNU/Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。</p></li><li><p>GNU/Linux</p><p>GNU本来有一个官方的内核，称为GNU Hurd，遗憾的是GNU Hurd还没有准备好可以作为产品使用。幸运的是，另一个内核已经可以取得。在一九九一年，Linus Torvalds开发了一个与Unix兼容的内核并称之为Linux。大约在一九九二年，将Linux与不是非常完整的GNU系统相结合产生了一个完整的自由软件操作系统，我们今天因此可以实际运行一个GNU系统的版本，称之GNU/Linux。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/Snipaste_2022-12-18_11-55-23.png" alt="Snipaste_2022-12-18_11-55-23"></p></li></ul><blockquote><ul><li><p>理查德·马修·斯托曼,全名Richard Matthew Stallman, RMS,于1953年出生，自由软件运动的精神领袖、GNU计划以及自由软件基金会（Free Software Foundation）的创立者、著名黑客。</p></li><li><p>李纳斯·托沃兹, linux之父，全名Linus Benedict Torvalds ，是一位出生于1969.12.28的芬兰人。</p></li></ul></blockquote><hr><h1 id="swig￼441"><p class="p cyan huge center">安装 Linux<sup>(2)</sup></p></h1><ul><li><p>下载</p><div class="tag link"><a class="link-card" title="阿里云开发者社区" target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/"><div class="left"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.alicdn.com/tfs/TB13DzOjXP7gK0jSZFjXXc5aXXa-212-48.png"></div><div class="right"><p class="text">阿里云开发者社区</p><p class="url">https://developer.aliyun.com/mirror/</p></div></a></div></li><li><p>CentOS</p><div class="tag link"><a class="link-card" title="WMware安装" target="_blank" rel="noopener" href="https://gitee.com/aceniu/Notes/blob/master/installed_Linux_handbook.md"><div class="left"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/12/63e901a611c26.jpg"></div><div class="right"><p class="text">WMware安装</p><p class="url">https://gitee.com/aceniu/Notes/blob/master/installed_Linux_handbook.md</p></div></a></div></li></ul><hr><h1 id="swig￼444"><p class="p cyan huge center">登入 Linux<sup>(3)</sup></p></h1><details class="folding-tag" blue><summary>Windows登入 Linux</summary><div class="content"><p><code>win+r</code>在<code>cmd.exe</code>中输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@主机地址(||主机名)</span><br></pre></td></tr></table></figure><p>提示是否保存秘钥 （根据实际情况选择）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/Snipaste_2022-12-11_10-15-40.png" alt="Snipaste_2022-12-11_10-15-40"></p></div></details><details class="folding-tag" blue><summary>其它工具登入 Linux</summary><div class="content"><ul><li>XShell</li><li>FinalShell</li></ul></div></details><hr><h1 id="swig￼447"><p class="p cyan huge center">文件系统<sup>(4)</sup></p></h1><table><thead><tr><th>文件夹</th><th>作用</th></tr></thead><tbody><tr><td>bin</td><td>常用命令集合（实际位置在usr/bin）</td></tr><tr><td>sbin</td><td>管理员命令集（实际位置在usr/sbin）</td></tr><tr><td>lib</td><td>库目录（相当于System32）（实际位置在usr/lib）</td></tr><tr><td>lib64</td><td>64位库目录</td></tr><tr><td>usr</td><td>包含用户的所有应用程序、文件和数据 （usr/local/ 相当于 Progrom Files 应用一般安装于此）</td></tr><tr><td>boot</td><td>挂载引导</td></tr><tr><td>dev</td><td>管理所有设备</td></tr><tr><td>etc</td><td>系统管理的配置文件</td></tr><tr><td>home</td><td>用户的个性化主目录</td></tr><tr><td>root</td><td>管理员个性化主目录</td></tr><tr><td>opt</td><td>第三方软件包的目录</td></tr><tr><td>media</td><td>识别媒体（光驱，硬盘）</td></tr><tr><td>mnt</td><td>移动设备挂载点</td></tr><tr><td>proc</td><td>进程目录</td></tr><tr><td>run</td><td>当前系统运行的所有信息</td></tr><tr><td>srv</td><td>系统服务</td></tr><tr><td>sys</td><td>系统硬件信息的相关信息</td></tr><tr><td>tmp</td><td>临时目录</td></tr><tr><td>var</td><td>可变目录</td></tr></tbody></table><h1 id="swig￼448"><p class="p cyan huge center">基础配置<sup>(5)</sup></p></h1><h2 id="swig￼449"><p class="p blue large left">网络配置<sup>(5.1)</sup></p></h2><ul><li><p>查询网卡命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip addr</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230111000810607.png" alt="image-20230111000810607"></p><ul><li>IP地址配置：　<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code></li><li>网关配置：　　<code>/etc/sysconfig/network</code></li><li>DNS配置：　　<code>/etc/resolv.conf</code></li></ul></li><li><p><strong>配置方法</strong></p><p><strong>静态ip只需执行步骤1、4。</strong></p><ol><li><p>首先要编辑<strong>网卡配置</strong>文件，CentOS7的网卡配置文件路径是：(虚拟机一般为ifcfg-ens33)</p><p><code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>，此路径非常重要，以后企业主机网络不通，可从此配置文件中查看。万一有一天，忘记了，怎么办呢？这里大家 一定要善用find命令；因为我只是知道网卡配置文件在/etc目录下，名字是eth0结尾，因此find命令为：<code>find /etc -iname *eth0</code> 。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/b44a9b802c0a42ecafbcb03d8e99cf2a.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/sysconfig/network-script/ifcfg-eth0</span><br><span class="line"> DEVICE=eth0                   # 物理设备名</span><br><span class="line"> IPADDR=192.168.1.10           # IP地址</span><br><span class="line"> NETMASK=255.255.255.0         # 掩码值</span><br><span class="line"> NETWORK=192.168.1.0           # 网络地址 ( 可不要 )</span><br><span class="line"> BROADCAST=192.168.1.255       # 广播地址（ 可不要 ）</span><br><span class="line"> GATEWAY=192.168.1.1           # 网关地址</span><br><span class="line"> ONBOOT=yes                    # [yes|no]（引导时是否激活设备）--开机自启</span><br><span class="line"> USERCTL=no                    # [yes|no]（非root用户是否可以控制该设备）</span><br><span class="line"> BOOTPROTO=static              # [none|static|bootp|dhcp]（引导时不使用协议|静态分配|BOOTP协议|DHCP协议）</span><br></pre></td></tr></table></figure></li><li><p><strong>网关配置：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/sysconfig/network</span><br><span class="line"> NETWORKING=yes</span><br><span class="line"> HOSTNAME=localhost.localdomain</span><br><span class="line"> GATEWAY=192.168.1.1</span><br></pre></td></tr></table></figure></li><li><p><strong>DNS配置：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/resolv.conf </span><br><span class="line">nameserver 192.168.237.200</span><br><span class="line">nameserver 114.114.114.114       # 主DNS</span><br><span class="line">nameserver 8.8.8.8               # 次DNS</span><br></pre></td></tr></table></figure><p>第三方的 DNS 服务器：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1049141419-0.jpg" alt="img"></p></li><li><p><strong>重启网络服务：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务重启</span></span><br><span class="line">[root@localhost ~]# systemctl restart network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">脚本重启,一般不必这样执行</span></span><br><span class="line">[root@localhost ~]# /etc/init.d/network restart</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="swig￼450"><p class="p blue large left">配置主机名<sup>(5.2)</sup></p></h2><ul><li><p>查看主机信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230109194319798.png" alt="image-20230109194319798"></p></li><li><p>修改主机名 <code>/etc/hostname</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/hostname</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">[root@localhost ~]# hostnamectl set-hostname newname</span><br></pre></td></tr></table></figure></li><li><p>主机名查询静态表 <code>/etc/hosts</code> 格式为：</p><blockquote><p>ip地址 主机名</p></blockquote><p>Windows 下：（由于权限较高只能替换，不能直接修改）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230111213715761.png" alt="image-20230111213715761"></p></li></ul><h2 id="swig￼451"><p class="p blue large left">防火墙<sup>(5.2)</sup></p></h2><p><a href="#firewall">Ctrl+点击请跳转到 6.6 firewall</a></p><ul><li><p>工作环境常用：</p><p><font style="color:orange;background:red"><strong>警告：打开防火墙后一定要先添加ssh端口到规则中，并重新载入</strong></font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>仅指定 ip:port 访问：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ywd1992/article/details/80401630">参考文章</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eg. 仅指定ip可以访问80端口</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.0.200&quot; port protocol=&quot;tcp&quot; port=&quot;80&quot; reject&quot;</span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.0.200&quot; port protocol=&quot;tcp&quot; port=&quot;80&quot; accept&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-3-Seliunx">5.3 Seliunx</h2><p>Linux被认为是当今最安全的操作系统之一，这是因为它杰出的安全特性，如SELinux(安全增强的Linux)。</p><p>对于初学者，SELinux被描述为在内核中执行的强制访问控制(MAC)安全结构。SELinux提供了一种强制执行某些安全策略的方法，否则系统管理员将无法有效地实现这些策略。当您安装RHEL/CentOS或其他衍生工具时，SELinux服务是默认启用的，因此您系统上的一些应用程序可能不支持这种安全机制。因此，要使此类应用程序正常运行，必须禁用或关闭SELinux。</p><p><strong>SELinux一共有3种状态，分别是Enforcing，Permissive和Disabled状态</strong>。第一种是默认状态，表示强制启用，第二种是宽容的意思，即大部分规则都放行。第三种是禁用，即不设置任何规则。只能通过setenforce命令来设置前面两种状态，而如果想修改为disable状态，需要修改配置文件，同时重启系统。</p><ul><li><p>查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sestatus</span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure></li><li><p>临时禁用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /selinux/enforce</span><br><span class="line">setenforce 0</span><br><span class="line">setenforce Permissive</span><br></pre></td></tr></table></figure></li><li><p>永久禁用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line"></span><br><span class="line"><span class="comment">#将配置SELinux=enforcing改为SELinux=disabled</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>保存退出后使配置生效，需要重新启动系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  getenforce</span><br><span class="line">  reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;% p cyan huge center, 软件安装&lt;sup&gt;(6)&lt;/sup&gt; %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## &#123;% p blue large left, 软件包&lt;sup&gt;(6.1)&lt;/sup&gt; %&#125;</span></span><br><span class="line"></span><br><span class="line">Linux下的软件包众多，且几乎都是经 GPL 授权、免费开源（无偿公开源代码）的。这意味着如果你具备修改软件源代码的能力，只要你愿意，可以随意修改。</span><br><span class="line"></span><br><span class="line">&gt; GPL，全称 General Public License，中文名称“通用性公开许可证”，简单理解 GPL 就是一个保护软件自由的一个协议，经 GPL 协议授权的软件必须开源。</span><br><span class="line"></span><br><span class="line">Linux下的软件包可细分为两种，分别是源码包和二进制包。</span><br><span class="line"></span><br><span class="line">* Linux源码包</span><br><span class="line"></span><br><span class="line">  实际上，源码包就是一大堆源代码程序，是由程序员按照特定的格式和语法编写出来的。</span><br><span class="line"></span><br><span class="line">  我们都知道，计算机只能识别机器语言，也就是二进制语言，所以源码包的安装需要一名“翻译官”将“abcd”翻译成二进制语言，这名“翻译官”通常被称为编译器。</span><br><span class="line"></span><br><span class="line">  虽然源码包免费开源，但用户不会编程怎么办？一大堆源代码程序不会使用怎么办？源码包容易安装吗？等等这些都是使用源码包安装方式无法解答的问题。</span><br><span class="line"></span><br><span class="line">  另外，由于源码包的安装需要把源代码编译为二进制代码，因此安装时间较长。比如，大家应该都在 Windows下安装过 QQ，QQ 功能较多，程序相对较大（有 70 MB左右），但由于其并非是以源码包的形式发布，而是编译后才发布的，因此只需几分钟（经过简单的配置）即可安装成功。但如果我们以源码包安装的方式在 Linux 中安装一个 MySQL 数据库，即便此软件的压缩包仅有 23 MB左右，也需要 30 分钟左右的时间（根据硬件配置不同，略有差异）。</span><br><span class="line"></span><br><span class="line">  通过对比你会发现，源码包的编译是很费时间的，况且绝多大数用户并不熟悉程序语言，在安装过程中我们只能祈祷程序不要报错，否则初学者很难解决。</span><br><span class="line"></span><br><span class="line">  为了解决使用源码包安装方式的这些问题，Linux 软件包的安装出现了使用二进制包的安装方式。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* Linux二进制包</span><br><span class="line"></span><br><span class="line">  二进制包，也就是源码包经过成功编译之后产生的包。由于二进制包在发布之前就已经完成了编译的工作，因此用户安装软件的速度较快（同 Windows下安装软件速度相当），且安装过程报错几率大大减小。</span><br><span class="line"></span><br><span class="line">  二进制包是 Linux 下默认的软件安装包，因此二进制包又被称为默认安装软件包。目前主要有以下 2 大主流的二进制包管理系统：</span><br><span class="line"></span><br><span class="line">  - RPM 包管理系统：功能强大，安装、升级、査询和卸载非常简单方便，因此很多 Linux 发行版都默认使用此机制作为软件安装的管理方式，例如 Fedora、CentOS、SuSE 等。</span><br><span class="line">  - DPKG 包管理系统：由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## &#123;% p blue large left, RPM包&lt;sup&gt;(6.1)&lt;/sup&gt; %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### RPM包统一命名规则&lt;sup&gt;(6.1.1)&lt;/sup&gt;</span></span><br><span class="line"></span><br><span class="line">RPM 二进制包的命名需遵守统一的命名规则，用户通过名称就可以直接获取这类包的版本、适用平台等信息。</span><br><span class="line"></span><br><span class="line">RPM 二进制包命名的一般格式如下：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">包名-版本号-发布次数-发行商-Linux平台-适合的硬件平台-包扩展名</span><br></pre></td></tr></table></figure></li></ul><p>例如，RPM 包的名称是<code>httpd-2.2.15-15.el6.centos.1.i686.rpm</code>，其中：</p><ul><li><p>httped：软件包名。这里需要注意，httped 是包名，而 httpd-2.2.15-15.el6.centos.1.i686.rpm 通常称为包全名，包名和包全名是不同的，在某些 Linux 命令中，有些命令（如包的安装和升级）使用的是包全名，而有些命令（包的查询和卸载）使用的是包名，一不小心就会弄错。</p></li><li><p>2.2.15：包的版本号，版本号的格式通常为<code>主版本号.次版本号.修正号</code>。</p></li><li><p>15：二进制包发布的次数，表示此 RPM 包是第几次编程生成的。</p></li><li><p>el*：软件发行商，el6 表示此包是由 Red Hat 公司发布，适合在 RHEL 6.x (Red Hat Enterprise Unux) 和 CentOS 6.x 上使用。</p></li><li><p>centos：表示此包适用于 CentOS 系统。</p></li><li><p>i686：表示此包使用的硬件平台，目前的 RPM 包支持的平台如表所示：</p><table><thead><tr><th>平台名称</th><th>适用平台信息</th></tr></thead><tbody><tr><td>i386</td><td>386 以上的计算机都可以安装</td></tr><tr><td>i586</td><td>686 以上的计算机都可以安装</td></tr><tr><td>i686</td><td>奔腾 II 以上的计算机都可以安装，目前所有的 CPU 是奔腾 II 以上的，所以这个软件版本居多</td></tr><tr><td>x86_64</td><td>64 位 CPU 可以安装</td></tr><tr><td>noarch</td><td>没有硬件限制</td></tr></tbody></table></li><li><p>rpm：RPM 包的扩展名，表明这是编译好的二进制包，可以使用 rpm 命令直接安装。此外，还有以 src.rpm 作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 rpm 格式的包，最后才能使用 rpm 命令进行安装。</p></li></ul><p>Linux 系统不靠扩展名分区文件类型，那为什么包全名中要包含 .rpm 扩展名呢？其实，这里的扩展名是为系统管理员准备的，如果我们不对 RPM 包标注扩展名，管理员很难知道这是一个 RPM 包，当然也就无法正确使用。</p><h3 id="RPM包安装、卸载和升级-sup-6-1-2-sup">RPM包安装、卸载和升级<sup>(6.1.2)</sup></h3><p>我们以安装 apache 程序为例。因为后续章节还会介绍使用源码包的方式安装 apache 程序，读者可以直观地感受到源码包和 RPM 包的区别。</p><ul><li><p><strong>RPM包默认安装路径</strong></p><p>通常情况下，RPM 包采用系统默认的安装路径，所有安装文件会按照类别分散安装到下表所示的目录中：</p><table><thead><tr><th>安装路径</th><th>含 义</th></tr></thead><tbody><tr><td>/etc/</td><td>配置文件安装目录</td></tr><tr><td>/usr/bin/</td><td>可执行的命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序所使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man/</td><td>帮助文件保存位置</td></tr></tbody></table><p>RPM 包的默认安装路径是可以通过命令查询的。</p><p>除此之外，RPM 包也支持手动指定安装路径，但此方式并不推荐。因为一旦手动指定安装路径，所有的安装文件会集中安装到指定位置，且系统中用来查询安装路径的命令也无法使用（需要进行手工配置才能被系统识别），得不偿失。</p><p>与 RPM 包不同，源码包的安装通常采用手动指定安装路径（习惯安装到 /usr/local/ 中）的方式。既然安装路径不同，同一 apache 程序的源码包和 RPM 包就可以安装到一台 Linux 服务器上（但同一时间只能开启一个，因为它们需要占用同一个 80 端口）。</p><p>实际情况中，一台服务器几乎不会同时包含两个 apache 程序，管理员不好管理，还会占用过多的服务器磁盘空间。</p></li><li><p><strong>RPM 包的安装</strong></p><p>安装 RPM 的命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm [options] 包全名</span><br></pre></td></tr></table></figure><p>注意一定是包全名。涉及到包全名的命令，一定要注意路径，可能软件包在光盘中，因此需提前做好设备的挂载工作。</p><ul><li><p>选项参数的含义为：</p><table><thead><tr><th>x选项</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>安装（install）</td></tr><tr><td>-v</td><td>显示更详细的信息（verbose）</td></tr><tr><td>-h</td><td>打印 #，显示安装进度（hash)</td></tr><tr><td>-e</td><td>卸载，也就是 erase 的首字母</td></tr><tr><td>-U</td><td>（大写）如果该软件没安装过则直接安装；若没安装则升级至最新版本</td></tr><tr><td>-F</td><td>（大写）如果该软件没有安装，则不会安装，必须安装有较低版本才能升级</td></tr><tr><td>–nodeps</td><td>不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。<br>如果不管依赖性，想强制安装，则可以使用这个选项。注意，这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做</td></tr><tr><td>–replacefiles</td><td>替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报&quot;某个文件已经存在&quot;的错误，<br>从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装</td></tr><tr><td>–replacepkgs</td><td>替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍</td></tr><tr><td>–force</td><td>强制安装。不管是否已经安装，都重新安装。也就是 -replacefiles 和 -replacepkgs 的综合</td></tr><tr><td>–test</td><td>测试安装。不会实际安装，只是检测一下依赖性</td></tr><tr><td>–prefix</td><td>指定安装路径。为安装软件指定安装路径，而不使用默认安装路径</td></tr></tbody></table></li></ul><p>例如，使用此命令安装 apache 软件包，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ivh \</span><br><span class="line">/mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br><span class="line">Preparing...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###################</span></span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">]</span></span><br><span class="line">1:httpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###################</span></span></span><br><span class="line"><span class="meta prompt_">[100%</span><span class="language-bash">]</span></span><br></pre></td></tr></table></figure><p>注意，直到出现两个 100% 才是真正的安装成功，第一个 100% 仅表示完成了安装准备工作。</p><p>此命令还可以一次性安装多个软件包，仅需将包全名用空格分开即可，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ivh a.rpm b.rpm c.rpm</span><br></pre></td></tr></table></figure><p>1</p></li><li><p><strong>RPM包的升级</strong></p><p>使用如下命令即可实现 RPM 包的升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -Uvh 包全名</span><br></pre></td></tr></table></figure><p>-U（大写）选项的含义是：如果该软件没安装过则直接安装；若没安装则升级至最新版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -Fvh 包全名</span><br></pre></td></tr></table></figure><p>-F（大写）选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。</p></li><li><p><strong>RPM包的卸载</strong></p><p>RPM 软件包的卸载要考虑包之间的依赖性。例如，我们先安装的 httpd 软件包，后安装 httpd 的功能模块 mod_ssl 包，那么在卸载时，就必须先卸载 mod_ssl，然后卸载 httpd，否则会报错。（<em>软件包卸载和拆除大楼是一样的，本来先盖的 2 楼，后盖的 3 楼，那么拆楼时一定要先拆除 3 楼。</em>）</p><p>如果卸载 RPM 软件不考虑依赖性，执行卸载命令会包依赖性错误，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -e httpd</span><br><span class="line">error: Failed dependencies:</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_wsgi-3.2-1.el6.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) php-5.3.3-3.el6_2.8.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_ssl-1:2.2.15-15.el6.</span><br><span class="line">centos.1.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_perl-2.0.4-10.el6.i686</span><br><span class="line">httpd = 2.2.15-15.el6.centos.1 is needed by (installed) httpd-manual-2.2.</span><br><span class="line">15-15.el6.centos.1 .noarch</span><br><span class="line">httpd is needed by (installed) webalizer-2.21_02-3.3.el6.i686</span><br><span class="line">httpd is needed by (installed) mod_ssl-1:2.2.15-15.el6.centos.1.i686</span><br><span class="line">httpd=0:2.2.15-15.el6.centos.1 is needed by(installed)mod_ssl-1:2.2.15-15.el6.centos.1.i686</span><br></pre></td></tr></table></figure></li></ul><h3 id="RPM命令查询软件包-sup-6-1-2-sup">RPM命令查询软件包<sup>(6.1.2)</sup></h3><p>使用 rpm 做查询命令的格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm [options] 查询对象</span><br></pre></td></tr></table></figure><p>查询对象：绝对路径+包全名</p><ul><li><p>选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-q</td><td>查询软件包是否安装</td></tr><tr><td>-qa</td><td>查询系统中所有安装的软件包</td></tr><tr><td>-qi</td><td>查询软件包的详细信息</td></tr><tr><td>-ql</td><td>查询软件包的文件列表</td></tr><tr><td>-qf</td><td>查询系统文件属于哪个RPM包</td></tr><tr><td>-qR</td><td>查询软件包的依赖关系</td></tr><tr><td>-qRp</td><td>查找未安装软件包的依赖性</td></tr></tbody></table></li></ul><h2 id="6-3-yum源">6.3 yum源</h2><h4 id="6-1-yum-配置">6.1 yum 配置</h4><p>yum，全称“Yellow dog Updater, Modified”，是一个专门为了解决包的依赖关系而存在的软件包管理器。</p><p>可以这么说，yum 是改进型的 RPM 软件管理器，它很好的解决了 RPM 所面临的软件包依赖问题。yum 在服务器端存有所有的 RPM 包，并将各个包之间的依赖关系记录在文件中，当管理员使用 yum 安装 RPM 包时，yum 会先从服务器端下载包的依赖性文件，通过分析此文件从服务器端一次性下载所有相关的 RPM 包并进行安装。</p><p>yum 软件可以用 rpm 命令安装，安装之前可以通过如下命令<strong>查看 yum 是否已安装</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep yum</span><br><span class="line">yum-metadata-parser-1.1.2-16.el6.i686</span><br><span class="line">yum-3.2.29-30.el6.centos.noarch</span><br><span class="line">yum-utils-1.1.30-14.el6.noarch</span><br><span class="line">yum-plugin-fastestmirror-1.1.30-14.el6.noarch</span><br><span class="line">yum-plugin-security-1.1.30-14.el6.noarch</span><br></pre></td></tr></table></figure><p>可以看到，系统上已经安装了 yum 。如果未安装 yum 可查看《<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/e3c78d6483a02a3c4d85f578.html">Linux怎么安装yum</a>》。</p><ul><li><p><strong>网络 yum 源搭建</strong></p><p>一般情况下，只要你的主机网络正常，可以直接使用网络 yum 源，不需要对配置文件做任何修改，这里对 yum 源配置文件做一下简单介绍。</p><p>网络 yum 源配置文件位于 <code>/etc/yum.repos.d/</code> 目录下，文件扩展名为&quot;<em>.repo&quot;（只要扩展名为 &quot;</em>.repo&quot; 的文件都是 yum 源的配置文件）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls /etc/yum.repos.d/</span><br><span class="line">CentOS-Base.repo</span><br><span class="line">CentOS-Media.repo</span><br><span class="line">CentOS-Debuginfo.repo.bak</span><br><span class="line">CentOS-Vault.repo</span><br></pre></td></tr></table></figure><p>可以看到，该目录下有 4 个 yum 配置文件，通常情况下 CentOS-Base.repo 文件生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# vim /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">[base]</span><br><span class="line">name=CentOS-$releasever - Base</span><br><span class="line">mirrorlist=http://mirrorlist.centos.org/? release= $releasever&amp;arch=$basearch&amp;repo=os</span><br><span class="line">baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><blockquote><p>此文件中含有 5 个 yum 源容器，这里只列出了 base 容器，其他容器和 base 容器类似。base 容器中各参数的含义分别为：</p><ul><li>[base]：容器名称，一定要放在[]中。</li><li>name：容器说明，可以自己随便写。</li><li>mirrorlist：镜像站点，这个可以注释掉。</li><li>baseurl：我们的 yum 源服务器的地址。默认是 CentOS 官方的 yum 源服务器，是可以使用的。如果你觉得慢，则可以改成你喜欢的 yum 源地址。</li><li>enabled：此容器是否生效，如果不写或写成 enabled 则表示此容器生效，写成 enable=0 则表示此容器不生效。</li><li>gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。</li><li>gpgkey：数字证书的公钥文件保存位置。不用修改。</li></ul></blockquote></li><li><p><strong>本地 yum 源</strong></p><p>在无法联网的情况下，yum 可以考虑用本地光盘（或安装映像文件）作为 yum 源。</p><p>Linux 系统安装映像文件中就含有常用的 RPM 包，我们可以使用压缩文件打开映像文件（iso文件），进入其 Packages 子目录，如图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Z32P9423J01.gif" alt="安装映像文件的 Packages 子目录"></p><p>可以看到，该子目录下含有几乎所有常用的 RPM 包，因此使用系统安装映像作为本地 yum 源没有任何问题。</p><p>在 <code>/etc/yum.repos.d/</code> 目录下有一个 CentOS-Media.repo 文件，此文件就是以本地光盘作为 yum 源的模板文件，只需进行简单的修改即可，步骤如下：</p><ol><li><p>放入 CentOS 安装光盘，并挂载光盘到指定位置。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/cdrom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建cdrom目录，作为光盘的挂载点</span></span><br><span class="line">[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/</span><br><span class="line">mount: block device/dev/srO is write-protected, mounting read-only</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载光盘到/mnt/cdrom目录下</span></span><br></pre></td></tr></table></figure></li><li><p>修改其他几个 yum 源配置文件的扩展名，让它们失效，因为只有扩展名是&quot;*.repo&quot;的文件才能作为 yum 源配置文件。当也可以删除其他几个 yum 源配置文件，但是如果删除了，当又想用网络作为 yum 源时，就没有了参考文件，所以最好还是修改扩展名。 命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /etc/yum.repos.d/</span><br><span class="line">[root@localhost yum.repos.d]# mv CentOS-Base, repo CentOS-Base.repo.bak</span><br><span class="line">[root@localhost yum.repos.d]#mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak</span><br><span class="line">[root@localhost yum.repos.d]# mv CentOS-Vault.repo CentOS-Vault.repo.bak</span><br></pre></td></tr></table></figure></li><li><p>修改光盘 yum 源配置文件 CentOS-Media.repo，参照以下方修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# vim CentOS-Media.repo</span><br><span class="line">[c6-media]</span><br><span class="line">name=CentOS-$releasever - Media</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">地址为你自己的光盘挂载地址</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">file:///media/cdrom/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">file:///media/cdrecorder/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注释这两个的不存在地址</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把enabled=0改为enabled=1, 让这个yum源配置文件生效</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure><p>如此，本地 yum 源就配置完成了。</p></li></ol></li></ul><h4 id="6-2-更换国内-yum-源">6.2 更换国内 yum 源</h4><ul><li><p>首先备份/etc/yum.repos.d/CentOS-Base.repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>网易（163）yum 源</p><p>下载对应版本 repo 文件, 放入 /etc/yum.repos.d/ (操作前请做好相应备份)</p><ul><li>CentOS5 ：<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a></li><li>CentOS6 ：<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li><li>CentOS7 ：<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">[root@localhost ~]# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br><span class="line">[root@localhost ~]# mv CentOS6-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>运行以下命令生成缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum clean all</span><br><span class="line">[root@localhost ~]# yum makecache</span><br></pre></td></tr></table></figure></li><li><p>中科大的 yum 源，安装方法查看：<a target="_blank" rel="noopener" href="https://lug.ustc.edu.cn/wiki/mirrors/help/centos">https://lug.ustc.edu.cn/wiki/mirrors/help/centos</a></p></li><li><p>sohu 的 yum 源安装方法查看: <a target="_blank" rel="noopener" href="http://mirrors.sohu.com/help/centos.html">http://mirrors.sohu.com/help/centos.html</a></p></li><li><p>aliyun 的 yum 源安装方法查看: <a target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.42931b11xSbXkh">https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.42931b11xSbXkh</a></p></li></ol><h4 id="6-3-yum-命令">6.3 yum 命令</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令（command）</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>check-update</td><td>列出所有可更新的软件清单命令</td></tr><tr><td>update</td><td>更新所有软件命令</td></tr><tr><td>install &lt;package_name&gt;</td><td>仅安装指定的软件命令</td></tr><tr><td>update &lt;package_name&gt;</td><td>仅更新指定的软件命令</td></tr><tr><td>remove &lt;package_name&gt;</td><td>删除软件包命令</td></tr><tr><td>list [package_name]</td><td>查询所有已安装和可安装的软件包<br>[package_name] 查询执行软件包的安装情况</td></tr><tr><td>search<keyword></keyword></td><td>查找软件包命令</td></tr><tr><td>info &lt;package_name&gt;</td><td>查询执行软件包的详细信息</td></tr><tr><td>clean packages</td><td>清除缓存目录下的软件包</td></tr><tr><td>clean header</td><td>清除缓存目录下的 headers</td></tr><tr><td>clean oldheaders</td><td>清除缓存目录下旧的 headers</td></tr><tr><td>clean 或 clean all (= yum clean packages; yum clean oldheaders)</td><td>清除缓存目录下的软件包及旧的 headers</td></tr></tbody></table></li><li><p>选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>当安装过程提示选择全部为 “yes”</td></tr><tr><td><code>-q</code></td><td>不显示安装的过程</td></tr></tbody></table></li></ul><h2 id="7）系统管理">7）系统管理</h2><p><strong>计算机中，一个正在执行的程序或命令，被叫做“进程”（process）。</strong></p><p><strong>启动之后一直存在、常驻内存的进程，被称作“服务”（service）。</strong></p><h3 id="6-1-service-OS6">6.1 service (OS6)</h3><p>服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，因此我们又称为守护进程。</p><p>service 指令管理的服务在 <code>/etc/init.d</code> 查看。</p><p><strong>在CentOS7.0后很多服务不再使用<code>service</code>，而是<code>systemctl</code>。</strong></p><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service 服务名 [start | stop | restart | status]</span><br></pre></td></tr></table></figure></li><li><p>配置 service 服务（以tomcat的服务为例）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/init.d/tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: Tomcat8 Start Stop Restart</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">processname: tomcat8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">chkconfig: 345 99 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CATALINA_HOME=/usr/local/tomcat8</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">        start)</span><br><span class="line">                sh $CATALINA_HOME/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        stop)</span><br><span class="line">                sh $CATALINA_HOME/bin/shutdown.sh</span><br><span class="line">                ;;</span><br><span class="line">        restart)</span><br><span class="line">                sh $CATALINA_HOME/bin/shutdown.sh</span><br><span class="line">                sh $CATALINA_HOME/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo &#x27;please use : tomcat &#123;start | stop | restart&#125;&#x27;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# chmod 755 /etc/init.d/tomcat</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-2-systemctl-OS7">6.2 systemctl (OS7)</h3><p>systemctl指令管理的服务在 <code>/usr/lib/systemd/system</code> 查看</p><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl [start|stop|restart|status] 服务名</span><br></pre></td></tr></table></figure></li><li><p>服务管理命令</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><span style="background:#ff0"><strong>systemctl start 服务名</strong></span></td><td><strong>开启服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl stop 服务名</strong></span></td><td><strong>关闭服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl status 服务名</strong></span></td><td><strong>显示状态</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl restart 服务名</strong></span></td><td><strong>重启服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl enable 服务名</strong></span></td><td><strong>开机启动服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl disable 服务名</strong></span></td><td><strong>禁止开机启动</strong></td></tr><tr><td>systemctl list-units</td><td>查看系统中所有正在运行的服务</td></tr><tr><td>systemctl list-unit-files</td><td>查看系统中所有服务的开机启动状态</td></tr><tr><td>systemctl list-dependencies 服务名</td><td>查看系统中服务的依赖关系</td></tr><tr><td>systemctl mask 服务名</td><td>冻结服务</td></tr><tr><td>systemctl unmask 服务名</td><td>解冻服务</td></tr><tr><td>systemctl set-default multi-user.target</td><td>开机时不启动图形界面</td></tr><tr><td>systemctl set-default graphical.target</td><td>开机时启动图形界面</td></tr><tr><td><span style="background:#ff0"><strong>systemctl daemon-reload</strong></span></td><td><strong>修改服务配置文件后，重新载入</strong></td></tr></tbody></table></li><li><p>配置 systemctl 服务</p><p>systemctl 配置文件存放在 <code>/usr/lib/systemd/system/</code>（以nginx的服务为例）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# systemctl cat nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/lib/systemd/system/nginx.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server	# 注释、描述</span><br><span class="line">Documentation=http://nginx.org/en/docs/	# 帮助或文档</span><br><span class="line">After=network-online.target remote-fs.target nss-lookup.target	# 核心 nginx在这些服务后才能执行（依赖）</span><br><span class="line">Wants=network-online.target	# 依赖</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking	# 服务类型</span><br><span class="line">PIDFile=/var/run/nginx.pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Environment=<span class="string">&quot;&quot;</span> <span class="comment"># 环境</span></span></span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf	# 服务启动</span><br><span class="line">ExecReload=/bin/sh -c &quot;/bin/kill -s HUP $(/bin/cat /var/run/nginx.pid)&quot;	# 服务重启</span><br><span class="line">ExecStop=/bin/sh -c &quot;/bin/kill -s TERM $(/bin/cat /var/run/nginx.pid)&quot;	# 服务关闭</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target	# 指定运行级别</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-3-服务运行级别">6.3 服务运行级别</h3><ul><li><p>Linux系统有7种运行级别（runlevel）：==常用的是级别3和5==<br>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则无法正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录运行级别2：多用户状态（没有NFS），不支持网络<br>==运行级别3：完全的多用户状态（有NFS），无界面，登录后进入控制台命令行模式==<br>运行级别4：系统未使用，保留<br>==运行级别5：X11控制台，登录后进入图形GUI模式==<br>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</p></li><li><p>使用init控制</p><p>查看默认级别 <code>vim /etc/inittab</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关机</span></span><br><span class="line">init 0</span><br></pre></td></tr></table></figure></li><li><p>开机流程</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/Snipaste_2022-12-11_22-53-14.png" alt="Snipaste_2022-12-11_22-53-14"></p></li></ul><ul><li><p>运行级别操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前默认运行级别</span></span><br><span class="line">[root@localhost ~]# systemctl get-default</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改默认运行级别</span></span><br><span class="line">[root@localhost ~]# systemctl set-default TARGET.target</span><br></pre></td></tr></table></figure><blockquote><p>CentOS7后运行级别简化，如下：</p><p>multi-user.target # 等价于原运行级别3（多用户有网，无图形界面）</p><p>graphical.target # 等价于原运行级别5（多用户有网，有图形界面）</p></blockquote></li></ul><h3 id="6-4-chkconfig-OS6">6.4 chkconfig (OS6)</h3><p>通过chkconfig命令可以给服务的各个运行级别设置自启动/关闭。CentOS7.0后，很多服务使用systemctl管理。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有服务运行级别</span></span><br><span class="line">[root@localhost ~]# chkconfig --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看某个服务运行级别</span></span><br><span class="line">[root@localhost ~]# chkconfig 服务名 --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整某服务对应的运行级别自启动开启或关闭</span></span><br><span class="line">[root@localhost ~]# chkconfig --level 3 服务名 on/off</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/niiuu/images/raw/master/article_images/typora_images/image-20230109204139909.png" alt="image-20230109204139909"></p><p>chkconfig 重新设置服务后自启动或关闭，需要重启机器reboot生效。</p></li></ul><h3 id="6-5-关机重启命令">6.5 关机重启命令</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>sync</td><td>将数据从内存同步到硬盘</td></tr><tr><td>halt</td><td>停机，关闭系统，但不断电</td></tr><tr><td>poweroff</td><td>关机，断电</td></tr><tr><td>reboot</td><td>重启，同shutdown-r now</td></tr><tr><td>shutdown [选项] 时间</td><td>选项：-H（相当于—halt，默认于1分钟后进行）<br>-r（相当于reboot）<br>-c 取消</td></tr></tbody></table><h3 id="6-6-iptables（OS6）">6.6 iptables（OS6）</h3><p>配置文件在<code>/etc/sysconfig/iptables</code></p><h3 id="6-7-span-id-firewall-firewall-span-（0S7）">6.7 <span id="firewall">firewall</span>（0S7）</h3><p>在真正是生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。</p><p>CentOS7采用新的firewalld，CentOS6及以前版本采用iptables，不过firewalld底层仍然调用的是iptables</p><p>firewalld 配置文件在 <code>/etc/firewalld</code> 和 <code>/usr/lib/firewalld</code>。如果名称相同的配置文件同时存储 在两个位置中，则将使用 <code>/etc/firewalld</code> 中的版本。</p><ul><li><p><span style="color:orange;background:red"><strong>警告：打开防火墙后一定要先添加ssh端口到规则中，并重新载入</strong></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --zone=public --add-port=22/tcp --permanent</span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开端口</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --permanet --add-port=端口号/协议</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭端口</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --permanent --remove-port=端口号/协议</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新载入，才能生效</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询端口是否开放：</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --query-port=端口/协议</span><br></pre></td></tr></table></figure><blockquote><p>firewall-cmd 可以执行 firewall-config 能够执行的相同操作。在使用 firewall-cmd 命令时，如果未指定–permanent 选项，则所有命令都作用于运行时配置。–zone=用来指定所 影响的区域，如果未指定–zone=参数，则将使用默认区域。配置防火墙时，管理员如果使用–permanent 参数更改配置，则需要使用 firewall-cmd --reload 来使更改生效，如果更改可能诱发危险，则可以不指定–permannent 参数，使更改 仅在运行状态下生效。如果需要指定某些更改在一定的时间后自动删除，从而防止意外锁定 某个系统，可以使用–timeout=</p></blockquote></li><li><p><strong>查询</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询已开放的端口（已开放的端口号集合）</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询已开放的端口 (可以具体查看某一个端口号)</span></span><br><span class="line">[root@localhost ~]# netstat -ntulp | grep 端口号</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询指定端口是否已开 (提示 <span class="built_in">yes</span>，表示开启；no表示未开启)</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --query-port=端口/协议</span><br></pre></td></tr></table></figure></li><li><p><strong>firewall区域介绍</strong></p><blockquote><p>firewalld防火墙为了简化管理，将所有网络流量分为多个区域（zone）。然后根据数据包的源IP地址或传入的网络接口等条件将流量传入相应区域，每个区域都定义了自己打开或者关闭的端口和服务列表。</p><ul><li><p>区域（zone）是针对特定位置或场景（例如家庭、公共、受信任等）可能具有的各种信任级别的规则集。</p></li><li><p>不同的区域（zone）可允许不同的网络服务和入站流量的类型，而拒绝其他任何流量。</p></li></ul></blockquote><blockquote><p>firewalld的9个区域</p><ul><li>public(公共) —— [默认]公网访问，不受任何限制。</li><li>work(工作) —— 用于工作区。基本信任的网络，仅仅接收经过选择的连接。</li><li>home(家庭) —— 用于家庭网络。基本信任的网络，仅仅接收经过选择的连接。</li><li>trusted(信任) —— 接收的外部网络连接是可信任、可接受的。</li><li>block(限制) —— 任何接收的网络连接都被IPv4的icmp-host-prohibited信息和IPv6的icmp6-adm-prohibited信息所拒绝。</li><li>dmz(隔离区) —— 英文&quot;demilitarized zone&quot;的缩写，此区域内可公开访问，它是非安全系统与安全系统之间的缓冲区。</li><li>drop(丢弃) —— 任何接收的网络数据包都被丢弃，没有任何回复。仅能有发送出去的网络连接。</li><li>external(外部) —— 允许指定的外部网络进入连接，特别是为路由器启用了伪装功能的外部网。</li><li>internal(内部) —— 内部访问。只限于本地访问，其他不能访问。</li></ul></blockquote></li><li><p>修改规则文件，实现防火墙规则</p><p><code>vi /etc/firewalld/zones/public.xml</code></p></li><li><p><strong>firewalld 服务</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动防火墙</span></span><br><span class="line">[root@localhost ~]# systemctl start firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">[root@localhost ~]# systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防火墙开机启动</span></span><br><span class="line">[root@localhost ~]# systemctl enable firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙开机启动</span></span><br><span class="line">[root@localhost ~]# systemctl disable firewalld</span><br></pre></td></tr></table></figure></li></ul><h2 id="8）快捷键">8）快捷键</h2><ul><li><p><strong>linux常用的快捷键</strong></p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>补全命令或显示所有可选项</td></tr><tr><td>Ctrl + Alt + T</td><td>打开当前页面的终端。</td></tr><tr><td>Ctrl + Shift + [+]</td><td>放大终端</td></tr><tr><td>Ctrl + [-]</td><td>缩小终端</td></tr><tr><td>Ctrl + a</td><td>使光标快速到行首</td></tr><tr><td>Ctrl + e</td><td>光标快速移到行尾</td></tr><tr><td>Ctrl + r</td><td>在历史命令中搜索</td></tr><tr><td>Ctrl + c</td><td>强制终止当前命令</td></tr><tr><td>Ctrl + z</td><td>暂停在终端运行的任务</td></tr><tr><td>Ctrl + l 或者 clear</td><td>清屏</td></tr><tr><td>Ctrl + Shift + f</td><td>查找</td></tr><tr><td>Ctrl + Shift + g</td><td>查找上一个，按回车下一个</td></tr><tr><td>Ctrl + Shift + c</td><td>复制</td></tr><tr><td>Ctrl + Shift + v</td><td>粘贴</td></tr><tr><td>Ctrl + K</td><td>光标所处位置到行末的所有内容 和 ctrl + u对立</td></tr><tr><td>Ctrl + U</td><td>光标所处位置到行首的所有内容 和 ctrl + k对立</td></tr><tr><td>Ctrl + W</td><td>光标所处位置之前的一个词，以空格、标点为界</td></tr><tr><td>Alt + F4</td><td>关闭当前窗口</td></tr><tr><td>Shift + PgUp</td><td>向上翻页</td></tr><tr><td>Shift + PgUp</td><td>向下翻页</td></tr><tr><td>Alt]+ Tab</td><td>切换不同的程序窗口</td></tr><tr><td>Alt + Shift + Tab</td><td>往回切换</td></tr><tr><td>F11</td><td>使终端全屏，再次按下退出全屏</td></tr><tr><td>[PrtSc]</td><td>获取整个屏幕的截图并保存到Pictures目录</td></tr></tbody></table></li><li><p>linux中不太常用的快捷键</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + t</td><td>交换光标位置前的两个字符</td></tr><tr><td>Ctrl + y</td><td>粘贴最后一次被删除的单词</td></tr><tr><td>Ctrl + z</td><td>把命令放入后台</td></tr><tr><td>Alt + b</td><td>光标往回移动到前一个单词</td></tr><tr><td>Alt + d</td><td>删除从光标位置到当前所处单词的末尾</td></tr><tr><td>Alt + F1</td><td>访问菜单</td></tr><tr><td>Alt + F2</td><td>运行</td></tr><tr><td>Alt + F10</td><td>最大化当前窗口，再次缩小</td></tr><tr><td>Ctrl + Alt + F2</td><td>切换到文本终端，也可以通过命令chvt n 来实现。如果你希望知道终端的名字，可以使用命令fgconsole</td></tr><tr><td>Ctrl + Alt + F1</td><td>从文本终端切换到图形用户界面</td></tr><tr><td>Ctrl + Alt + Delete</td><td>在文本终端下使用时强制重启</td></tr><tr><td>Shift + PrtSc</td><td>获取屏幕的某个区域截图并保存到Pictures目录</td></tr><tr><td>Alt + PrtS]</td><td>获取 当前窗口的截图并保存到Pictures目录</td></tr><tr><td>Ctrl + PrtSc</td><td>获取整个屏幕的截图并存放到剪贴板</td></tr><tr><td>Shift + Ctrl + PrtSc</td><td>获取屏幕的某个区域截图并存放到剪贴板</td></tr><tr><td>Ctrl + Alt + PrtSc</td><td>获取当前窗口的截图并存放到剪贴板</td></tr><tr><td>ctrl +f</td><td>光标向右移动一个 等价于小键盘的 &lt;-- 键</td></tr><tr><td>ctrl +b</td><td>光标向左移动一个 等价于小键盘的 --&gt; 键</td></tr><tr><td>ctrl +d</td><td>退出当前登录，等同于exit logout；如果在当前使用了ssh远程其他机器，改指令会退回当前奇迹</td></tr><tr><td>ctrl + h</td><td>向前退格，等价于backspace</td></tr><tr><td>ctrl + p</td><td>显示上一条指令 等价于小键盘 ↑</td></tr><tr><td>ctrl + n</td><td>显示下一条指令 等价于小键盘 ↓</td></tr><tr><td>ctrl + s</td><td>锁定终端，使任何人不允许输入，但是输入操作会记录</td></tr><tr><td>ctrl + q</td><td>解除ctrl +s的锁定，同时会展示或执行ctrl +s锁定时输入的指令</td></tr></tbody></table></li></ul><h2 id="8）命令">8）命令</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令大全（runoob.com）</a></p><h3 id="8-1-帮助">8.1 帮助</h3><h4 id="8-1-1-man-获得帮助信息">8.1.1 man 获得帮助信息</h4><p>man命令是Linux下最核心的命令之一。而man命令也并不是英文单词“man”的意思，它是单词manual的缩写，即使用手册的意思。</p><p>man命令会列出一份完整的说明。 其内容包括命令语法、各选项的意义及相关命令 。更为强大的是，不仅可以查看Linux中命令的使用帮助，还可以查看软件服务配置文件、系统调用、库函数等帮助信息。</p><p>man手册页文件存放在/usr/share/man目录下。</p><ul><li><p><strong>基本语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# man [命令或配置文件]</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>在所有的man帮助手册中搜索</td></tr><tr><td>-d</td><td>主要用于检查，如果用户加入了一个新的文件，就可以用这个参数检查是否出错</td></tr><tr><td>-f</td><td>显示给定关键字的简短描述信息</td></tr><tr><td>-p</td><td>指定内容时使用分页程序</td></tr><tr><td>-M</td><td>指定man手册搜索的路径</td></tr><tr><td>-w</td><td>显示文件所在位置</td></tr></tbody></table></li><li><p><strong>快捷键</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>q</td><td>退出</td></tr><tr><td>Enter</td><td>按行下翻</td></tr><tr><td>Space</td><td>按页下翻</td></tr><tr><td>b</td><td>上翻一页</td></tr><tr><td>/字符串</td><td>在手册页中查找字符串</td></tr></tbody></table></li></ul><h4 id="8-1-2-help-获得shell内置命令的帮助信息">8.1.2 help 获得shell内置命令的帮助信息</h4><p>一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）”命令；响应的其他命令被称为“外部命令”。</p><ul><li><p><strong>基本语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# help [-dms] 命令</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主要使用</span></span><br><span class="line">[root@localhost ~]# [外部命令] --help    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断命令是否为内置命令</span></span><br><span class="line">[root@localhost ~]# type ls    </span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>输出每个命令的简短描述</td></tr><tr><td><code>-m</code></td><td>以类似于 man 手册的格式描述命令</td></tr><tr><td><code>-m</code></td><td>只显示命令使用格式</td></tr></tbody></table></li></ul><h3 id="8-2-文件和目录管理">8.2 文件和目录管理</h3><h4 id="8-2-1-pwd-显示绝对路径">8.2.1 pwd 显示绝对路径</h4><p>Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pwd [options]</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-L</code>：<code>–logical</code></td><td>显示当前的路径，有连接文件时，直接显示连接文件的路径，(不加参数时默认此方式)</td></tr><tr><td><code>-p</code>：<code>–physical</code></td><td>显示当前的路径，有连接文件时，不使用连接路径，直接显示连接文件所指向的文件。<br>当包含多层连接文件时，显示连接文件最终指向的文件</td></tr><tr><td><code>--help</code></td><td>在线帮助</td></tr><tr><td><code>--version</code></td><td>显示版本信息</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230115161740445.png" alt="image-20230115161740445"></p></li></ul><h4 id="8-2-2-ls-列出目录的内容">8.2.2 ls 列出目录的内容</h4><p>Linux ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</p><p><strong>(隐藏文件夹以<code>.</code>开头)</strong></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls [options] [name]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><span style="color:red">-<strong>a</strong></span></td><td>显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</td></tr><tr><td><span style="color:red">-<strong>l</strong></span></td><td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出（等同于<code>ll</code>）</td></tr><tr><td>-r</td><td>将文件以相反次序显示(原定依英文字母次序)</td></tr><tr><td>-t</td><td>将文件依建立时间之先后次序列出</td></tr><tr><td>-A</td><td>同 -a ，但不列出 “.” (目前目录) 及 “…” (父目录)</td></tr><tr><td>-F</td><td>在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/”</td></tr><tr><td>-R</td><td>若目录下有文件，则以下之文件亦皆依序列出</td></tr><tr><td>-lh</td><td>同-l但是文件的大小会以单位k、m、g等显示</td></tr></tbody></table></li></ul><p>​</p><ul><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230115162714813.png" alt="image-20230115162714813"></p></li></ul><h4 id="8-2-3-cd-切换目录">8.2.3 cd 切换目录</h4><p>Linux cd（英文全拼：change directory）命令用于切换当前工作目录。</p><p>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p><p>另外，<strong>~</strong> 也表示为 home 目录 的意思， <strong>.</strong> 则是表示目前所在的目录， <strong>…</strong> 则表示目前目录位置的上一层目录。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd dirName</span><br></pre></td></tr></table></figure></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116100537862.png" alt="image-20230116100537862"></p></li></ul><h4 id="8-2-4-mkdir-创建一个新的目录">8.2.4 mkdir 创建一个新的目录</h4><p>Linux mkdir（英文全拼：make directory）命令用于创建目录。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir [options] dirName</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归创建目录</span></span><br><span class="line">[root@localhost ~]# mkdir -p xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归创建并设置权限为 drwx-rwx-r-x</span></span><br><span class="line">[root@localhost ~]# mkdir -m 775 -p xxx </span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-p</code>：<code>--parents</code></td><td>如果目录不存在，根据需要创建父级目录</td></tr><tr><td><code>-m</code>：<code>--mode=MODE</code></td><td>设置文件模式(chmod)</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过程</td></tr><tr><td><code>-Z</code></td><td>创建目录的SELinux安全设置为默认类型</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116103530138.png" alt="image-20230116103530138"></p></li></ul><h4 id="8-2-5-rmdir-删除一个空的目录">8.2.5 rmdir 删除一个空的目录</h4><p>Linux rmdir（英文全拼：remove directory）。rmdir 命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意：rm - r dir 命令可代替rmdir，但是有很大危险性）删除某目录时也必须具有对父目录的写权限。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rmdir [options] dirName</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rmdir -p xxx</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>-p</code>：<code>--parents</code></td><td>删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除</td></tr><tr><td><code>--ignore-fail-on-non-empty</code></td><td>忽略非空目录的错误信息</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过程</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116104246194.png" alt="image-20230116104246194"></p></li></ul><h4 id="8-2-6-touch-创建空文件">8.2.6 touch 创建空文件</h4><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch [options] fileName</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>只更改访问时间</td></tr><tr><td><code>-c</code>：<code>--no-create</code></td><td>不创建任何文件</td></tr><tr><td><code>-d</code>：<code>--date=字符串</code></td><td>使用指定字符串表示时间而非当前时间</td></tr><tr><td><code>-h</code>：<code>--no-dereference</code></td><td>会影响符号链接本身，而非符号链接所指示的目的地<br>(当系统支持更改符号链接的所有者时，此选项才有用)</td></tr><tr><td><code>-m</code></td><td>只更改修改时间</td></tr><tr><td><code>-r</code>：<code>--reference=FILE</code></td><td>使用file文件的时间戳（access、modify）更新文件的时间戳</td></tr><tr><td><code>-t</code></td><td>设定档案的时间记录，格式与 date 指令相同</td></tr><tr><td><code>--help</code></td><td>显示此帮助信息并退出</td></tr><tr><td><code>--version</code></td><td>显示版本信息并退出</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116110047556.png" alt="image-20230116110047556"></p></li></ul><h4 id="8-2-7-cp-复制文件或目录">8.2.7 cp 复制文件或目录</h4><p>Linux cp（英文全拼：copy file）命令主要用于复制文件或目录。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp [options] source directory</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归拷贝（就是将目录和目录下的所有子文件夹都拷贝过去）</span></span><br><span class="line">[root@localhost ~]# cp -r 拷贝的文件 拷贝到的路径    </span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>相当于 <code>-pdr</code> ，此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容</td></tr><tr><td><code>-d</code></td><td>复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式</td></tr><tr><td><code>-f</code></td><td>覆盖已经存在的目标文件而不给出提示</td></tr><tr><td><code>-i</code></td><td>与 <strong>f</strong> 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 <strong>y</strong> 时目标文件将被覆盖</td></tr><tr><td><code>-p</code></td><td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td><strong><code>-r</code></strong></td><td>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</td></tr><tr><td><code>-l</code></td><td>不复制文件，只是生成链接文件</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116112837632.png" alt="image-20230116112837632"></p></li></ul><h4 id="8-2-8-rm-删除文件或目录">8.2.8 rm 删除文件或目录</h4><p>Linux rm（英文全拼：remove）命令用于删除一个文件或者目录。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm [options] name</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归删除目录及文件或文件不提示信息</span></span><br><span class="line">[root@localhost ~]# rm -rf 文件名[路径]</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-f</code></td><td>忽略不存在的文件和参数，不要提示</td></tr><tr><td><code>-i</code></td><td>每次删除前都会提示</td></tr><tr><td><strong><code>-r</code></strong></td><td>递归地删除目录及其内容</td></tr><tr><td><code>-d</code></td><td>删除空目录</td></tr><tr><td><code>-v</code></td><td>列出详细信息</td></tr><tr><td><code>--help</code></td><td>帮助</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116113749497.png" alt="image-20230116113749497"></p></li></ul><h4 id="8-2-9-mv-移动文件与目录或重命名">8.2.9 mv 移动文件与目录或重命名</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv [options] source directory</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th></th></tr></thead><tbody><tr><td><code>-b</code></td><td>目标文件或目录存在时，在执行覆盖前，会为其创建一个备份</td></tr><tr><td><code>-i</code></td><td>如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作</td></tr><tr><td><code>-f</code></td><td>如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件</td></tr><tr><td><code>-n</code></td><td>不要覆盖任何已存在的文件或目录</td></tr><tr><td><code>-u</code></td><td>当源文件比目标文件新或者目标文件不存在时，才执行移动操作</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>将文件 aaa 改名为 bbb :</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116114445282.png" alt="image-20230116114445282"></p></li><li><p>将 info 目录放入 logs 目录中。注意，如果 logs 目录不存在，则该命令将 info 改名为 logs:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116114951414.png" alt="image-20230116114951414"></p></li></ol></li></ul><h4 id="8-2-13-ln-建立一个同步的链接">8.2.13 ln 建立一个同步的链接</h4><p>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p><strong>命令功能</strong> :Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p><p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ln [optians] 源目录或目录 目标文件或目录</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">建立软链接</span></span><br><span class="line">[root@localhost ~]# ln -s 源目录或目录 目标文件或目录</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-b</code>：<code>--backup</code></td><td>删除，覆盖目标文件之前的备份。</td></tr><tr><td><code>-d</code>：<code>-F</code>或<code>--directory</code></td><td>建立目录的硬连接。</td></tr><tr><td><code>-f</code>：<code>--force</code></td><td>强行建立文件或目录的连接，不论文件或目录是否存在。</td></tr><tr><td><code>-i</code>：<code>--interactive</code></td><td>覆盖既有文件之前先询问用户。</td></tr><tr><td><code>-n</code>：<code>--no-dereference</code></td><td>把符号连接的目的目录视为一般文件。</td></tr><tr><td><code>-s</code>：<code>--symbolic</code></td><td>对源文件建立软链接(符号连接)，而非硬连接。</td></tr><tr><td><code>-S&lt;字尾备份字符串&gt;</code>：<code>--suffix=&lt;字尾备份字符串&gt;</code></td><td>用&quot;-b&quot;参数备份目标文件后，<br>备份文件的字尾会被加上一个备份字符串，<br>预设的字尾备份字符串是符号&quot;~“，可通过”-S&quot;参数来改变它。</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过程。</td></tr><tr><td><code>-V&lt;备份方式&gt;</code>：<code>--version-control=&lt;备份方式&gt;</code></td><td>用&quot;-b&quot;参数备份目标文件后，<br>备份文件的字尾会被加上一个备份字符串，<br>这个字符串不仅可用&quot;-S&quot;参数变更，当使用&quot;-V&quot;参数&lt;备份方式&gt;<br>指定不同备份方式时，也会产生不同字尾的备份字符串。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116203320934.png" alt="image-20230116203320934"></p></li></ul><h4 id="8-2-14-scp-安全拷贝">8.2.14 scp 安全拷贝</h4><p>secure copy (remote file copy program)，意思安全拷贝，安全复制的意思，是一个远程文件复制程序。准确来说就是不同服务器之间进行文件（包括目录）进行安全复制的命令。scp基于加州大学Regents的BSD源代码中的rcp程序。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# scp [option] /path/to/source/file user@server-ip:/path/to/destination/directory</span><br></pre></td></tr></table></figure><blockquote><p><code>/path/to/source/file</code> – 这是打算复制到远程主机的源文件。</p><p><code>user@server-IP:</code> – 这是远程系统的用户名和 IP 地址。请注意 <strong>IP 地址后面加冒号</strong>。</p><p><code>/path/to/destination/directory</code> – 这是文件将复制到的远程系统上的目标目录。</p></blockquote></li><li><p><strong>选项</strong></p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-C</td><td style="text-align:center">这会在复制过程中压缩文件或目录。</td></tr><tr><td style="text-align:center">-P</td><td style="text-align:center">如果默认 SSH 端口不是 22，则使用此选项指定 SSH 端口。</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">此选项递归复制目录及其内容。</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">保留文件的访问和修改时间。</td></tr></tbody></table></li></ul><h3 id="8-3-文本处理">8.3 文本处理</h3><h4 id="8-3-1-cat-查看文件内容">8.3.1 cat 查看文件内容</h4><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat [options] fileName</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出行号</span></span><br><span class="line">cat -n 文件名</span><br></pre></td></tr></table></figure></li><li><p>选项</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-A</code>：<code>--show-all</code>：<code>-vET</code></td><td>相当于 -vET 选项的整合，用于列出所有隐藏符号；</td></tr><tr><td><code>-E</code>：<code>--show-ends</code></td><td>列出每行结尾的回车符 $；</td></tr><tr><td><code>-n</code>：<code>--number</code></td><td>对输出的所有行进行编号；</td></tr><tr><td><code>-b</code>：<code>--number-nonblank</code></td><td>同 -n 不同，此选项表示只对非空行进行编号。</td></tr><tr><td><code>-T</code>：<code>--show-tabs</code></td><td>把 Tab 键 ^I 显示出来；</td></tr><tr><td><code>-V</code></td><td>列出特殊字符；</td></tr><tr><td><code>-s</code>：<code>--squeeze-blank</code></td><td>当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure></li><li><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure></li><li><p>清空 /etc/test.txt 文档内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /dev/null &gt; /etc/test.txt</span><br></pre></td></tr></table></figure></li><li><p>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /dev/fd0 &gt; OUTFILE</span><br></pre></td></tr></table></figure><p>相反的，如果想把 image file 写到软盘，输入：(通常用制作开机磁片)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat IMG_FILE &gt; /dev/fd0</span><br></pre></td></tr></table></figure><ul><li><p>OUTFILE 指输出的镜像文件名。</p></li><li><p>IMG_FILE 指镜像文件。</p></li><li><p>若从镜像文件写回 device 时，device 容量需与相当。</p></li></ul></li></ol></li></ul><h4 id="8-3-2-more-文件内容分屏查看器">8.3.2 more 文件内容分屏查看器</h4><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# more [options] [fileNames..]</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>+n</td><td>从笫n行开始显示</td></tr><tr><td>-n</td><td>定义屏幕显示n行为一屏</td></tr><tr><td>+/字符串</td><td>在每个档案显示前搜寻该字串，然后从该字串前两行之后开始显示</td></tr><tr><td>-c</td><td>先清屏，然后显示要查看的文件或日志内容</td></tr><tr><td>-d</td><td>在显示内空中添加提示 “Press space to continue，’q’ to quit(按空格键继续，按q键退出)”，禁用响铃功能</td></tr><tr><td>-p</td><td>通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</td></tr><tr><td>-s</td><td>把连续的多个空行显示为一行</td></tr><tr><td>-u</td><td>把文件内容中的下画线去掉</td></tr></tbody></table></li><li><p><strong>more查看文件或日志后常用操作命令</strong></p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>Enter</td><td>向下n行。默认为1行</td></tr><tr><td>F键 [空格键]</td><td>向下滚动一屏</td></tr><tr><td>B键</td><td>返回上一屏</td></tr><tr><td>=</td><td>输出当前行的行号</td></tr><tr><td>V键</td><td>在使用more查看时，使用v调用vi编辑器</td></tr><tr><td>!命令</td><td>调用Shell，并执行命令</td></tr><tr><td>q</td><td>退出more</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>在一个目录下的文件，由于内容太多，可以管道 | 结合起来进行分页显示:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116121938713.png" alt="image-20230116121938713"></p><p>1</p></li></ol></li></ul><h4 id="8-3-3-head-显示文件头部内容">8.3.3 head 显示文件头部内容</h4><p>head 命令可用于查看文件的开头部分的内容，<strong>有一个常用的参数 -n 用于显示行数，默认为 10</strong>。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# head [options] fileName</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# head -n 5 fileName</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-q</code></td><td>隐藏文件名</td></tr><tr><td><code>-v</code></td><td>显示文件名</td></tr><tr><td><code>-c 字节数</code></td><td>显示的字节数</td></tr><tr><td><code>-n 行数</code></td><td>显示的行数</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p>默认为显示10行文件内容：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116191108192.png" alt="image-20230116191108192"></p></li></ul><h4 id="8-3-4-less-分屏显示文件内容">8.3.4 less 分屏显示文件内容</h4><p>Linux 中的 less 命令主要用来浏览文件内容，与 more 命令的用法相似，不同于 more 命令的是，less 命令可往回卷动浏览以看过的部分。less 的用法比起 more 更加的有弹性。在 more 的时候,我们并没有办法向前面翻,只能往后面看，但若使用了 less 时，就可以使用 <code>［pageup］</code> <code>［pagedown]</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# less [options] fileName</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-N</td><td>显示每行的行号。</td></tr><tr><td>-S</td><td>行过长时将超出部分舍弃。</td></tr><tr><td>-e</td><td>当文件显示结束后，自动离开。</td></tr><tr><td>-g</td><td>只标志最后搜索到的关键同。</td></tr><tr><td>-Q</td><td>不使用警告音。</td></tr><tr><td>-i</td><td>忽略搜索时的大小写。</td></tr><tr><td>-m</td><td>显示类似 more 命令的百分比。</td></tr><tr><td>-f</td><td>强迫打开特殊文件，比如外围设备代号、目录和二进制文件。</td></tr><tr><td>-s</td><td>显示连续空行为一行。</td></tr><tr><td>-b &lt;缓冲区大小&gt;</td><td>设置缓冲区的大小。</td></tr><tr><td>-o &lt;文件名&gt;</td><td>将 less 输出的内容保存到指定文件中。</td></tr><tr><td>-x &lt;数字&gt;</td><td>将【Tab】键显示为规定的数字空格。</td></tr></tbody></table></li><li><p><strong>操作命令</strong></p><table><thead><tr><th>交互指令</th><th>功能</th></tr></thead><tbody><tr><td>/字符串</td><td>向下搜索“字符串”的功能。</td></tr><tr><td>?字符串</td><td>向上搜索“字符串”的功能。</td></tr><tr><td>n</td><td>重复*前一个搜索（与 / 成 ? 有关）。</td></tr><tr><td>N</td><td>反向重复前一个搜索（与 / 或 ? 有关）。</td></tr><tr><td>b</td><td>向上移动一页。</td></tr><tr><td>d</td><td>向下移动半页。</td></tr><tr><td>h 或 H</td><td>显示帮助界面。</td></tr><tr><td>q 或 Q</td><td>退出 less 命令。</td></tr><tr><td>y</td><td>向上移动一行。</td></tr><tr><td>空格键</td><td>向下移动一页。</td></tr><tr><td>回车键</td><td>向下移动一行。</td></tr><tr><td>【PgDn】键</td><td>向下移动一页。</td></tr><tr><td>【PgUp】键</td><td>向上移动一页。</td></tr><tr><td>Ctrl+f</td><td>向下移动一页。</td></tr><tr><td>Ctrl+b</td><td>向上移动一页。</td></tr><tr><td>Ctrl+d</td><td>向下移动一页。</td></tr><tr><td>Ctrl+u</td><td>向上移动半页。</td></tr><tr><td>j</td><td>向下移动一行。</td></tr><tr><td>k</td><td>向上移动一行。</td></tr><tr><td>G</td><td>移动至最后一行。</td></tr><tr><td>g</td><td>移动到第一行。</td></tr><tr><td>ZZ</td><td>退出 less 命令。</td></tr><tr><td>v</td><td>使用配置的编辑器编辑当前文件。</td></tr><tr><td>[</td><td>移动到本文档的上一个节点。</td></tr><tr><td>]</td><td>移动到本文档的下一个节点。</td></tr><tr><td>p</td><td>移动到同级的上一个节点。</td></tr><tr><td>u</td><td>向上移动半页。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p><code>ps -ef | less</code> 显示已有进程信息</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116172234561.png" alt="image-20230116172234561"></p></li><li><p><code>history | less</code>查看命令历史使用记录</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116172701184.png" alt="image-20230116172701184"></p></li></ol></li></ul><h4 id="8-3-5-tail-输出文件尾部内容">8.3.5 tail 输出文件尾部内容</h4><p>tail 命令可用于查看文件的内容。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail [options] filename</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容</span></span><br><span class="line">[root@localhost ~]# tail -f filename</span><br></pre></td></tr></table></figure></li><li><p>选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-f</code></td><td>循环读取</td></tr><tr><td><code>-q</code></td><td>不显示处理信息</td></tr><tr><td><code>-v</code></td><td>显示详细的处理信息</td></tr><tr><td><code>-c 数目</code></td><td>显示的字节数</td></tr><tr><td><code>-n 行数</code></td><td>显示文件的尾部 n 行内容</td></tr><tr><td><code>--pid=PID</code></td><td>与-f合用,表示在进程ID,PID死掉之后结束</td></tr><tr><td><code>-q</code>：<code>--quiet</code>：<code>--silent</code></td><td>从不输出给出文件名的首部</td></tr><tr><td><code>-s</code>：<code>--sleep-interval=S</code></td><td>与-f合用,表示在每次反复的间隔休眠S秒</td></tr></tbody></table></li><li><p><strong>实例</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116193720678.png" alt="tail"></p></li></ul><h4 id="8-3-6-输出重定向">8.3.6 &gt; &gt;&gt; 输出重定向</h4><p><code>&gt;</code> 覆盖，会覆盖目标的原有内容，当文件存在时，会先删除原文件，再重新创建文件，然后把内容写入该文件，否则直接创建文件。</p><p><code>&gt;&gt;</code> 追加，会在目标原有内容后追加内容，当文件存在时直接在文件末尾进行内容追加，不会删除原文件，否则直接创建文件。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列表的内容写入文件 test.txt 中 （覆盖写）</span></span><br><span class="line">[root@localhost ~]# ls -l &gt; test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列表的内容追加到文本 test.txt 的末尾</span></span><br><span class="line">[root@localhost ~]# ls -al &gt;&gt; test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;：就是标准输入重定向（等同0&lt;），意思将某某文件作为程序输入，也就是从某文件读取而不是键盘。</span></span><br><span class="line">[root@localhost ~]# command &lt; file</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-3-7-cut-选取部分内容">8.3.7 cut 选取部分内容</h4><p>cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><ul><li><p>语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> [options]  filename</span><br></pre></td></tr></table></figure></li><li><p>参数</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-b</code></td><td>以字节为单位进行分割</td></tr><tr><td><code>-c</code></td><td>以字符 (characters) 的单位取出固定字符区间</td></tr><tr><td><code>-d</code></td><td>分隔符，按照指定分隔符分割列。与 -f 一起使用</td></tr><tr><td><code>-f</code></td><td>依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思（列号，提取第几列）</td></tr></tbody></table></li><li><p>eg.</p><p>准备数据:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim cut.txt</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line">le  le</span><br></pre></td></tr></table></figure><ol><li><p>切割cut.txt第一列</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -d &#x27; &#x27; -f 1 cut.txt </span></span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure></li><li><p>切割cut.txt第二、三列</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -d &#x27; &#x27; -f 2,3 cut.txt </span></span><br><span class="line">shen</span><br><span class="line">zhen</span><br><span class="line"> wo</span><br><span class="line"> lai</span><br><span class="line"> le</span><br></pre></td></tr></table></figure></li><li><p>切割cut.txt的第5-8个字符</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -c 5-8 cut.txt </span></span><br><span class="line"> she</span><br><span class="line"> zhe</span><br><span class="line">wo</span><br><span class="line"> lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure></li><li><p>切割cut.txt的第2,4,6个字节</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -b 2,4,6 cut.txt </span></span><br><span class="line">ogs</span><br><span class="line">unz</span><br><span class="line">o o</span><br><span class="line">a l</span><br><span class="line">e e</span><br></pre></td></tr></table></figure><p>1</p></li></ol></li></ul><h4 id="8-3-8-tr-对标准输入内容做替换">8.3.8 tr 对标准输入内容做替换</h4><p>tr (translate的简写),主要用于压缩重复字符，主要用于将从标准输入(<code>stdin</code>)读取的数据进行结果集映射、字符压缩和字符删除。它首先会将读取的标准输入进行排序然后按照某种方式换行，然后再根据给出的命令行参数做相关处理。</p><ul><li><p>语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tr [options] [SET1] [SET2]</span></span><br></pre></td></tr></table></figure></li><li><p>参数</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-c</code></td><td>使用SET1的补集</td></tr><tr><td><code>-d</code></td><td>删除字符</td></tr><tr><td><code>-s</code></td><td>压缩字符</td></tr><tr><td><code>-t</code></td><td>截断SET1，使得SET1的长度和SET2的长度相同</td></tr></tbody></table></li><li><p>eg.</p><p>1.将输入的字符由大写转换成小写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;HELLO&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>2.ROT13 加解密 原理 就是两边都对称 所以加解密可以用一套相同的集合</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;hello&quot; | tr &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27; \</span></span><br><span class="line">&gt; <span class="string">&#x27;NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&#x27;</span></span><br><span class="line">uryyb</span><br></pre></td></tr></table></figure><p>3.删除指定字符</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;hello 123 world 234&quot; | tr -d &#x27;0-9&#x27;</span></span><br><span class="line">hello  world </span><br></pre></td></tr></table></figure><p>4.字符集补偿（删除补集）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo hello 1 char 2 next 4 | tr -d -c &#x27;0-9 \n&#x27;</span></span><br><span class="line"> 1  2  4</span><br></pre></td></tr></table></figure><p>5.压缩字符(压缩输入中重复的字符)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;tr    is    a   shell   order   &quot; | tr -s &#x27; &#x27;</span></span><br><span class="line"><span class="built_in">tr</span> is a shell order </span><br></pre></td></tr></table></figure><p>6.字符类</p><table><thead><tr><th>字符类</th><th>说明</th></tr></thead><tbody><tr><td><code>[:digit:]</code></td><td>所有数字</td></tr><tr><td><code>[:lower:]</code></td><td>所有小写字符</td></tr><tr><td><code>[:upper:]</code></td><td>所有大写字符</td></tr><tr><td><code>[:graph:]</code></td><td>所有可打印字符，不包括空格</td></tr><tr><td><code>[:print:]</code></td><td>所有可打印字符，包括空格</td></tr><tr><td><code>[:punct:]</code></td><td>所有的标点字符</td></tr><tr><td><code>[:space:]</code></td><td>所有横向或者纵向的空白</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo acniu | tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;</span></span><br><span class="line">ACENIU</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-3-11-用文本模式指定行区间管道符">8.3.11 | 用文本模式指定行区间管道符</h4><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3131.html">未整理</a></p><p>管道是一种通信机制，通常用于进程间的通信。它表现出来的形式将<strong>前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/ad572909f7df4a43a732b1b8ccdf5d6a.png" alt="img"></p><ul><li><p><strong>实例</strong></p><ol><li><p>过滤功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls / | grep “y”</span><br><span class="line">grep 指令用于“过滤”</span><br><span class="line">grep 语法：grep 选项 文件路径/内容</span><br><span class="line"></span><br><span class="line">针对上面这个命令说明：</span><br><span class="line">以管道作为分界线，前面的命令有个输出，后面需要先输入（缺少查找范围），然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入。</span><br><span class="line">为了便于理解，上述的指令变相实现可以如下：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> / &gt; xxx.txt 将<span class="built_in">ls</span> /的结果保存到xxx.txt文件中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">grep “y” xxx.txt 使用grep指令搜索xxx.txt中的包含y的行</span></span><br></pre></td></tr></table></figure></li><li><p>xargs命令扩展</p><p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name &quot;*.conf&quot; | ls -l (错误)</span><br><span class="line">find /etc -name &quot;*.conf&quot; | xargs ls -l (正确)</span><br></pre></td></tr></table></figure><blockquote><p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。<br>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。<br>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。<br>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p></blockquote></li></ol></li></ul><h4 id="8-3-12-xargs-给命令传递参数">8.3.12 xargs 给命令传递参数</h4><p>管道实现的是将前面的输出<code>stdout</code>作为后面的输入<code>stdin</code>，但是有些命令不接受管道的传递方式。例如：<code>ls</code>，这是为什么呢？</p><p>因为有些命令希望管道传递过来的是参数，但是**直接使用管道有时无法传递到命令的参数位。**这时候就需要<code>xargs</code>，<code>xargs</code>实现的是将管道传递过来的<code>stdin</code>进行处理然后传递到命令的参数位置上。</p><ul><li><p>语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somecommand |xargs [options]  <span class="built_in">command</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-3-13-echo-输出内容到控制台">8.3.13 echo 输出内容到控制台</h4><p>Linux中 echo命令主要用于打印字符或者回显，一般起到一个提示的作用。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo [options] &quot;string&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>不在最后自动换行</td></tr><tr><td>-e</td><td>使用-e扩展参数选项时，与如下参数一起使用，有不同含义，支持反斜线控制的字符转换</td></tr></tbody></table><table><tr><td>-e的参数</td><td>说明</td></tr><tr><td>\a</td><td>发出警告声</td></tr><tr><td>\c</td><td>最后不加上换行符号</td></tr><tr><td>\f</td><td>换行但光标仍旧停留在原来的位置</td></tr><tr><td>\n</td><td>换行且光标移至行首</td></tr><tr><td>\r</td><td>光标移至行首，但不换行</td></tr><tr><td>\t</td><td>制表符，也就是Tab键</td></tr><tr><td>\v</td><td>与\f相同</td></tr><tr><td>\\</td><td>插入\字符</td></tr><tr><td colspan="2">\033[30m 黑色字 \033[0m</td></tr><tr><td colspan="2">\033[31m 红色字 \033[0m</td></tr><tr><td colspan="2">\033[32m 绿色字 \033[0m</td></tr><tr><td colspan="2">\033[33m 黄色字 \033[0m</td></tr><tr><td colspan="2">\033[34m 蓝色字 \033[0m</td></tr><tr><td colspan="2">\033[35m 紫色字 \033[0m</td></tr><tr><td colspan="2">\033[36m 天蓝字 \033[0m</td></tr><tr><td colspan="2">\033[37m 白色字 \033[0m</td></tr><tr><td colspan="2">\033[40;37m 黑底白字 \033[0m</td></tr><tr><td colspan="2">\033[41;37m 红底白字 \033[0m</td></tr><tr><td colspan="2">\033[42;37m 绿底白字 \033[0m</td></tr><tr><td colspan="2">\033[43;37m 黄底白字 \033[0m</td></tr><tr><td colspan="2">\033[44;37m 蓝底白字 \033[0m</td></tr><tr><td colspan="2">\033[45;37m 紫底白字 \033[0m</td></tr><tr><td colspan="2">\033[46;37m 天蓝底白字 \033[0m</td></tr><tr><td colspan="2">\033[47;30m 白底黑字 \033[0m</td></tr></table></li><li><p><strong>实例</strong></p><ol><li><p>变色使用方法</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116180009067.png" alt="image-20230116180009067"></p></li><li><p>覆盖test.txt里面的内容</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116180254831.png" alt="image-20230116180254831"></p></li><li><p>在test.txt追加内容</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230116181730012.png" alt="image-20230116181730012"></p></li></ol></li></ul><h4 id="8-3-14-printf-输出">8.3.14 printf 输出</h4><p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p><p>标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p><p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。<strong>默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n</strong>。</p><ul><li><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>  format-string  [arguments...]</span><br></pre></td></tr></table></figure></li><li><p><strong>参数说明：</strong></p><ul><li><strong>format-string:</strong> 为格式控制字符串</li><li><strong>arguments:</strong> 为参数列表。</li></ul></li><li><p><strong>eg.</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello, Shell&quot;</span></span><br><span class="line">Hello, Shell</span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;Hello, Shell\n&quot;</span></span><br><span class="line">Hello, Shell</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>接下来,我来用一个脚本来体现 printf 的强大功能：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4s\n&quot;</span> 姓名 性别 体重kg  </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 杨过 男 48.6543 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭芙 女 47.9876 </span><br><span class="line"></span><br><span class="line"><span class="comment">#结果:</span></span><br><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br></pre></td></tr></table></figure><p>%s %c %d %f都是格式替代符</p><p>%-10s 指一个宽度为 10 个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p><p>%-4.2f 指格式化为小数，其中 .2 指保留 2 位小数。</p></li><li><p><strong>printf的转义序列</strong></p><table class="reference"><tbody><tr><th>序列</th><th>说明</th></tr><tr><td>\a</td><td>警告字符，通常为 ASCII 的 BEL 字符</td></tr><tr><td>\b</td><td>后退</td></tr><tr><td>\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在 %b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td>\f</td><td>换页（formfeed）</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车（Carriage return）</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\\</td><td>一个字面上的反斜杠字符</td></tr><tr><td>\ddd</td><td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td>\0ddd</td><td>表示 1 到 3 位的八进制值字符</td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;a string, no processing:&lt;%s&gt;\n&quot;</span> <span class="string">&quot;A\nB&quot;</span></span><br><span class="line">a string, no processing:&lt;A\nB&gt;</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;a string, no processing:&lt;%b&gt;\n&quot;</span> <span class="string">&quot;A\nB&quot;</span></span><br><span class="line">a string, no processing:&lt;A</span><br><span class="line">B&gt;</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">printf</span> <span class="string">&quot;www.w3cschool.cn \a&quot;</span></span><br><span class="line">www.w3cschool.cn $                  <span class="comment">#不换行</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-3-15-grep-过滤查找">8.3.15 grep 过滤查找</h4><p>Linux grep 命令用于查找文件里符合条件的字符串。</p><p>grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep [options] [patterns] 文件名</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep -n file</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-c</code>：<code>--count</code></td><td>仅列出文件中包含模式的行数。</td></tr><tr><td><code>-i</code>：<code>--ignore-case</code></td><td>忽略模式中的字母大小写。</td></tr><tr><td><code>-l</code>：<code>--file-with-matches</code></td><td>列出带有匹配行的文件名。</td></tr><tr><td><code>-n</code>：<code>--line-number</code></td><td>在每一行的最前面列出行号。</td></tr><tr><td><code>-v</code>：<code>--invert-match</code></td><td>列出没有匹配模式的行。（反转）</td></tr><tr><td><code>-w</code>：<code>--word-regexp</code></td><td>把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。</td></tr><tr><td><code>-r 关键字 目录</code></td><td>在目录下搜索关键字</td></tr></tbody></table></li><li><p>patterns 正则表达式的通配符</p><table><thead><tr><th>通配符</th><th>功能</th></tr></thead><tbody><tr><td>c*</td><td>将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。</td></tr><tr><td>.</td><td>将匹配任何一个字符，且只能是一个字符。</td></tr><tr><td>[xyz]</td><td>匹配方括号中的任意一个字符。</td></tr><tr><td>[^xyz]</td><td>匹配除方括号中字符外的所有字符。</td></tr><tr><td>^</td><td>锁定行的开头。</td></tr><tr><td>$</td><td>锁定行的结尾。</td></tr></tbody></table><p>需要注意的是，在基本正则表达式中，如通配符 *、+、{、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \，如 *、+、{、|、( 和 )。</p></li></ul><h4 id="8-3-16-sed-字符流编辑器-Stream-EDitor">8.3.16 sed 字符流编辑器(Stream EDitor)</h4><p>我们知道，Vim 采用的是交互式文本编辑模式，你可以用键盘命令来交互性地插入、删除或替换数据中的文本。但本节要讲的 sed 命令不同，它采用的是流编辑模式，最明显的特点是，在 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。</p><p>sed 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下：</p><ol><li>每次仅读取一行内容；</li><li>根据提供的规则命令匹配并修改数据。注意，<font style="background:green">sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据;</font></li><li>将执行结果输出。</li></ol><p>当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。</p><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed [options] [[address]sed command] file</span><br></pre></td></tr></table></figure></li></ul><p><strong>一、选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-e</code></td><td>该选项会将其后跟的脚本命令添加到已有的命令中</td></tr><tr><td><code>-f</code></td><td>该选项会将其后文件中的脚本命令添加到已有的命令中</td></tr><tr><td><code>-n</code></td><td>默认情况下，sed 会在所有的脚本执行完毕后，会自动输出处理后的内容，而该选项会屏蔽自动输出，需使用 print 命令来完成输出</td></tr><tr><td><code>-i</code></td><td>此选项会直接修改源文件</td></tr></tbody></table><p>成功使用 sed 命令的关键在于掌握各式各样的脚本命令及格式，它能帮你定制编辑文件的规则。</p><ul><li><strong>sed 内置命令</strong> <code>[sed command]</code></li></ul><table><thead><tr><th>sed的内置命令字符</th><th>解释</th></tr></thead><tbody><tr><td><code>a</code></td><td>append，对文本追加，在指定行==后面==添加一行/多行文本</td></tr><tr><td><code>d</code></td><td>Delete，删除匹配行</td></tr><tr><td><code>i</code></td><td>insert，表示插入文本，在指定行==前==添加一行/多行文本</td></tr><tr><td><code>p</code></td><td>Print，打印匹配行的内容，通常p与-n一起用</td></tr><tr><td><code>s/正则/替换的内容/flags标记</code></td><td>匹配正则内容，然后替换内容（支持正则）。</td></tr></tbody></table><p><strong>1.1 sed s 替换脚本命令</strong></p><p>此命令的基本格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;[address]s/pattern/replacement/flags&quot;</span><br></pre></td></tr></table></figure><p>其中，address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。关于指定具体操作行（address）的用法，<a href="#anchor_sed01">点击跳转详细介绍</a>。此命令中常用的 flags 标记如下表所示：</p><table><thead><tr><th>flags标记</th><th>功能</th></tr></thead><tbody><tr><td><code>n</code></td><td>1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这时就用到这个标记</td></tr><tr><td><code>g</code></td><td>对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A</td></tr><tr><td><code>p</code></td><td>会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用</td></tr><tr><td><code>w file</code></td><td>将缓冲区中的内容写到指定的 file 文件中</td></tr><tr><td><code>&amp;</code></td><td>用正则表达式匹配的内容进行替换</td></tr><tr><td><code>\n</code></td><td>匹配第 n 个子串，该子串之前在 pattern 中用 () 指定</td></tr><tr><td><code>\</code></td><td>转义（转义替换部分包含：&amp;、\ 等）</td></tr></tbody></table><p>比如，可以指定 sed 用新文本替换第几处模式匹配的地方：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/test/trial/2&#x27; data.txt</span><br><span class="line">This is a test of the trial script.</span><br><span class="line">This is the second test of the trial script.</span><br></pre></td></tr></table></figure><p>可以看到，<strong>使用数字 2 作为标记的结果就是，sed 编辑器只替换每行中第 2 次出现的匹配模式</strong>。</p><p>如果要用新文本替换所有匹配的字符串，可以使用 g 标记：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/test/trial/g&#x27; data.txt</span><br><span class="line">This is a trial of the trial script.</span><br><span class="line">This is the second trial of the trial script.</span><br></pre></td></tr></table></figure><p>由上文可知，-n 选项会禁止 sed 输出，但 p 标记会输出修改过的行，将二者匹配使用的效果就是只输出被替换命令修改过的行，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">This is a test line.</span><br><span class="line">This is a different line.</span><br><span class="line">[root@localhost ~]# sed -n &#x27;s/test/trial/p&#x27; data2.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure><p>w 标记会将匹配后的结果保存到指定文件中，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/test/trial/w test.txt&#x27; data2.txt</span><br><span class="line">This is a trial line.</span><br><span class="line">This is a different line.</span><br><span class="line">[root@localhost ~]#cat test.txt</span><br><span class="line">This is a trial line.</span><br></pre></td></tr></table></figure><p>在使用 s 脚本命令时，替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线进行转义，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/\/bin\/bash/\/bin\/csh/&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><p><strong>1.2 sed d删除脚本命令</strong></p><p>此命令的基本格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]d</span><br></pre></td></tr></table></figure><p>如果需要删除文本中的特定行，可以用 d 脚本命令，它会删除指定行中的所有内容。但使用该命令时要特别小心，如果你忘记指定具体行的话，文件中的所有内容都会被删除，举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">[root@localhost ~]# sed &#x27;d&#x27; data1.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">什么也不输出，证明成了空文件(只是在缓冲区中删除内容，并不会删除源文件中的内容)</span></span><br></pre></td></tr></table></figure><p>当和指定地址一起使用时，删除命令显然能发挥出大的作用。可以从数据流中删除特定的文本行。例如：</p><ul><li><p>通过行号指定，比如删除 data6.txt 文件内容中的第 3 行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">[root@localhost ~]# sed &#x27;3d&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure></li><li><p>或者通过特定行区间指定，比如删除 data6.txt 文件内容中的第 2、3 行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,3d&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure></li><li><p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心，你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，因此，sed 会删除两个指定行之间的所有行（包括指定的行），例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#sed &#x27;/1/,/3/d&#x27; data6.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除第 1~3 行的文本数据</span></span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure></li><li><p>或者通过特殊的文件结尾字符，比如删除 data6.txt 文件内容中第 3 行开始的所有的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3,$d&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure><p>在次强调，在默认情况下 sed 并不会修改原始文件，这里被删除的行只是从 sed 的输出中消失了，原始文件没做任何改变。</p></li></ul><p><strong>1.3 sed a 和 i 添加脚本命令</strong></p><p>a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行，这里之所以要同时介绍这 2 个脚本命令，因为它们的基本格式完全相同，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]a（或 i）\新文本内容</span><br></pre></td></tr></table></figure><p>下面分别就这 2 个命令，给读者举几个例子。比如说，将一个新行插入到数据流第三行前，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3i\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is an inserted line.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is an inserted line.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><p>再比如说，将一个新行附加到数据流中第三行后，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3a\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is an appended line.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an appended line.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><p>如果你想将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;1i\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is one line of new text.\</span></span><br><span class="line"><span class="language-bash">&gt; This is another line of new text.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is one line of new text.</span><br><span class="line">This is another line of new text.</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><p>可以看到，指定的两行都会被添加到数据流中。</p><p><strong>1.4 sed c 替换脚本命令</strong></p><p>c 命令表示将指定行中的所有内容，替换成该选项后面的字符串。该命令的基本格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]c\用于替换的新文本</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3c\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">This is a changed line of text.<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">This is line number 4.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">在这个例子中，sed 编辑器会修改第三行中的文本，其实，下面的写法也可以实现此目的：</span></span></span><br><span class="line">[root@localhost ~]# sed &#x27;/number 3/c\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">This is a changed line of text.&#x27;</span> data6.txt</span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is a changed line of text.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><p><strong>1.5 sed y 转换脚本命令</strong></p><p>y 转换命令是唯一可以处理单个字符的 sed 脚本命令，其基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]y/inchars/outchars/</span><br></pre></td></tr></table></figure><p>转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…这个映射过程会一直持续到处理完指定字符。如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。举个简单例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;y/123/789/&#x27; data8.txt</span><br><span class="line">This is line number 7.</span><br><span class="line">This is line number 8.</span><br><span class="line">This is line number 9.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is line number 7 again.</span><br><span class="line">This is yet another line.</span><br><span class="line">This is the last line in the file.</span><br></pre></td></tr></table></figure><p>可以看到，inchars 模式中指定字符的每个实例都会被替换成 outchars 模式中相同位置的那个字符。 转换命令是一个全局命令，也就是说，它会将文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置，再打个比方：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;This 1 is a test of 1 try.&quot; | sed &#x27;y/123/456/&#x27;</span><br><span class="line">This 4 is a test of 4 try.</span><br></pre></td></tr></table></figure><p>sed 转换了在文本行中匹配到的字符 ‘1’ 的两个实例，我们无法限定只转换在特定地方出现的字符。</p><p><strong>1.6 sed p 打印脚本命令</strong></p><p>p 命令表示搜索匹配文本模式的行，并输出该行的内容，此命令的基本格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]p</span><br></pre></td></tr></table></figure><p>p 命令常见的用法是打印包含匹配文本模式的行，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">[root@localhost ~]# sed -n &#x27;/number 3/p&#x27; data6.txt</span><br><span class="line">This is line number 3.</span><br></pre></td></tr></table></figure><p>可以看到，用 -n 选项和 p 命令配合使用，我们可以禁止输出其他行，只打印包含匹配文本模式的行。 如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &#x27;/3/&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/line/test/p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27; data6.txt</span></span></span><br><span class="line">This is line number 3.</span><br><span class="line">This is test number 3.</span><br></pre></td></tr></table></figure><p>sed 命令会查找包含数字 3 的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。</p><p><strong>1.7 sed w 写入文件脚本命令</strong></p><p>w 命令用来将文本中指定行的内容写入文件中，此命令的基本格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]w filename</span><br></pre></td></tr></table></figure><p>这里的 filename 表示文件名，可以使用相对路径或绝对路径，但不管是哪种，运行 sed 命令的用户都必须有文件的写权限。 下面的例子是将数据流中的前两行打印到一个文本文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;1,2w test.txt&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure><p>当然，如果不想让行直接输出，可以用 -n 选项，再举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data11.txt</span><br><span class="line">Blum, R       Browncoat</span><br><span class="line">McGuiness, A  Alliance</span><br><span class="line">Bresnahan, C  Browncoat</span><br><span class="line">Harken, C     Alliance</span><br><span class="line">[root@localhost ~]# sed -n &#x27;/Browncoat/w Browncoats.txt&#x27; data11.txt</span><br><span class="line">[root@localhost ~]# cat Browncoats.txt</span><br><span class="line">Blum, R       Browncoat</span><br><span class="line">Bresnahan, C  Browncoat</span><br></pre></td></tr></table></figure><p>可以看到，通过使用 w 脚本命令，sed 可以实现将包含文本模式的数据行写入目标文件。</p><p><strong>1.8 sed r 读取文件脚本命令</strong></p><p>r 命令用于将一个独立文件的数据插入到当前数据流的指定位置，该命令的基本格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]r filename</span><br></pre></td></tr></table></figure><p>sed 命令会将 filename 文件中的内容插入到 address 指定行的后面，比如说：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data12.txt</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">[root@localhost ~]# sed &#x27;3r data12.txt&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">This is line number 4.</span><br></pre></td></tr></table></figure><p>如果你想将指定文件中的数据插入到数据流的末尾，可以使用 $ 地址符，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;$r data12.txt&#x27; data6.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br></pre></td></tr></table></figure><p><strong>1.9 sed q 退出脚本命令</strong></p><p>q 命令的作用是使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理。 比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2q&#x27; test.txt</span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br></pre></td></tr></table></figure><p>可以看到，sed 命令在打印输出第 2 行之后，就停止了，是 q 命令造成的，再比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;/number 1/&#123; s/number 1/number 0/;q; &#125;&#x27; test.txt</span><br><span class="line">This is line number 0.</span><br></pre></td></tr></table></figure><p>使用 q 命令之后，sed 命令会在匹配到 number 1 时，将其替换成 number 0，然后直接退出。</p><p><strong><a id="anchor_sed01">二、sed 脚本命令的寻址方式</a></strong></p><p>前面在介绍各个脚本命令时，我们一直忽略了对 address 部分的介绍。对各个脚本命令来说，address 用来表明该脚本命令作用到文本中的具体行。默认情况下，sed 命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须写明 address 部分，表示的方法有以下 2 种：</p><p>1、以数字形式指定行区间；</p><p>2、用文本模式指定具体行区间。</p><table><thead><tr><th>sed匹配范围</th><th>解释</th></tr></thead><tbody><tr><td>空地址</td><td>全文处理</td></tr><tr><td>单地址</td><td>指定文件某一行</td></tr><tr><td>/pattern/</td><td>被模式匹配到的每一行</td></tr><tr><td>范围区间</td><td><code>10,20</code> 十到二十行， <code>10,+5</code>第10行向下5行 <code>/pattern1/,/pattern2/</code></td></tr><tr><td>步长</td><td><code>1~2</code>表示1、3、5、7、9行， <code>2~2</code>表示2、4、6、8、10 偶数行</td></tr></tbody></table><p>以上两种形式都可以使用如下这 2 种格式，分别是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[address]脚本命令</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">address &#123;</span><br><span class="line">    多个脚本命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种形式在前面例子中都有具体实例，因此这里不再做过多赘述。</p><p><strong>2.1 以数字形式指定行区间</strong></p><p>当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。sed 会将文本流中的第一行编号为 1，然后继续按顺序为接下来的行分配行号。在脚本命令中，指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里举一个 sed 命令作用到指定行号的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#sed &#x27;2s/dog/cat/&#x27; data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure><p>可以看到，sed 只修改地址指定的第二行的文本。下面的例子中使用了行地址区间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,3s/dog/cat/&#x27; data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure><p>在此基础上，如果想将命令作用到文本中从某行开始的<strong>所有行</strong>，可以用特殊地址——美元符（$）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,$s/dog/cat/&#x27; data1.txt</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br><span class="line">The quick brown fox jumps over the lazy cat</span><br></pre></td></tr></table></figure><p><strong>2.2 用文本模式指定行区间</strong></p><p>sed 允许指定文本模式来过滤出命令要作用的行，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/command</span><br></pre></td></tr></table></figure><p>注意，必须用**<font style="background:green">正斜线</font>**将要指定的 pattern 封起来，sed 会将该命令作用到包含指定文本模式的行上。举个例子，如果你想只修改用户 demo 的默认 shell，可以使用 sed 命令，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep demo /etc/passwd</span><br><span class="line">demo:x:502:502::/home/Samantha:/bin/bash</span><br><span class="line">[root@localhost ~]# sed &#x27;/demo/s/bash/csh/&#x27; /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br><span class="line">demo:x:502:502::/home/demo:/bin/csh</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限，因此，sed 允许在文本模式使用正则表达式指明作用的具体行。正则表达式允许创建高级文本模式匹配表达式来匹配各种数据。这些表达式结合了一系列通配符、特殊字符以及固定文本字符来生成能够匹配几乎任何形式文本的简练模式。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;First Wed&lt;/title&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">h1Helloh1</span><br><span class="line">h2Helloh2</span><br><span class="line">h3Helloh3</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用正则表示式给所有第一个的h1、h2、h3添加&lt;&gt;，给第二个h1、h2、h3添加&lt;/&gt;</span></span><br><span class="line">[root@localhost ~]# cat sed.sh</span><br><span class="line">/h[0-9]/&#123;</span><br><span class="line">    s//\&lt;&amp;\&gt;/1</span><br><span class="line">    s//\&lt;\/&amp;\&gt;/2</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# sed -f sed.sh test.txt</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;title&gt;First Wed&lt;/title&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;Hello&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;Hello&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>解释： 在上述命令中，“h[0-9]” 来匹配 h1、h2、h3，匹配到之后，把h前面的空白替换成&lt;&gt;，然后&amp;表示将正则表达式匹配的内容(h1、h2、h3)替换到此处，最终的形式为<code>&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;</code>，第二个替换命令原理也是这样。</p><p><strong>三、sed多行命令</strong></p><p>在学习 sed 命令的基础功能时，你可能注意到了一个局限，即所有的 sed 命令都只是针对单行数据执行操作，在 sed 命令读取缓冲区中的文本数据时，它会基于换行符的位置，将数据分成行，sed 会根据定义好的脚本命令一次处理一行数据。 但是，有时我们需要对跨多行的数据执行特定操作。比如说，在文本中查找一串字符串&quot;<a target="_blank" rel="noopener" href="http://c.biancheng.net">http://c.biancheng.net</a>&quot;，它很有可能出现在两行中，每行各包含其中一部分。这时，如果用普通的 sed 编辑器命令来处理文本，就不可能发现这种被分开的情况。 幸运的是，sed 命令的设计人员已经考虑到了这种情况，并设计了对应的解决方案。sed 包含了三个可用来处理多行文本的特殊命令，分别是：</p><p>1、Next 命令（N）：将数据流中的下一行加进来创建一个多行组来处理。</p><p>2、Delete（D）：删除多行组中的一行。</p><p>3、Print（P）：打印多行组中的一行。</p><p><strong><font style="background:green">注意，以上命令的缩写，都为大写。</font></strong></p><p><strong>3.1 N 多行操作命令</strong></p><p>N 命令会将下一行文本内容添加到缓冲区已有数据之后（之间用换行符分隔），从而使前后两个文本行同时位于缓冲区中，sed 命令会将这两行数据当成一行来处理。 下面这个例子演示的 N 命令的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed &#x27;/first/&#123; N ; s/\n/ / &#125;&#x27; data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line. This is the second data line.</span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><p>在这个例子中，sed 命令查找含有单词 first 的那行文本，找到之后，会用N命令将下一行也放入缓冲区中(之间用换行符分隔)，把两行当成一行来处理，然后用替换命令s将换行符替换成空格。结果就是，文本文件中的两行在sed的输出中成了1行。如果要在数据文件中查找一个可能会分散在两行中的文本短语，该如何实现呢？这里给大家一个实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data3.txt</span><br><span class="line">On Tuesday, the Linux System</span><br><span class="line">Administrator&#x27;s group meeting will be held.</span><br><span class="line">All System Administrators should attend.</span><br><span class="line">Thank you for your attendance.</span><br><span class="line">[root@localhost ~]# sed &#x27;N ; s/System Administrator/Desktop User/&#x27; data3.txt</span><br><span class="line">On Tuesday, the Linux Desktop User&#x27;s group meeting will be held.</span><br><span class="line">All Desktop Users should attend.</span><br><span class="line">Thank you for your attendance.</span><br></pre></td></tr></table></figure><p>用N命令将发现第一个单词的那行和下一行在缓冲区合并后(之间用换行符分隔)，即使短语内出现了换行，仍然可以找到它，这是因为，替换命令在 System 和 Administrator之间用了通配符（.）来匹配空格和换行符这两种情况。但当它匹配了换行符时，它就从字符串中删掉了换行符，导致两行合并成一行。这可能不是你想要的。要解决这个问题，可以在 sed 脚本中用两个替换命令，一个用来匹配短语出现在多行中的情况，一个用来匹配短语出现在单行中的情况，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;N</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data3.txt</span></span></span><br><span class="line">On Tuesday, the Linux Desktop</span><br><span class="line">User&#x27;s group meeting will be held.</span><br><span class="line">All Desktop Users should attend.</span><br><span class="line">Thank you for your attendance.</span><br></pre></td></tr></table></figure><p>第一个替换命令专门查找类似这样的短语：‘System\nAdministrator’，即‘System’和‘Administrator’不在同一行的情况，并用‘Desktop\nUser’来替换。这样就可以做到：找到跨行的短语并用跨行的短语来替换。所以输出的时候，‘Desktop’和‘User’仍在两行中。</p><p>但这个脚本中仍有个小问题，即它总是在执行 sed 命令前将下一行文本读入到缓冲区中，当它到了最后一行文本时，就没有下一行可读了，此时 N 命令会叫 sed 程序停止，这就导致，如果要匹配的文本正好在最后一行中，sed 命令将不会发现要匹配的数据。解决这个问题的方法是，将单行命令放到 N 命令前面，将多行命令放到 N 命令后面，像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System\nAdministrator/Desktop\nUser/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">N</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/System Administrator/Desktop User/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="string">&#x27; data3.txt</span></span></span><br><span class="line">On Tuesday, the Linux Desktop</span><br><span class="line">User&#x27;s group meeting will be held.</span><br><span class="line">All Desktop Users should attend.</span><br><span class="line">Thank you for your attendance.</span><br></pre></td></tr></table></figure><p>现在，查找单行中短语的替换命令在数据流的后一行也能正常工作，多行替换命令则会负责短语出现在数据流中间的情况。</p><p><strong>3.2 D 多行删除命令</strong></p><p>sed 不仅提供了单行删除命令（d），也提供了多行删除命令 D，其作用是只删除缓冲区中的第一行，也就是说，D 命令将缓冲区中第一个换行符（包括换行符）之前的内容删除掉。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data4.txt</span><br><span class="line">On Tuesday, the Linux System</span><br><span class="line">Administrator&#x27;s group meeting will be held.</span><br><span class="line">All System Administrators should attend.</span><br><span class="line">[root@localhost ~]# sed &#x27;N ; /System\nAdministrator/D&#x27; data4.txt</span><br><span class="line">Administrator&#x27;s group meeting will be held.</span><br><span class="line">All System Administrators should attend.</span><br></pre></td></tr></table></figure><p>文本的第二行被 N 命令加到了缓冲区，因此 sed 命令第一次匹配就是成功，而 D 命令会将缓冲区中第一个换行符之前（也就是第一行）的数据删除，所以，得到了如上所示的结果。 下面的例子中，它会删除数据流中出现在第一行前的空白行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data5.txt</span><br><span class="line"></span><br><span class="line">This is the header line.</span><br><span class="line">This is a data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed &#x27;/^$/&#123;N ; /header/D&#125;&#x27; data5.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is a data line.</span><br><span class="line"></span><br><span class="line">This is the last line.</span><br></pre></td></tr></table></figure><p>sed会查找空白行，然后用 N 命令来将下一文本行添加到缓冲区。此时如果缓冲区的内容中含有单词 header，则 D 命令会删除缓冲区中的第一行，即第一个换行符(包括换行符)之前的内容。</p><p><strong>3.3 P 多行打印命令</strong></p><p>同 d 和 D 之间的区别一样，P（大写）命令和单行打印命令 p（小写）不同，对于具有多行数据的缓冲区来说，它只会打印缓冲区中的第一行，也就是首个换行符之前的所有内容。例如，test.txt 文件中的内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br><span class="line">eee</span><br><span class="line">fff</span><br></pre></td></tr></table></figure><p>下表是对 test.txt 文件中的内容分别用 p 命令和 P 命令后，产生的输出信息的对比。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1701765-20210906153326927-1710229205.png" alt="img"></p><p>第一个 sed 命令，每次都使用 N 将下一行内容追加到缓冲区内容的后面（用换行符间隔），也就是说，第一次执行命令时缓冲区中的内容为 aaa\nbbb，但 P（大写） 命令的作用是打印换行符之前的内容，也就是 aaa，之后执行的是 sed 的自动输出功能，输出 aaa 和 bbb（sed 命令会自动将 \n 输出为换行），依次类推，就输出了所看到的结果。第二个 sed 命令，使用的是 p （小写）单行打印命令，它会将缓冲区中的所有内容全部打印出来（\n 会自动输出为换行），因此，就会出现上述结果。</p><p><strong>四、sed保持空间</strong></p><p>前面我们一直说，sed 命令处理的是缓冲区中的内容，其实这里的缓冲区，应称为<strong>模式空间</strong>。值得一提的是，模式空间并不是 sed 命令保存文件的唯一空间。sed 还有另一块称为<strong>保持空间</strong>的缓冲区域，它可以用来临时存储一些数据。下表列出了 5 条可用来操作保持空间的命令。</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>h</td><td>将模式空间中的内容复制到保持空间</td></tr><tr><td>H</td><td>将模式空间中的内容附加到保持空间</td></tr><tr><td>g</td><td>将保持空间中的内容复制到模式空间</td></tr><tr><td>G</td><td>将保持空间中的内容附加到模式空间</td></tr><tr><td>x</td><td>交换模式空间和保持空间中的内容</td></tr></tbody></table><p>通常，在使用 h 或 H 命令将字符串移动到保持空间后，最终还要用 g、G 或 x 命令将保存的字符串移回模式空间。保持空间最直接的作用是，一旦我们将模式空间中所有的文件复制到保持空间中，就可以清空模式空间来加载其他要处理的文本内容。由于有两个缓冲区域，下面的例子中演示了如何用 h 和 g 命令来将数据在 sed 缓冲区之间移动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed -n &#x27;/first/&#123;h;p;n;p;g;p;&#125;&#x27; data2.txt</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the first data line.</span><br></pre></td></tr></table></figure><p>这个例子的运行过程是这样的：</p><ul><li><p>sed脚本命令用正则表达式过滤出含有单词first的行；</p></li><li><p>当含有单词 first 的行出现时，h 命令将该行放到保持空间；</p></li><li><p>p 命令打印模式空间也就是第一个数据行的内容；</p></li><li><p>n 命令提取数据流中的下一行（This is the second data line），并将它放到模式空间；</p></li><li><p>p 命令打印模式空间的内容，现在是第二个数据行；</p></li><li><p>g 命令将保持空间的内容（This is the first data line）放回模式空间，替换当前文本；</p></li><li><p>p 命令打印模式空间的当前内容，现在变回第一个数据行了。</p></li></ul><p><strong>五、sed改变指定流程</strong></p><p><strong>5.1 b分支命令</strong></p><p>通常，sed 程序的执行过程会从第一个脚本命令开始，一直执行到最后一个脚本命令（D 命令是个例外，它会强制 sed 返回到脚本的顶部，而不读取新的行）。sed 提供了 <strong>b 分支命令</strong>来改变命令脚本的执行流程，其结果与结构化编程类似。b 分支命令基本格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]b [label]</span><br></pre></td></tr></table></figure><p>其中，address 参数决定了哪些行的数据会触发分支命令，label 参数定义了要跳转到的位置。需要注意的是，如果没有加 label 参数，跳转命令会跳转到<strong>脚本的结尾</strong>，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">This is the header line.</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">This is the last line.</span><br><span class="line">[root@localhost ~]# sed &#x27;&#123;2,3b ; s/This is/Is this/ ; s/line./test?/&#125;&#x27; data2.txt</span><br><span class="line">Is this the header test?</span><br><span class="line">This is the first data line.</span><br><span class="line">This is the second data line.</span><br><span class="line">Is this the last test?</span><br></pre></td></tr></table></figure><p>可以看到，因为 b 命令未指定 label 参数，因此数据流中的第2行和第3行并没有执行那两个替换命令。如果我们不想直接跳到脚本的结尾，可以为 b 命令指定一个标签（也就是格式中的 label，最多为 7 个字符长度）。在使用此该标签时，要以冒号开始（比如 :label2），并将其放到要跳过的脚本命令之后。这样，当 sed 命令匹配并处理该行文本时，会跳过标签之前所有的脚本命令，但会执行标签之后的脚本命令。比如说：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;&#123;/first/b jump1 ; s/This is the/No jump on/</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">:jump1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/This is the/Jump here on/&#125;<span class="string">&#x27; data2.txt</span></span></span><br><span class="line">No jump on header line</span><br><span class="line">Jump here on first data line</span><br><span class="line">No jump on second data line</span><br><span class="line">No jump on last line</span><br></pre></td></tr></table></figure><p>在这个例子中，如果文本行中出现了 first，程序的执行会直接跳到 jump1 标签之后的脚本行。如果分支命令的模式没有匹配，sed 会继续执行所有的脚本命令。b 分支命令除了可以向后跳转，还可以向前跳转，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;This, is, a, test, to, remove, commas.&quot; | sed -n &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">:start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/,//1p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">/,/b start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br><span class="line">This is, a, test, to, remove, commas.</span><br><span class="line">This is a, test, to, remove, commas.</span><br><span class="line">This is a test, to, remove, commas.</span><br><span class="line">This is a test to, remove, commas.</span><br><span class="line">This is a test to remove, commas.</span><br><span class="line">This is a test to remove commas.</span><br></pre></td></tr></table></figure><p>在这个例子中，当缓冲区中的行内容中有逗号时，脚本命令就会一直循环执行，每次迭代都会删除文本中的第一个逗号，并打印字符串，直至内容中没有逗号。</p><p>5.2 t测试命令</p><p>类似于 b 分支命令，t 命令也可以用来改变 sed 脚本的执行流程。t 测试命令会根据 s 替换命令的结果，如果匹配并替换成功，则脚本的执行会跳转到指定的标签；反之，t 命令无效。测试命令使用与分支命令相同的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]t [label]</span><br></pre></td></tr></table></figure><p>跟分支命令一样，在没有指定标签的情况下，如果 s 命令替换成功，sed 会跳转到脚本的结尾（相当于不执行任何脚本命令）。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/first/matched/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">t</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/This is the/No match on/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27; data2.txt</span></span></span><br><span class="line">No match on header line</span><br><span class="line">This is the matched data line</span><br><span class="line">No match on second data line</span><br><span class="line">No match on last line</span><br></pre></td></tr></table></figure><p>此例中，第一个替换命令会查找模式文本 first，如果匹配并替换成功，命令会直接跳过后面的替换命令；反之，如果第一个替换命令未能匹配成功，第二个替换命令就会被执行。再举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  echo &quot;This, is, a, test, to, remove, commas. &quot; | sed -n &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">:start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">s/,//1p</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">t start</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#125;<span class="string">&#x27;</span></span></span><br><span class="line">This is, a, test, to, remove, commas.</span><br><span class="line">This is a, test, to, remove, commas.</span><br><span class="line">This is a test, to, remove, commas.</span><br><span class="line">This is a test to, remove, commas.</span><br><span class="line">This is a test to remove, commas.</span><br><span class="line">This is a test to remove commas.</span><br></pre></td></tr></table></figure><p>在上面的例子中，sed会先对文本执行s替换操作，即把每行的第1个逗号(,)替换成空字符并打印本行。如果替换操作成功，则会执行t命令的start标签中的命令，即继续替换逗号，直到文本中没有逗号为止。</p><h4 id="8-3-17-awk">8.3.17 awk</h4><p>和 sed 命令类似，awk 命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk [options] &#x27;pattern&#123;action&#125;&#x27; file</span><br></pre></td></tr></table></figure></li><li><p>选项</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-F &quot;fs&quot;</code></td><td>指定以 fs 作为输入行的分隔符，awk 命令默认分隔符为空格或制表符。</td></tr><tr><td><code>-f file</code></td><td>从脚本文件中读取 awk 脚本指令，以取代直接在命令行中输入指令。</td></tr><tr><td><code>-v var=val</code></td><td>在执行处理过程之前，设置一个变量 var，并给其设备初始值为 val。</td></tr></tbody></table><ul><li><p>内置变量 <code>-v var</code></p><table><thead><tr><th>内置变量</th><th>解释</th></tr></thead><tbody><tr><td>FS</td><td>输入字段分隔符， 默认为空白字符</td></tr><tr><td>OFS</td><td>输出字段分隔符， 默认为空白字符</td></tr><tr><td>RS</td><td>输入记录分隔符(输入换行符)， 指定输入时的换行符</td></tr><tr><td>ORS</td><td>输出记录分隔符（输出换行符），输出时用指定符号代替换行符</td></tr><tr><td>NF</td><td>NF：number of Field，当前行的字段的个数(即当前行被分割成了几列)，字段数量</td></tr><tr><td>NR</td><td>NR：行号，当前处理的文本行的行号。</td></tr><tr><td>FNR</td><td>FNR：各文件分别计数的行号</td></tr><tr><td>FILENAME</td><td>FILENAME：当前文件名</td></tr><tr><td>ARGC</td><td>ARGC：命令行参数的个数</td></tr><tr><td>ARGV</td><td>ARGV：数组，保存的是命令行所给定的各参数</td></tr></tbody></table></li></ul></li></ul><p>awk 的强大之处在于脚本命令，它由 2 部分组成，分别为匹配规则和执行命令，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;匹配规则&#123;执行命令&#125;&#x27;</span><br></pre></td></tr></table></figure><p>这里的匹配规则，和 sed 命令中的 address 部分作用相同，用来指定脚本命令可以作用到文本内容中的具体行，可以使用字符串（比如 /demo/，表示查看含有 demo 字符串的行）或者正则表达式指定。另外需要注意的是，整个脚本命令是用单引号（‘’）括起，而其中的执行命令部分需要用大括号（{}）括起来。</p><p>在 awk 程序执行时，如果没有指定执行命令，则默认会把匹配的行输出；如果不指定匹配规则，则默认匹配文本中所有的行。</p><p>举个简单的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;/^$/ &#123;print &quot;Blank line&quot;&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure><p>在此命令中，<code>/^$/</code> 是一个正则表达式，功能是匹配文本中的空白行，同时可以看到，执行命令使用的是 print 命令，此命令经常会使用，它的作用很简单，就是将指定的文本进行输出。因此，整个命令的功能是，如果 test.txt 有 N 个空白行，那么执行此命令会输出 N 个 Blank line。</p><p><strong>一、awk 使用数据字段变量</strong></p><p>awk 的主要特性之一是其处理文本文件中数据的能力，它会自动给一行中的每个数据元素分配一个变量。</p><p>默认情况下，awk 会将如下变量分配给它在文本行中发现的数据字段：</p><ul><li><p>$0 代表整个文本行；</p></li><li><p>$1 代表文本行中的第 1 个数据字段(列)；</p></li><li><p>$2 代表文本行中的第 2 个数据字段；</p></li><li><p>$n 代表文本行中的第 n 个数据字段。</p></li><li><p>$NF 字段数量变量</p></li><li><p>$NR 每行的记录号，多文件记录递增</p></li><li><p>$FNR 与NR类似，不过多文件记录不递增，每个文件都从1开始</p></li></ul><p>前面说过，在 awk 中，默认的字段分隔符是任意的空白字符（例如空格或制表符）。 在文本行中，每个数据字段都是通过字段分隔符划分的。awk 在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。</p><p>所以在下面的例子中，awk 程序读取文本文件，只显示第 1 个数据字段的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data2.txt</span><br><span class="line">One line of test text.</span><br><span class="line">Two lines of test text.</span><br><span class="line">Three lines of test text.</span><br><span class="line">[root@localhost ~]# awk &#x27;&#123;print $1&#125;&#x27; data2.txt</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br></pre></td></tr></table></figure><p>该程序用 $1 字段变量来表示“仅显示每行文本的第 1 个数据字段”。当然，如果你要读取采用了其他字段分隔符的文件，可以用 -F 选项手动指定。</p><p><strong>二、awk 脚本命令使用多个命令</strong></p><p>awk 允许将多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;My name is Rich&quot; | awk &#x27;&#123;$4=&quot;Christine&quot;; print $0&#125;&#x27;</span><br><span class="line">My name is Christine</span><br></pre></td></tr></table></figure><p>第一条命令会给字段变量 $4 赋值。第二条命令会打印整个数据字段。可以看到，awk 程序在输出中已经将原文本中的第四个数据字段替换成了新值。</p><p>除此之外，也可以一次一行地输入程序脚本命令，比如说：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;&#123;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="variable">$4</span>=<span class="string">&quot;Christine&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">print</span> <span class="variable">$0</span>&#125;<span class="string">&#x27;</span></span></span><br><span class="line">My name is Rich</span><br><span class="line">My name is Christine</span><br></pre></td></tr></table></figure><p>在你用了表示起始的单引号后，bash shell 会使用 &gt; 来提示输入更多数据，我们可以每次在每行加一条命令，直到输入了结尾的单引号。</p><p>注意，此例中因为没有在命令行中指定文件名，awk 程序需要用户输入获得数据，因此当运行这个程序的时候，它会一直等着用户输入文本，此时如果要退出程序，只需按下 Ctrl+D 组合键即可。</p><p><strong>三、awk从文件中读取程序</strong></p><p>跟 sed 一样，awk 允许将脚本命令存储到文件中，然后再在命令行中引用，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat awk.sh</span><br><span class="line">&#123;print $1 &quot;&#x27;s home directory is &quot; $6&#125;</span><br><span class="line">[root@localhost ~]# awk -F: -f awk.sh /etc/passwd</span><br><span class="line">root&#x27;s home directory is /root</span><br><span class="line">bin&#x27;s home directory is /bin</span><br><span class="line">daemon&#x27;s home directory is /sbin</span><br><span class="line">adm&#x27;s home directory is /var/adm</span><br><span class="line">lp&#x27;s home directory is /var/spool/lpd</span><br><span class="line">...</span><br><span class="line">Christine&#x27;s home directory is /home/Christine</span><br><span class="line">Samantha&#x27;s home directory is /home/Samantha</span><br><span class="line">Timothy&#x27;s home directory is /home/Timothy</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://awk.sh">awk.sh</a> 脚本文件会使用 print 命令打印 /etc/passwd 文件的主目录数据字段（字段变量 $6），以及 userid 数据字段（字段变量 $1）。注意，在程序文件中，也可以指定多条命令，只要一条命令放一行即可，之间不需要用分号。</p><p><strong>四、awk BEGIN关键字</strong></p><p>通常，对于每个输入行， awk 都会执行脚本代码块一次。然而，在许多编程情况中，可能需要在处理数据前运行一些脚本命令，这就需要使用 BEGIN 关键字。BEGIN 会强制 awk 在读取数据前执行该关键字后指定的脚本命令(BEGIN后面的命令只执行一次)，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat data3.txt</span><br><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">[root@localhost ~]# awk &#x27;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125;<span class="string">&#x27; data3.txt</span></span></span><br><span class="line">The data3 File Contents:</span><br><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br></pre></td></tr></table></figure><p>可以看到，这里的脚本命令中分为 2 个部分，BEGIN 部分的脚本指令会在 awk 命令处理数据前运行，而真正用来处理数据的是第二段脚本命令。</p><p><strong>五、awk END关键字</strong></p><p>和 BEGIN 关键字相对应，END 关键字允许我们指定一些脚本命令，awk 会在读完数据后执行它们，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;BEGIN &#123;print &quot;The data3 File Contents:&quot;&#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&#123;<span class="built_in">print</span> <span class="variable">$0</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">END &#123;<span class="built_in">print</span> <span class="string">&quot;End of File&quot;</span>&#125;<span class="string">&#x27; data3.txt</span></span></span><br><span class="line">The data3 File Contents:</span><br><span class="line">Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3</span><br><span class="line">End of File</span><br></pre></td></tr></table></figure><p>可以看到，当 awk 程序打印完文件内容后，才会执行 END 中的脚本命令。</p><p><strong>六、条件操作符</strong></p><p>条件操作符有：&lt;、&lt;=、==、!=、&gt;=、~匹配正则表达式、!~不匹配正则表达式</p><p>匹配:<code>awk '&#123;if ($4~/ASIMA/) print $0&#125;' temp.txt</code> 表示如果第四个数据字段包含ASIMA，就打印整行数据</p><p>精确匹配:awk ‘$3==“48” {print $0}’ temp.txt 表示只打印第3个数据字段等于&quot;48&quot;的记录</p><p>不匹配: awk ‘$0 !~ /ASIMA/’ temp.txt 表示打印整条不包含ASIMA的记录</p><p>不等于: awk ‘$1 != “asima”’ temp.txt 表示打印第1个数据字段不等于&quot;asima&quot;的记录</p><p>小于: awk ‘{if ($1&lt;$2) print $1 “is smaller”}’ temp.txt 表示如果第一个数据字段小于第二个数据字段，则打印第一个数据字段+“is smaller”</p><p>设置大小写: awk ‘/[Gg]reen/’ temp.txt 表示打印整条包含Green，或者green的记录</p><p>任意字符: awk ‘$1 ~/^…a/’ temp.txt 表示打印第1个数据字段中第四个字符是a的记录，符号’^’代表行首，符合’.’代表任意字符</p><p>或关系匹配: awk ‘$0~/(abc)|(efg)/’ temp.txt 表示打印整行数据匹配“abc”或“efg”的记录，使用|时，语句需要括起来</p><p>AND与关系:<code>awk '&#123;if ( $1==&quot;a&quot; &amp;&amp; $2==&quot;b&quot; ) print $0&#125;' temp.txt</code> 表示如果第一个数据字段等于“a”并且第二个数据字段等于“b”，则打印该行数据</p><p>OR或关系: awk ‘{if ($1==“a” || $1==“b”) print $0}’ temp.txt 表示如果第一个数据字段等于“a”或者第二个数据字段等于“b”，则打印该行数据</p><p><strong>七、awk内置变量</strong></p><table><thead><tr><th>ARGC</th><th>命令行参数个数</th><th>NF</th><th>当前行的数据字段个数</th></tr></thead><tbody><tr><td>AGRV</td><td>命令行参数排列</td><td>NR</td><td>已读的记录数，即行号，从1开始(一行就是一个记录，一个记录有若干个字段/域)</td></tr><tr><td>ENVIRON</td><td>支持队列中系统环境变量的使用</td><td>OFS</td><td>输出数据字段分隔符(默认为空格)</td></tr><tr><td>FILENAME</td><td>awk浏览的文件名</td><td>ORS</td><td>输出记录分隔符(默认为换行符)</td></tr><tr><td>FNR</td><td>浏览文件的记录数</td><td>RS</td><td>记录分隔符(默认是换行符)</td></tr><tr><td>FS</td><td>设置输入域分隔符，同<code>-F</code>选项</td><td></td><td></td></tr></tbody></table><p>下图说明了几个内置变量的含义：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1701765-20210919173809187-1016993733.png" alt="img"></p><p>举几个实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例1：在最后打印文件的行数</span></span><br><span class="line">➜  test awk &#x27;END &#123;print NR&#125;&#x27; data2.txt</span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例2：先输出行号，再输出本行有几个数据字段，再输出本行，最后输出文件名</span></span><br><span class="line">➜  test awk &#x27;&#123;print NR,NF,$0&#125; END &#123;print FILENAME&#125;&#x27; data2.txt</span><br><span class="line">1 6 line1:This is the header line 1.</span><br><span class="line">2 7 line2:This is the first data line 2.</span><br><span class="line">3 7 line3:This is the second data line 3.</span><br><span class="line">4 6 line4:This is the last line 4.</span><br><span class="line">data2.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例3：行数&gt;0，并且第4个数据字段和/last/正则表达式匹配，就输出该行</span></span><br><span class="line">➜  test awk &#x27;&#123;if (NR&gt;0 &amp;&amp; $4~/last/) print $0&#125;&#x27; data2.txt</span><br><span class="line">line4:This is the last line 4.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例4：显示当前目录名</span></span><br><span class="line">➜  test echo $PWD</span><br><span class="line">/home/baichunyu.bcy/test</span><br><span class="line">➜  test echo $PWD | awk -F / &#x27;&#123;print $NF&#125;&#x27;</span><br><span class="line">test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例5：修改字段分隔符为\t</span></span><br><span class="line">➜  test cat test.txt</span><br><span class="line">ww   CC        IDD</span><br><span class="line">➜  test awk &#x27;BEGIN &#123;FS=&quot;\t+&quot;&#125; &#123;print $1,$2,$3&#125;&#x27; test.txt   #把字段分隔符修改为一个或多个制表符 </span><br><span class="line">ww   CC        IDD</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实例6：修改字段分隔符的另一种方式</span></span><br><span class="line">➜  test cat hello.txt</span><br><span class="line">root:x::0 0:root:/root:/bin/bash</span><br><span class="line">➜  test awk -F &#x27;[ :/]+&#x27; &#x27;&#123;print $1,$2,$3,$4&#125; END&#123;print NF&#125;&#x27; hello.txt  #把字段分隔符修改为1个或多个空格、冒号、斜杠(采用正则表达式)</span><br><span class="line">root x 0 0</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>八、awk内置字符串函数</strong></p><ul><li><p>gsub(r，s)　　含义：在整个$0中用s替代r</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;gsub(/name/，&quot;xiaoming&quot;) &#123;print $0&#125;&#x27; temp.txt　　# 在temp.txt中把每行中的name替换成xiaoming，并打印该行</span><br></pre></td></tr></table></figure></li><li><p>gsub(r，s，t)　　含义：在整个t中用s替代r</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  test cat data2.txt</span><br><span class="line">line1:This is the header line 1.</span><br><span class="line">line2:This is the first data line 2.</span><br><span class="line">line3:This is the second data line 3.</span><br><span class="line">line4:This is the last line 4.</span><br><span class="line"></span><br><span class="line">➜  test awk &#x27;gsub(/line/,&quot;hang&quot;,$5) &#123;print $0&#125;&#x27; data2.txt    # 在data2.txt文件中，把每行的第5个域中的line替换成hang，如果替换成功则打印该行</span><br><span class="line">line1:This is the header hang 1.</span><br><span class="line">line4:This is the last hang 4. </span><br></pre></td></tr></table></figure></li><li><p>index(s，t)　　含义：返回s中字符串t的第一位置(下标从1开始计算)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;print index(&quot;Sunny&quot;,&quot;ny&quot;)&#125;&#x27; temp.txt</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li><p>length(s)　　含义：返回s的长度</p></li><li><p>match(s，r)　　含义：测试s中是否包含匹配r的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;$1=&quot;J.Lulu&quot; &#123;print match($1,&quot;u&quot;)&#125;&#x27; temp.txt   # 因为temp.txt中有两行，遍历每一行时，都把$1赋值为&quot;J.Lulu&quot;，都包含&quot;u&quot;，因此输出两个4，代表&quot;J.Lulu&quot;中包含&quot;u&quot;</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure></li><li><p>split(s，a，fs)　　含义：用fs把s分割成序列a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;print split(&quot;12#345#6789&quot;,arr,&quot;#&quot;);print arr[1];print arr[2];print arr[3]&#125;&#x27; temp.txt</span><br><span class="line">3</span><br><span class="line">12</span><br><span class="line">345</span><br><span class="line">6789#上述命令中，print split(&quot;12#345#6789&quot;，arr，&quot;#&quot;)，输出3，即arr的长度，同时arr[1]=&quot;12&quot;， arr[2]=&quot;345&quot;， arr[3]=&quot;6789&quot;   (该序列下标从1开始计算)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  test awk &#x27;BEGIN&#123;info=&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#x27;</span><br><span class="line">4</span><br><span class="line">1 this</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br><span class="line">4 test#上述命令中，分割字符串到数组tA中，for循环会自动遍历数组，其中k是数组下标，会自动增加。</span><br></pre></td></tr></table></figure></li><li><p>sprint(fmt，exp)　　含义：返回经fmt格式化后的exp</p></li><li><p>sub(r，s)　　含义：在$0中用s替换第一个r</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  test cat data2.txt</span><br><span class="line">line1:This is the header line 1.</span><br><span class="line">line2:This is the first data line 2.</span><br><span class="line">line3:This is the second data line 3.</span><br><span class="line">line4:This is the last line 4.</span><br><span class="line">➜  test awk &#x27;sub(/line/,&quot;hang&quot;) &#123;print $0&#125;&#x27; data2.txt    # 把每行中第一个line替换成hang，并打印该行</span><br><span class="line">hang1:This is the header line 1.</span><br><span class="line">hang2:This is the first data line 2.</span><br><span class="line">hang3:This is the second data line 3.</span><br><span class="line">hang4:This is the last line 4.</span><br></pre></td></tr></table></figure></li><li><p>substr(str,from,[num])　　含义：从str中截取子串，该子串从from下标开始截取(<strong>str下标从1开始</strong>)，截取的长度为num，若未指定num参数，则截取到str的末尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN&#123;print substr(&quot;abcdef&quot;,4)&#125;&#x27; data2.txt</span><br><span class="line">def</span><br><span class="line">➜  test awk &#x27;BEGIN&#123;print substr(&quot;abcdef&quot;,3,2)&#125;&#x27; data2.txt</span><br><span class="line">cd</span><br></pre></td></tr></table></figure></li><li><p>tolower(str)、toupper(str) 含义：把str转为小写、把str转为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN&#123;print tolower(&quot;abcdefAAA&quot;)&#125;&#x27; data2.txt</span><br><span class="line">abcdefaaa</span><br><span class="line">➜  test awk &#x27;BEGIN&#123;print toupper(&quot;abcdefAAA&quot;)&#125;&#x27; data2.txt</span><br><span class="line">ABCDEFAAA</span><br></pre></td></tr></table></figure></li></ul><p><strong>九、printf函数的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 字符转换:</span><br><span class="line">➜  test echo &quot;65&quot;|awk &#x27;&#123;printf &quot;%c\n&quot;,$0&#125;&#x27;</span><br><span class="line">A</span><br><span class="line"></span><br><span class="line"># 格式化输出 </span><br><span class="line">➜  test awk &#x27;BEGIN &#123;printf &quot;%f\n&quot;,999&#125;&#x27; temp.txt</span><br><span class="line">999.000000  </span><br><span class="line">  </span><br><span class="line"># 格式化输出</span><br><span class="line">➜  test cat temp.txt</span><br><span class="line">my name is bcy.</span><br><span class="line">and you?</span><br><span class="line">➜  test awk &#x27;&#123;printf &quot;%-15s %s\n&quot;,$1,$2&#125;&#x27; temp.txt</span><br><span class="line">my              name</span><br><span class="line">and             you?</span><br></pre></td></tr></table></figure><p><strong>十、awk的一些其他用法</strong></p><p><strong>10.1 给变量赋值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 以下两种方法都可以实现给变量AGE赋值➜  test awk &#x27;&#123;if ($6&lt;AGE) print $0&#125;&#x27; AGE=10 data2.txt</span><br><span class="line">line1:This is the header line 1.</span><br><span class="line">line4:This is the last line 4.</span><br><span class="line">➜  test awk -v AGE=10 &#x27;&#123;if ($6&lt;AGE) print $0&#125;&#x27; data2.txt</span><br><span class="line">line1:This is the header line 1.</span><br><span class="line">line4:This is the last line 4.</span><br></pre></td></tr></table></figure><p>另外，也可以将<strong>环境变量</strong>的值赋给变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  test echo $LOGNAME     # 输出登录名</span><br><span class="line">baichunyu.bcy</span><br><span class="line">➜  test who | awk &#x27;&#123;if ($1==user) print $1 &quot; are in &quot; $0&#125;&#x27; user=$LOGNAME       # 把登录名赋值给变量user</span><br><span class="line">baichunyu.bcy are in baichunyu.bcy pts/1        Sep 17 09:38 (10.78.232.152)</span><br></pre></td></tr></table></figure><p><strong>10.2 只列出文件名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l | awk &#x27;&#123;print $9&#125;&#x27;      # 常规情况文件名是第9域</span><br></pre></td></tr></table></figure><p><strong>10.3 awk数组</strong></p><p>awk的循环结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For (element in array) print array[element]  </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;record=&quot;123#456#789&quot;;split(record,arr,&quot;#&quot;)&#125; END &#123;for (i in arr) &#123;print arr[i]&quot; i=&quot;i&#125;&#125;&#x27; temp.txt</span><br><span class="line">123 i=1</span><br><span class="line">456 i=2</span><br><span class="line">789 i=3</span><br></pre></td></tr></table></figure><p>在上述命令中，在BEGIN中把record分割成数组，保存在arr中，在END中遍历并输出数组arr中的每个元素。<strong>i从1开始自动递增，数组的下标也是从1开始</strong>。</p><p><strong>10.4 awk正则</strong></p><table><thead><tr><th>元字符</th><th>功能</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>^</td><td>行首定位符</td><td>/^root/</td><td>匹配所有以root开头的行</td></tr><tr><td>$</td><td>行尾定位符</td><td>/root$/</td><td>匹配所有以root结尾的行</td></tr><tr><td>.</td><td>匹配任意单个字符</td><td>/r…t/</td><td>匹配字母r，然后两个任意字符，再以t结尾的单词，比如：root、raat、rabt</td></tr><tr><td>*</td><td>匹配0个或多个前导字符</td><td>/a*ool/</td><td>匹配0个或多个a之后紧跟着ool的单词，比如：ool、aool、aaaool</td></tr><tr><td>+</td><td>匹配1个或多个前导字符</td><td>/a+b/</td><td>匹配1个或多个a加b的单词，比如：ab、aab、aaaab</td></tr><tr><td>？</td><td>匹配0个或1个前导字符</td><td>/a?b/</td><td>匹配b 或 ab</td></tr><tr><td>[]</td><td>匹配指定字符组内的任意一个字符</td><td>/<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>/</td><td>匹配以字母a或b或c开头的单词</td></tr><tr><td>[^]</td><td>匹配不在指定字符组内的任意一个字符</td><td>/<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>/</td><td>匹配不以字母a或b或c开头的单词</td></tr><tr><td>()</td><td>子表达式组合</td><td>/(root)+/</td><td>匹配1个或多个root</td></tr><tr><td>|</td><td>或者的意思</td><td>/(root)|B/</td><td>匹配root或者B</td></tr><tr><td>\</td><td>转义字符</td><td>/a///</td><td>匹配a//</td></tr><tr><td>~和!~</td><td>匹配和不匹配的条件语句</td><td>$1~/root/</td><td>匹配第一个数据字段包含root的行</td></tr><tr><td>x{m}x{m,}x{m,n}</td><td>x重复m次x重复至少m次x重复至少m次，但不超过n次</td><td>/(root){3}//(root){3,}//(root){5,6}/</td><td>匹配root正好出现3次的情况匹配root出现至少3次的情况匹配root出现5到6次的情况</td></tr></tbody></table><p>举例说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Gin scripts]# awk &#x27;/root/&#123;print $0&#125;&#x27; passwd #匹配所有包含root的行</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line"> </span><br><span class="line">[root@Gin scripts]# awk -F: &#x27;$5~/root/&#123;print $0&#125;&#x27; passwd  #以分号作为分隔符，匹配第5个字段是root的行</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p><strong>十一、if条件语句</strong></p><p>awk中if条件语句的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(表达式)  </span><br><span class="line">   &#123;语句1&#125;  </span><br><span class="line">else if(表达式)  </span><br><span class="line">   &#123;语句2&#125;  </span><br><span class="line">else  </span><br><span class="line">   &#123;语句3&#125;</span><br></pre></td></tr></table></figure><p>每条语句后面要用“;”结尾，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;</span><br><span class="line">quote&gt; test=70;</span><br><span class="line">quote&gt; if(test&gt;90)</span><br><span class="line">quote&gt; &#123;</span><br><span class="line">quote&gt; print &quot;very good!&quot;;</span><br><span class="line">quote&gt; &#125;</span><br><span class="line">quote&gt; else if(test&gt;60)</span><br><span class="line">quote&gt; &#123;</span><br><span class="line">quote&gt; print &quot;good~&quot;;</span><br><span class="line">quote&gt; &#125;</span><br><span class="line">quote&gt; else</span><br><span class="line">quote&gt; &#123;</span><br><span class="line">quote&gt; print &quot;no pass!!&quot;;</span><br><span class="line">quote&gt; &#125;</span><br><span class="line">quote&gt; &#125;&#x27;</span><br><span class="line">good~</span><br></pre></td></tr></table></figure><p><strong>十二、循环语句</strong></p><p><strong>12.1 while循环语句</strong></p><p>awk中while循环语句的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(表达式)</span><br><span class="line"></span><br><span class="line">&#123;语句&#125;</span><br></pre></td></tr></table></figure><p>举个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;</span><br><span class="line">border=10;</span><br><span class="line">sum=0;</span><br><span class="line">i=0;</span><br><span class="line">while(i&lt;=border)&#123;</span><br><span class="line">   sum+=i;</span><br><span class="line">   i++;</span><br><span class="line">&#125;</span><br><span class="line">print sum;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">55</span><br></pre></td></tr></table></figure><p><strong>12.2 for循环语句</strong></p><p>awk中for循环语句有两种格式，先看格式1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(变量 in 数组)</span><br><span class="line"></span><br><span class="line">&#123;语句&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;</span><br><span class="line">for (k in ENVIRON)&#123;       # ENVIRON 是awk常量，是个数组</span><br><span class="line">print k&quot;=&quot;ENVIRON[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">AWKPATH=.:/usr/share/awk  </span><br><span class="line">OLDPWD=/home/web97  </span><br><span class="line">SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass  </span><br><span class="line">SELINUX_LEVEL_REQUESTED=  </span><br><span class="line">SELINUX_ROLE_REQUESTED=  </span><br><span class="line">LANG=zh_CN.GB2312</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>for循环的格式2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(变量;条件;表达式)</span><br><span class="line"></span><br><span class="line">&#123;语句&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;</span><br><span class="line">sum=0;</span><br><span class="line">for(i=0;i&lt;=100;i++)&#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">print sum;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p><strong>12.3 do…while循环语句</strong></p><p>awk中do…while循环语句的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">   语句</span><br><span class="line">&#125;</span><br><span class="line">while(条件)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;BEGIN &#123;</span><br><span class="line">sum=0;</span><br><span class="line">i=0;</span><br><span class="line">do&#123;</span><br><span class="line">sum+=i;</span><br><span class="line">i++;</span><br><span class="line">&#125;while(i&lt;=100)</span><br><span class="line">print sum;</span><br><span class="line">&#125;&#x27;</span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p>除此之外，还有一些关键字，例如：</p><table><thead><tr><th>break</th><th>当 break 语句用于 while 或 for 语句时，导致退出程序循环</th></tr></thead><tbody><tr><td>continue</td><td>当 continue 语句用于 while 或 for 语句时，使程序循环移动到下一个迭代</td></tr><tr><td>next</td><td>使程序读入下一个输入行，并返回到脚本的顶部，这可以避免对当前输入行执行其他的操作</td></tr><tr><td>exit</td><td>exit关键字使主输入循环退出并移动到END，如果END存在的话。如果没有定义END规则，或在END中应用exit语句，则终止脚本的执行</td></tr></tbody></table><p>十三、awk使用实例</p><p><strong>实例1：只查看test.txt文件（100行）内第20到第30行的内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">→  test awk &#x27;&#123;if(NR&gt;=20 &amp;&amp; NR&lt;=30) print $0&#125;&#x27; test.txt   </span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>解释： NR代表已读的记录数(行数)，NR&gt;=20&amp;&amp;NR&lt;=30 代表文件中的第20行到第30行。</p><p><strong>实例2：已知test.txt文件内容为：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  test cat test.txt </span><br><span class="line">I am Poe,my qq is 33794712</span><br></pre></td></tr></table></figure><p>请从该文件中过滤出&quot;Poe&quot;字符串与33794712，最后输出的结果为：Poe 33794712</p><p>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk &#x27;&#123;split($3,arr,&quot;,&quot;);print arr[1]&quot; &quot;$6&#125;&#x27; test.txt</span><br><span class="line">Poe 33794712</span><br></pre></td></tr></table></figure><p>解释：Poe,my 是$3，用split()内置函数把$3分割成arr，其中arr[1]=Poe，33794712是$6，print 后面拼接字符串进行输出。</p><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  test awk -F &#x27;[ ,]+&#x27; &#x27;&#123;print $3&quot; &quot;$7&#125;&#x27; test.txt</span><br><span class="line">Poe 33794712</span><br></pre></td></tr></table></figure><p>解释：用-F来指定分隔符为1个或多个空格或逗号(,) ，然后Poe和33794712分别是$3和$7，print 后面拼接字符串进行输出。</p><h4 id="8-3-18-history-查看已经执行过的历史命令">8.3.18 history 查看已经执行过的历史命令</h4><p>实际上history的历史命令是写入.bash_history 中的。 ~/.bash_history 记录的是前一次登陆所运行过的命令，而本次登陆所运行的命令都被缓存在内存中，当退出系统后，本次的命令记忆才会记录到 .bash_history 中。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# histroy [options]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><p>通常都是直接 <code>history</code> 然后通过管道配合 <code>more</code>，<code>less</code>，<code>tail</code>，<code>head</code> 来使用，其他复杂用法这里不作介绍。</p></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>将目前的shell中的所有 history 内容全部清除</td></tr><tr><td>-a</td><td>将目前新增的history指令新增入 histfiles中，若没有 histfiles，则预设写入 ~/.bash_history</td></tr><tr><td>-r</td><td>将histfiles的内容读到目前这个shell的history记忆中</td></tr><tr><td>-w</td><td>将目前的history记忆内容写入histfiles</td></tr></tbody></table></li><li><p><strong>生产环境优化</strong></p><p>在项目中，在不同终端下执行了一系列的命令后，翻不到历史记录，也没有汇总，也不知道每条命令的执行时间，所以需要对该命令进行优化。</p><p>配置文件:centos上<code>/root/.bashrc</code>；ubuntu上修改的文件是 <code>/etc/bash.bashrc</code>；mac上修改的文件是 <code>/etc/bashrc</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改histroy的配置文件</span></span><br><span class="line">[root@localhost ~]# vim /root/.bashrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加日期</span></span><br><span class="line">HISTTIMEFORMAT=&quot;%F %T &quot;</span><br><span class="line">export HISTTIMEFORMAT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不同终端命令汇总</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Avoid duplicates</span></span><br><span class="line">export HISTCONTROL=ignoredups:erasedups</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">When the shell exits, append to the <span class="built_in">history</span> file instead of overwriting it</span></span><br><span class="line">shopt -s histappend</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">After each <span class="built_in">command</span>, append to the <span class="built_in">history</span> file and reread it</span></span><br><span class="line">export PROMPT_COMMAND=&quot;$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND$&#x27;\n&#x27;&#125;history -a; history -c; history -r&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整记录命令长度</span></span><br><span class="line">export HISTSIZE=3000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">剔除连续重复的条目</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Avoid duplicates</span></span><br><span class="line">export HISTCONTROL=ignoredups:erasedups</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后执行</span></span><br><span class="line">[root@localhost ~]# source /root/.bashrc</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-4-日期、时间">8.4 日期、时间</h3><h4 id="8-4-1-date-日期与时间">8.4.1 date 日期与时间</h4><p>Linux date 命令可以用来显示或设定系统的日期与时间。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [OPTION] [+&quot;FORMAT&quot;]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# date +&quot;%F %T &quot;</span><br><span class="line">2023-01-16 22:05:22 </span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code>：<code>--date=STRING</code></td><td>显示 datestr 中所设定的时间 (非系统时间)</td></tr><tr><td><code>-s</code>,：<code>--set=STRING</code></td><td>将系统时间设为 datestr 中所设定的时间</td></tr><tr><td><code>-u</code>： <code>--utc</code>：<code>--universal</code></td><td>打印或设置协调世界时（UTC）</td></tr><tr><td><code>--version</code></td><td>显示版本编号</td></tr><tr><td><code>-help</code></td><td>显示辅助讯息</td></tr></tbody></table></li><li><p><strong>格式</strong></p><ul><li><p>时间格式</p><table><thead><tr><th align="left">符号</th><th align="left">符号说明</th></tr></thead><tbody><tr><td align="left">%</td><td align="left">印出 %</td></tr><tr><td align="left">%n</td><td align="left">下一行</td></tr><tr><td align="left">%t</td><td align="left">跳格</td></tr><tr><td align="left">%H</td><td align="left">小时(00…23)</td></tr><tr><td align="left">%I</td><td align="left">小时(01…12)</td></tr><tr><td align="left">%k</td><td align="left">小时(0…23)</td></tr><tr><td align="left">%l</td><td align="left">小时(1…12)</td></tr><tr><td align="left">%M</td><td align="left">分钟(00…59)</td></tr><tr><td align="left">%p</td><td align="left">显示本地 AM 或 PM</td></tr><tr><td align="left">%r</td><td align="left">直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</td></tr><tr><td align="left">%R</td><td align="left">24小时制方式显示时间，相当于%H:%M</td></tr><tr><td align="left">%s</td><td align="left">从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数</td></tr><tr><td align="left">%S</td><td align="left">秒(00…60)</td></tr><tr><td align="left">%T</td><td align="left">直接显示时间 (24 小时制)</td></tr><tr><td align="left">%X</td><td align="left">相当于 %H:%M:%S</td></tr><tr><td align="left">%z</td><td align="left">数字方式显示时区</td></tr><tr><td align="left">%Z</td><td align="left">字母缩写方式显示时区</td></tr></tbody></table></li><li><p>日期格式</p><table><thead><tr><th align="left">符号</th><th align="left">符号说明</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">星期几 ，缩写(Sun…Sat)</td></tr><tr><td align="left">%A</td><td align="left">星期几 ，完整英文星期(Sunday…Saturday)</td></tr><tr><td align="left">%b</td><td align="left">月份 (Jan…Dec)</td></tr><tr><td align="left">%B</td><td align="left">月份 (January…December)</td></tr><tr><td align="left">%c</td><td align="left">直接显示日期与时间</td></tr><tr><td align="left">%d</td><td align="left">日 (01…31)</td></tr><tr><td align="left">%D</td><td align="left">直接显示日期 (mm/dd/yy)</td></tr><tr><td align="left">%e</td><td align="left">一个月中的第几天，类似%_d</td></tr><tr><td align="left">%F</td><td align="left">完整的日期，相当于%Y-%m-%d</td></tr><tr><td align="left">%h</td><td align="left">同 %b</td></tr><tr><td align="left">%j</td><td align="left">一年中的第几天 (001…366)</td></tr><tr><td align="left">%m</td><td align="left">月份 (01…12)</td></tr><tr><td align="left">%u</td><td align="left">一周中的第几天 (1…7) (1是星期一)</td></tr><tr><td align="left">%U</td><td align="left">一年中的第几周 (00…53) (以 Sunday 为一周的第一天的情形)</td></tr><tr><td align="left">%w</td><td align="left">一周中的第几天 (0…6)(0是星期天)</td></tr><tr><td align="left">%W</td><td align="left">一年中的第几周 (00…53) (以 Monday 为一周的第一天的情形)</td></tr><tr><td align="left">%x</td><td align="left">直接显示日期 (mm/dd/yy)</td></tr><tr><td align="left">%y</td><td align="left">年份的最后两位数字 (00.99)</td></tr><tr><td align="left">%Y</td><td align="left">完整年份 (0000…9999)</td></tr></tbody></table></li></ul></li></ul><h4 id="8-4-2-cal-查看日历">8.4.2 cal 查看日历</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# cal [option] [[[日] 月] 年]</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-1</code>： <code>-one</code></td><td>只显示当前月份(默认)</td></tr><tr><td><code>-3</code>：<code>--three</code></td><td>显示上个月、当月和下个月</td></tr><tr><td><code>-s</code>： <code>--sunday</code></td><td>周日作为一周第一天</td></tr><tr><td><code>-m</code>：<code>--monday</code></td><td>周一作为一周第一天</td></tr><tr><td><code>-j</code>： <code>--julian</code></td><td>输出儒略日（显示每一天是本年的第几天）</td></tr><tr><td><code>-y</code>：<code>--year</code></td><td>输出整年</td></tr><tr><td><code>-V</code>： <code>--version</code></td><td>显示版本信息并退出</td></tr><tr><td><code>-h</code>：<code>--help</code></td><td>显示此帮助并退出</td></tr></tbody></table></li></ul><h3 id="8-5-用户、用户组管理">8.5 用户、用户组管理</h3><h4 id="8-5-3-etc-passwd-系统-用户配置文件">8.5.3 /etc/passwd 系统-用户配置文件</h4><p>Linux 系统中的 <code>/etc/passwd</code> 文件，是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作。</p><ul><li><p><strong>文件内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下文件内容</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">...省略部分输出...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>/etc/passwd</code> 文件中的内容非常规律，每行记录对应一个用户。</p><p>这些用户中的绝大多数是系统或服务正常运行所必需的用户，这种用户通常称为系统用户或伪用户。系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。</p></li><li><p><strong>字段</strong></p><ul><li><p><strong>用户名</strong></p><p>用户名仅是为了方便用户记忆，Linux 系统是通过 UID 来识别用户身份，分配用户权限的。<code>/etc/passwd</code> 文件中就定义了用户名和 UID 之间的对应关系。</p></li><li><p><strong>密码</strong></p><p>“x” 表示此用户设有密码，但不是真正的密码，真正的密码保存在 <code>/etc/shadow</code> 文件中。在早期的 UNIX 中，这里保存的就是真正的加密密码串，但由于所有程序都能读取此文件，非常容易造成用户数据被窃取（虽然密码是加密的，但是采用暴力破解的方式也是能够进行破解的）。因此，现在 Linux 系统把真正的加密密码串放置在 <code>/etc/shadow</code> 文件中，此文件只有 root 用户可以浏览和操作，这样就最大限度地保证了密码的安全。</p><p>需要注意的是，虽然 “x” 并不表示真正的密码，但也不能删除，如果删除了 “x”，那么系统会认为这个用户没有密码，从而导致只输入用户名而不用输入密码就可以登陆。（只能在本地使用无密码登录，远程是不可以的）</p></li><li><p><strong>UID</strong></p><p>UID，也就是用户 ID。每个用户都有唯一的一个 UID，Linux 系统通过 UID 来识别不同的用户。实际上，UID 就是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份。</p><table><thead><tr><th>UID 范围</th><th>用户身份</th></tr></thead><tbody><tr><td>0</td><td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</td></tr><tr><td>1~499</td><td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1~99 用于系统自行创建的账号；100~499 分配给有系统账号需求的用户。 其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td></tr><tr><td>500~65535</td><td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 232 个 UID 了。</td></tr></tbody></table></li><li><p><strong>GID</strong></p><p>全称“Group ID”，简称“组ID”，表示用户初始组的组 ID 号。这里需要解释一下初始组和附加组的概念。</p><p><strong>初始组</strong>：指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。比如说，我们手工添加用户 lamp，在建立用户 lamp 的同时，就会建立 lamp 组作为 lamp 用户的初始组。</p><p><strong>附加组</strong>：指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。</p><p>当然，初始组和附加组的身份是可以修改的，但是我们在<strong>工作中不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱</strong>。需要注意的是，在 <code>/etc/passwd</code> 文件的第四个字段中看到的 ID 是这个用户的初始组。</p></li><li><p><strong>描述性信息</strong></p><p>这个字段并没有什么重要的用途，只是用来解释这个用户的意义而已。</p></li><li><p><strong>主目录</strong></p><p>也就是用户登录后有操作权限的访问目录，通常称为用户的主目录。</p><p>root 超级管理员账户的主目录为 <code>/root</code>，普通用户的主目录为 <code>/home/yourIDname</code>。</p></li><li><p><strong>默认的Shell</strong></p><p>Shell 就是 Linux 的命令解释器，是用户和 Linux 内核之间沟通的桥梁。</p><p>通常情况下，Linux 系统默认使用的命令解释器是 <code>bash</code>（<code>/bin/bash</code>），当然还有其他命令解释器，例如 sh、csh 等。</p><p>这里不能随便写入和登陆没有关系的命令（如 ls），系统不会识别这些命令，同时也就意味着这个用户不能登录。</p><p>把 lamp 用户的 Shell 命令解释器修改为 <code>/sbin/nologin</code>，那么，这个用户就不能登录了，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vi /etc/passwd</span><br><span class="line">lamp:x:502:502::/home/lamp:/usr/bin/passwd</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8-5-5-etc-group-系统-用户组配置文件">8.5.5 /etc/group 系统-用户组配置文件</h4><p>此文件是记录组 ID（GID）和组名相对应的文件。</p><ul><li><p><strong>文件内容</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vim /etc/group</span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:bin,daemon</span><br><span class="line">daemon:x:2:bin,daemon</span><br><span class="line">…省略部分输出…</span><br><span class="line">lamp:x:502:</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">组名：密码：GID：该用户组中的用户列表</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>/etc/group</code> 中每一行各代表一个用户组。在前面章节中，我们曾创建 lamp 用户，系统默认生成一个 lamp 用户组，在此可以看到，此用户组的 GID 为 502，目前它仅作为 lamp 用户的初始组。</p></li><li><p>字段</p><ul><li><p><strong>组名</strong></p><p>也就是是用户组的名称，有字母或数字构成。同 <code>/etc/passwd</code> 中的用户名一样，组名也不能重复。</p></li><li><p><strong>组密码</strong></p><p>和 <code>/etc/passwd</code> 文件一样，这里的 “x” 仅仅是密码标识，真正加密后的组密码默认保存在 <code>/etc/gshadow</code> 文件中。</p><p>不过，用户设置密码是为了验证用户的身份，那用户组设置密码是用来做什么的呢？用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，可以由该组的组管理员替代 root 进行管理。但是这项功能目前很少使用，我们也很少设置组密码。如果需要赋予某用户调整某个用户组的权限，则可以使用 sudo 命令代替。</p></li><li><p><strong>组ID (GID)</strong></p><p>就是群组的 ID 号，Linux 系统就是通过 GID 来区分用户组的，同用户名一样，组名也只是为了便于管理员记忆。</p><p>这里的组 GID 与 <code>/etc/passwd</code> 文件中第 4 个字段的 GID 相对应，实际上，<code>/etc/passwd</code> 文件中使用 GID 对应的群组名，就是通过此文件对应得到的。</p></li><li><p>组中的用户</p><p>此字段列出每个群组包含的所有用户。需要注意的是，如果该用户组是这个用户的初始组，则该用户不会写入这个字段，可以这么理解，该字段显示的用户都是这个用户组的附加用户。</p><p>举个例子，lamp 组的组信息为 “<code>lamp:x:502:</code>”，可以看到，第四个字段没有写入 lamp 用户，因为 lamp 组是 lamp 用户的初始组。如果要查询这些用户的初始组，则需要先到 <code>/etc/passwd</code> 文件中查看 GID（第四个字段），然后到 /etc/group 文件中比对组名。每个用户都可以加入多个附加组，但是只能属于一个初始组。所以我们在实际工作中，如果需要把用户加入其他组，则需要以附加组的形式添加。例如，我们想让 lamp 也加入 root 这个群组，那么只需要在第一行的最后一个字段加入 lamp，即 <code>root:x:0:lamp</code> 就可以了。</p></li></ul></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li><li><p><strong>实例</strong></p></li></ul><h4 id="8-5-9-useradd-添加新用户">8.5.9 useradd 添加新用户</h4><p>Linux useradd 命令用于建立用户帐号。</p><p><code>useradd</code> 可用来建立用户帐号。帐号建好之后，再用 <code>passwd</code> 设定帐号的密码。可用 <code>userdel</code> 删除帐号。使用 <code>useradd</code> 指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code> 文本文件中。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# useradd [options] username</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-u UID</td><td>手工指定用户的 UID，注意 UID 的范围（不要小于 500）。</td></tr><tr><td>-d 主目录</td><td>手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</td></tr><tr><td>-c 用户说明</td><td>手工指定/etc/passwd文件中各用户信息中第 5 个字段的描述性内容，可随意配置；</td></tr><tr><td>-g 组名</td><td>手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时<br>会默认建立初始组。一旦手动指定，则系统将不会在创建此默认的初始组目录。</td></tr><tr><td>-G 组名</td><td>指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</td></tr><tr><td>-s shell</td><td>手工指定用户的登录 Shell，默认是 /bin/bash；</td></tr><tr><td>-e 曰期</td><td>指定用户的失效曰期，格式为 “YYYY-MM-DD”。也就是 /etc/shadow 文件的第八个字段；</td></tr><tr><td>-o</td><td>允许创建的用户的 UID 相同。例如，执行 “useradd -u 0 -o usertest” 命令<br>建立用户 usertest，它的 UID 和 root 用户的 UID 相同，都是 0；</td></tr><tr><td>-m</td><td>建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</td></tr><tr><td>-r</td><td>创建系统用户，也就是 UID 在 1~499 之间，供系统程序使用的用户。<br>由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</td></tr></tbody></table><p>其实，系统已经帮我们规定了非常多的默认值，在没有特殊要求下，无需使用任何选项即可成功创建用户。</p></li><li><p>流程</p><ol><li><p>创建 lamp 普通用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd lamp</span><br></pre></td></tr></table></figure><p>可以看到，用户的 UID 是从 500 开始计算的。同时默认指定了用户的家目录为 /home/lamp/，用户的登录 Shell 为 /bin/bash。</p></li><li><p>在 /etc/passwd 文件中创建一行与 lamp 用户相关的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/passwd</span><br><span class="line">lamp:x:500:500::/home/lamp:/bin/bash</span><br></pre></td></tr></table></figure><p>当然，这个用户还没有设置密码，所以密码字段是 “!!”，代表这个用户没有合理密码，不能正常登录。同时会按照默认值设定时间字段，例如密码有效期有 99999 天，距离密码过期 7 天系统会提示用户“密码即将过期”等。</p></li><li><p>在 /etc/group 文件中创建一行与用户名一模一样的群组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/group</span><br><span class="line">lamp:x:500:</span><br></pre></td></tr></table></figure><p>该群组会作为新建用户的初始组。</p></li><li><p>在 /etc/gshadow 文件中新增一行与新增群组相关的密码信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/gshadow</span><br><span class="line">lamp:!::</span><br></pre></td></tr></table></figure><p>当然，我们没有设定组密码，所以这里没有密码，也没有组管理员。</p></li><li><p>默认创建用户的主目录和邮箱：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#ll -d /home/lamp/</span><br><span class="line">drwx------ 3 lamp lamp 4096 1月6 00:19 /home/lamp/</span><br><span class="line">[root@localhost ~]#ll /var/spod/mail/lamp</span><br><span class="line">-rw-rw---- 1 lamp mail 0 1月6 00:19 /var/spool/mail/lamp</span><br></pre></td></tr></table></figure><p>注意这两个文件的权限，都要让 lamp 用户拥有相应的权限。</p></li><li><p>将 /etc/skel 目录中的配置文件复制到新用户的主目录中</p></li></ol></li><li><p>新增用户组时初始化数据</p><p>文件<code>/etc/default/useradd</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vim /etc/default/useradd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">useradd defaults file</span></span><br><span class="line">GR0UP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure><p>也可以选项查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd -D</span><br></pre></td></tr></table></figure><ul><li><p>文件内容</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>GR0UP=100</td><td>这个选项用于建立用户的默认组，也就是说，在添加每个用户时，用户的初始组就是 GID 为 100 的这个用户组。但 CentOS 并不是这样的，而是在添加用户时会自动建立和用户名相同的组作为此用户的初始组。也就是说这个选项并不会生效。 Linux 中默认用户组有两种机制：一种是私有用户组机制，系统会创建一个和用户名相同的用户组作为用户的初始组；另一种是公共用户组机制，系统用 GID 是 100 的用户组作为所有新建用户的初始组。目前我们采用的是私有用户组机制。</td></tr><tr><td>HOME=/home</td><td>指的是用户主目录的默认位置，所有新建用户的主目录默认都在 /home/下，刚刚新建的 lamp1 用户的主目录就为 /home/lamp1/。</td></tr><tr><td>INACTIVE=-1</td><td>指的是密码过期后的宽限天数，也就是 /etc/shadow 文件的第七个字段。这里默认值是 -1，代表所有新建立的用户密码永远不会失效。</td></tr><tr><td>EXPIRE=</td><td>表示密码失效时间，也就是 /etc/shadow 文件的第八个字段。默认值是空，代表所有新建用户没有失效时间，永久有效。</td></tr><tr><td>SHELL=/bin/bash</td><td>表示所有新建立的用户默认 Shell 都是 /bin/bash。</td></tr><tr><td>SKEL=/etc/skel</td><td>在创建一个新用户后，你会发现，该用户主目录并不是空目录，而是有 .bash_profile、.bashrc 等文件，这些文件都是从 /etc/skel 目录中自动复制过来的。因此，更改 /etc/skel 目录下的内容就可以改变新建用户默认主目录中的配置文件信息。</td></tr><tr><td>CREATE_MAIL_SPOOL=yes</td><td>指的是给新建用户建立邮箱，默认是创建。也就是说，对于所有的新建用户，系统都会新建一个邮箱，放在 /var/spool/mail/ 目录下，和用户名相同。例如，</td></tr></tbody></table></li></ul></li><li><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd lamp1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先手工添加lamp1用户组，因为我一会儿要把lamp1用户的初始迎指定过来，如果不事先建立，则会报告用户组不存在</span></span><br><span class="line">[root@localhost ~]# useradd -u 550 -g lamp1 -G root -d /home/lamp1 -c &quot;test user&quot; -s /bin/bash lamp1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在建立用户lamp1的同时，指定了UID（550）、初始组（lamp1）、附加组（root）、家目录（/home/lamp1/）、用户说明（<span class="built_in">test</span> user）和用户登录Shell（/bin/bash）</span></span><br><span class="line">[root@localhost ~]# grep &quot;lamp1&quot; /etc/passwd /etc/shadow /etc/group</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同时查看三个文件</span></span><br><span class="line">/etc/passwd:lamp1:x:550:502:test user:/home/lamp1:/bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户的UID、初始组、用户说明、家目录和登录Shell都和命令手工指定的一致</span></span><br><span class="line">/etc/shadow:lamp1:!!:15710:0:99999:7:::</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lamp1用户还没有设定密码</span></span><br><span class="line">/etc/group:root:x:0:lamp1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lamp1用户加入了root组，root组是lamp1用户的附加组</span></span><br><span class="line">/etc/group:lampl:x:502:</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GID为502的组是lamp1组</span></span><br><span class="line">[root@localhost ~]#ll -d /home/lamp1/</span><br><span class="line">drwx------ 3 lamp1 lamp1 4096 1月6 01:13 /home/lamp1/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">家目录也建立了，不需要手工建立</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-5-10-passwd-设置用户密码">8.5.10 passwd 设置用户密码</h4><p>很多Linux 发行版为了系统安装，都使用了 PAM 模块进行密码的检验，设置密码太短、与用户名相同、是常见字符串等，都会被 PAM 模块检查出来，从而禁止用户使用此类密码。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd [options] username</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-S</code></td><td>查询用户密码的状态，也就是 /etc/shadow 文件中此用户密码的内容（仅 root 用户可用）</td></tr><tr><td><code>-l</code></td><td>暂时锁定用户，该选项会在 /etc/shadow 文件中指定用户的加密密码串前添加 “!”，使密码失效<br>（仅 root 用户可用）</td></tr><tr><td><code>-u</code></td><td>解锁用户，和 -l 选项相对应（ 仅 root 用户使用）</td></tr><tr><td><code>-d</code></td><td>删除密码</td></tr><tr><td><code>-f</code></td><td>强迫用户下次登录时必须修改口令</td></tr><tr><td><code>--stdin</code></td><td>可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用</td></tr><tr><td><code>-k</code></td><td>更新只能发送在过期之后</td></tr><tr><td><code>-n</code></td><td>设置该用户修改密码后，多长时间不能再次修改密码，也就是修改 /etc/shadow 文件中各行密码<br>的第 4 个字段</td></tr><tr><td><code>-x</code></td><td>设置该用户的密码有效期，对应 /etc/shadow 文件中各行密码的第 5 个字段</td></tr><tr><td><code>-w</code></td><td>设置用户密码过期前的警告天数，对于 /etc/shadow 文件中各行密码的第 6 个字段</td></tr><tr><td><code>-i</code></td><td>设置用户密码失效日期，对应 /etc/shadow 文件中各行密码的第 7 个字段</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>使用 root 账户修改 lamp 普通用户的密码，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd lamp</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">New password: &lt;==直接输入新的口令，但屏幕不会有任何反应</span><br><span class="line">BAD PASSWORD: it is WAY too short &lt;==口令太简单或过短的错误！这里只是警告信息，输入的密码依旧能用</span><br><span class="line">Retype new password:  &lt;==再次验证输入的密码，再输入一次即可</span><br><span class="line">passwd: all authentication tokens updated successfully.  &lt;==提示修改密码成功</span><br></pre></td></tr></table></figure></li><li><p>使用 passwd 命令修改当前系统已登录用户的密码，但要注意的是，需省略掉 “选项” 和 “用户名”。登陆 lamp 用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">passwd直接回车代表修改当前用户的密码</span></span><br><span class="line">Changing password for user vbird2.</span><br><span class="line">Changing password for vbird2</span><br><span class="line">(current) UNIX password: &lt;==这里输入『原有的旧口令』</span><br><span class="line">New password: &lt;==这里输入新口令</span><br><span class="line">BAD PASSWORD: it is WAY too short &lt;==口令检验不通过，请再想个新口令</span><br><span class="line">New password: &lt;==这里再想个来输入吧</span><br><span class="line">Retype new password: &lt;==通过口令验证！所以重复这个口令的输入</span><br><span class="line">passwd: all authentication tokens updated successfully. &lt;==成功修改用户密码</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>普通用户只能使用 passwd 命令修改自己的密码，而不能修改其他用户的密码。</p></li><li><p>与使用 root 账户修改普通用户的密码不同，普通用户修改自己的密码需要先输入自己的旧密码，只有旧密码输入正确才能输入新密码。不仅如此，此种修改方式对密码的复杂度有严格的要求，新密码太短、太简单，都会被系统检测出来并禁止用户使用。</p></li><li><p>–stdin 选项，用于批量给用户设置初始密码。使用此方式批量给用户设置初始密码，当然好处就是方便快捷，但需要注意的是，这样设定的密码会把密码明文保存在历史命令中，如果系统被攻破，别人可以在 /root/.bash_history 中找到设置密码的这个命令，存在安全隐患。（①手工清除历史命令；②强制这些新添加的用户在第一次登录时必须修改密码。）</p></li></ol></li></ol></li></ul><h4 id="8-5-11-usermod-修改用户信息">8.5.11 usermod 修改用户信息</h4><p>Linux usermod命令用于修改用户帐号信息。</p><p>使用 Vim 文本编辑器手动修改涉及用户信息的相关文件（/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow），另一个方法就是使用本节介绍了 usermod 命令，该命令专门用于修改用户信息。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#usermod [options] username</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-c 用户说明</code></td><td>修改用户的说明信息，即修改 <code>/etc/passwd</code> 文件目标用户信息的第 5 个字段</td></tr><tr><td><code>-d 主目录</code></td><td>修改用户的主目录，即修改 <code>/etc/passwd</code> 文件中目标用户信息的第 6 个字段，需要注意的是，主目录必须写绝对路径</td></tr><tr><td><code>-e 日期</code></td><td>修改用户的失效曰期，格式为 “YYYY-MM-DD”，即修改 /etc/shadow 文件目标用户密码信息的第 8 个字段</td></tr><tr><td><code>-g 组名</code></td><td>修改用户的初始组，即修改 <code>/etc/passwd</code> 文件目标用户信息的第 4 个字段（GID）</td></tr><tr><td><code>-u UID</code></td><td>修改用户的UID，即修改 <code>/etc/passwd</code> 文件目标用户信息的第 3 个字段（UID）</td></tr><tr><td><code>-G 组名</code></td><td>修改用户的附加组，其实就是把用户加入其他用户组，即修改 /etc/group 文件</td></tr><tr><td><code>-l 用户名</code></td><td>修改用户名称</td></tr><tr><td><code>-L</code></td><td>临时锁定用户（Lock）</td></tr><tr><td><code>-U</code></td><td>解锁用户（Unlock），和 -L 对应</td></tr><tr><td><code>-s shell</code></td><td>修改用户的登录 Shell，默认是 <code>/bin/bash</code></td></tr></tbody></table><p>其实 usermod 命令提供的选项和 useradd 命令的选项相似，因为 usermod 命令就是用来调整使用 useradd 命令添加的用户信息的。</p><p>usermod 命令还多出了几个选项，即 -L 和 -U，作用分别与 passwd 命令的 -l 和-u 相同。此命令对用户的临时锁定，同 passwd 命令一样，都是在 /etc/passwd 文件目标用户的加密密码字段前添加 “!”，使密码失效；反之，解锁用户就是将添加的 “!” 去掉。</p></li><li><p><strong>实例</strong></p></li></ul><h4 id="8-4-13-userdel-删除用户">8.4.13 userdel 删除用户</h4><p>Linux userdel命令用于删除用户帐号。</p><p>userdel可删除用户帐号与相关的文件。若不加参数，则仅删除用户帐号，但是不删除用户的家目录，那么家目录就会变成没有属主和属组的目录，也就是垃圾文件。</p><p><strong><span style="color:red">※注意：如果要删除的用户已经使用过系统一段时间，那么此用户可能在系统中留有其他文件，因此，如果我们想要从系统中彻底的删除某个用户，最好在使用 userdel 命令之前，先通过 <code>find -user 用户名</code> 命令查出系统中属于该用户的文件，然后在加以删除。</span></strong></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# userdel [options] username</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除用户的同时删除用户的家目录</span></span><br><span class="line">[root@localhost ~]# userdel -r username</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>删除用户登入目录以及目录中所有文件</td></tr></tbody></table></li><li><p><s>手动删除</s></p><p>手动删除用户，仅是为了对 userdel 命令理解地更透彻，实际使用中，使用 userdel 删除用户更方便。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立新 lamp 用户</span></span><br><span class="line">[root@localhost ~]# useradd lamp</span><br><span class="line">[root@localhost ~]# passwd lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为 lamp 用户设置密码，由此 lamp 用户才算是创建成功</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面开始手动删除 lamp</span></span><br><span class="line">[root@localhost ~]# vi /etc/passwd</span><br><span class="line">lamp:x:501:501::/home/lamp:/bin/bash   &lt;--删除此行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改用户信息文件，删除lamp用户行</span></span><br><span class="line">[root@localhost ~]#vi /etc/shadow</span><br><span class="line">lamp:$6$KoOYtcOJ $56Xk9vp3D2vMRBxibNOn.21cVJ9onbW8IHx4WrOx6qBqfGa9U3mjMsGjqYnj L/4t3zt3YxElce2X8rbb12x4a0:15716:0:99999:7:::   &lt;--删除此行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改影子文件，删除lamp用户密码行，注意，这个文件的权限是000，所以要强制保存</span></span><br><span class="line">[root@localhost ~]#vi /etc/group</span><br><span class="line">lamp:x:501:  &lt;--删除此行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改组信息文件，删除lamp群组信息</span></span><br><span class="line">[root@localhost ~]#vi /etc/gshadow</span><br><span class="line">lamp:!::  &lt;--删除此行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改组影子文件，删除lamp群组密码信息。同样注意需要强制保存</span></span><br><span class="line">[root@localhost ~]# rm -rf /var/spod/mail/lamp  #删除用户邮箱</span><br><span class="line">[root@localhost ~]# rm -rf/home/lamp/  #删除用户的家目录</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">至此，用户彻底删除，再新建用户lamp。如果可以正常建立，则说明我们手工删除干净了</span></span><br><span class="line">[root@localhost ~]# useradd lamp</span><br><span class="line">[root@localhost ~]# passwd lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新建立同名用户，没有报错，说明前面的手工删除是可以完全删除用户的</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-4-14-id-查看用户的UID和GID">8.4.14 id 查看用户的UID和GID</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# id [options] username</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# id username</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-g</code>：<code>--group</code></td><td>显示用户所属群组的ID</td></tr><tr><td><code>-G</code>：<code>--groups</code></td><td>显示用户所属附加群组的ID</td></tr><tr><td><code>-n</code>：<code>--name</code></td><td>显示用户，所属群组或附加群组的名称</td></tr><tr><td><code>-r</code>：<code>--real</code></td><td>显示实际ID</td></tr><tr><td><code>-u</code>：<code>--user</code></td><td>显示用户ID</td></tr></tbody></table></li><li><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# id lamp</span><br><span class="line">uid=501(lamp) gid=501(lamp) groups=501(lamp)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">能看到uid(用户ID)、gid(初始组ID), <span class="built_in">groups</span>是用户所在组，这里既可以看到初始组，如果有附加组，则也能看到附加组</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-4-15-su-用户间切换">8.4.15 su 用户间切换</h4><p>Linux su（英文全拼：switch user）命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# su [options] username</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[lamp@localhost ~]$ su -root</span><br><span class="line">密码： &lt;-- 输入 root 用户的密码</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;-&quot;</span>代表连带环境变量一起切换，不能省略</span></span><br><span class="line"></span><br><span class="line">[lamp@localhost ~]$ su - -c ls root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变更帐号为 root 并在执行 <span class="built_in">ls</span> 指令后退出变回原使用者</span></span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境<br>（包括 PATH 变量、MAIL 变量等），使用 - 选项可省略用户名，默认会切换为 root 用户。</td></tr><tr><td><code>-l</code></td><td>同 - 的使用类似，也就是在切换用户身份的同时，完整切换工作环境，但后面需要添加欲切换的使用者账号。</td></tr><tr><td><code>-p</code>：<code>-m</code></td><td>表示切换为指定用户的身份，但不改变当前的工作环境（不使用切换用户的配置文件）。</td></tr><tr><td><code>-c 命令</code></td><td>仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。</td></tr></tbody></table></li><li><p><strong><code>su</code> 和 <code>su -</code> 的区别</strong></p><p>使用 su 命令时，有 - 和没有 - 是完全不同的，- 选项表示在切换用户身份的同时，连当前使用的环境变量也切换成指定用户的。我们知道，环境变量是用来定义操作系统环境的，因此如果系统环境没有随用户身份切换，很多命令无法正确执行。</p><ul><li><p>eg.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lamp@localhost ~]$ whoami</span><br><span class="line">lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询用户身份，我是lamp</span></span><br><span class="line">[lamp@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">&lt;-输入root密码</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换到root，但是没有切换环境变量。注意：普通用户切换到root需要密码</span></span><br><span class="line">[root@localhost ~]# env | grep lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看环境变量，提取包含lamp的行</span></span><br><span class="line">USER=lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名还是lamp，而不是root</span></span><br><span class="line">PATH=/usr/lib/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/lamp/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令査找的路径不包含超级用户路径</span></span><br><span class="line">MAIL=/var/spool/mail/lamp</span><br><span class="line">PWD=/home/lamp</span><br><span class="line">LOGNAME=lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">邮箱、主目录、目前用户名还是lamp</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[lamp@localhost ~]$ whoami</span><br><span class="line">lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前我是lamp</span></span><br><span class="line">[lamp@localhost ~]$ su - -c &quot;useradd user1&quot; root</span><br><span class="line">密码：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不切换成root，但是执行useradd命令添加user1用户</span></span><br><span class="line">[lamp@localhost ~]$ whoami</span><br><span class="line">lamp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我还是lamp</span></span><br><span class="line">[lamp@localhost ~]$ grep &quot;user1&#x27; /etc/passwd</span><br><span class="line">userl:x:502:504::/home/user1:/bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user用户已经添加了</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-4-16-who-查看登录用户信息">8.4.16 who 查看登录用户信息</h4><p>Linux中 who 命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who [options]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# whoami</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-H</code>：<code>--heading</code></td><td>显示各栏位的标题信息列</td></tr><tr><td><code>-i</code> ： <code>-u</code>：<code>--idle</code></td><td>显示闲置时间，若该用户在前一分钟之内有进行任何动作，<br>将标示成&quot;.&quot;号，如果该用户已超过24小时没有任何动作，则<br>标示出&quot;old&quot;字符串</td></tr><tr><td><code>-m</code>：<code>am i</code></td><td>登陆当前系统的用户名</td></tr><tr><td><code>-q</code>：<code>--count</code></td><td>只显示登入系统的帐号名称和总人数</td></tr><tr><td><code>-s</code></td><td>此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题</td></tr><tr><td><code>-w</code> ：<code>-T</code>：<code>--mesg</code>：<code>--message</code>：<code>--writable</code></td><td>显示用户的信息状态栏</td></tr><tr><td><code>--help</code></td><td>在线帮助</td></tr><tr><td><code>--version</code></td><td>显示版本信息</td></tr></tbody></table></li><li><p><strong><font style="color:red"><code>whoami</code> 和 <code>who am i</code> 区别</font></strong></p><p>whoami 命令和 who am i 命令是不同的 2 个命令，前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 Linux 系统的用户名。</p><p>为了能够更好地区分这 2 个命令的功能，给大家举个例子，我们首先使用用户名为“Cyuyan”登陆 Linux 系统，然后执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Cyuyan@localhost ~]$ whoami</span><br><span class="line">Cyuyan</span><br><span class="line">[Cyuyan@localhost ~]$ who am i</span><br><span class="line">Cyuyan  pts/0  2017-10-09 15:30 (:0.0)</span><br></pre></td></tr></table></figure><p>在此基础上，使用 su 命令切换到 root 用户下，再执行一遍上面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Cyuyan@localhost ~] su - root</span><br><span class="line">[root@localhost ~]$ whoami</span><br><span class="line">root</span><br><span class="line">[root@localhost ~]$ who am i</span><br><span class="line">Cyuyan  pts/0  2017-10-09 15:30 (:0.0)</span><br></pre></td></tr></table></figure><p>看到了吗？在未切换用户身份之前，whoami 和 who am i 命令的输出是一样的，但使用 su 命令切换用户身份后，使用 whoami 命令打印的是切换后的用户名，而 who am i 命令打印的仍旧是登陆系统时所用的用户名。</p><blockquote><p>执行 whoami 命令，等同于执行 id -un 命令；执行 who am i 命令，等同于执行 who -m 命令。</p></blockquote></li></ul><h4 id="8-4-17-groupadd-添加用户组">8.4.17 groupadd 添加用户组</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd [options] groupname</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-g</td><td>指定新建工作组的 id</td></tr><tr><td>-r</td><td>创建系统工作组，系统工作组的组 ID 小于 500</td></tr><tr><td>-K</td><td>覆盖配置文件 <code>/etc/login.defs</code></td></tr><tr><td>-o</td><td>允许添加组 ID 号不唯一的工作组</td></tr><tr><td>-f：–force</td><td>如果指定的组已经存在，此选项将失明了仅以成功状态退出。当与 -g 一起使用，并且指定的 GID_MIN 已经存在时，选择另一个唯一的 GID（即 -g 关闭）</td></tr></tbody></table></li><li><p>相关文件</p><ul><li><p><code>/etc/group</code> 组账户信息。</p></li><li><p><code>/etc/gshadow</code> 安全组账户信息。</p></li><li><p><code>/etc/login.defs</code> Shadow密码套件配置。</p></li></ul></li></ul><h4 id="8-4-18-groupmod-修改用户组">8.4.18 groupmod 修改用户组</h4><p>Linux groupmod命令用于更改群组识别码或名称。需要更改群组的识别码或名称时，可用groupmod指令来完成这项工作。</p><p><strong><font style="color:red">※注意：用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。</font></strong></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupmod [options] groupname</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-g &lt;群组识别码&gt;</td><td>设置欲使用的群组识别码</td></tr><tr><td>-o</td><td>重复使用群组识别码</td></tr><tr><td>-n &lt;新群组名称&gt;</td><td>设置欲使用的群组名称</td></tr></tbody></table></li></ul><h4 id="8-4-19-groupdel-刪除用户组">8.4.19 groupdel 刪除用户组</h4><p>Linux groupdel命令用于删除群组。需要从系统上删除群组时，可用groupdel(group delete)指令来完成这项工作。倘若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><p><strong><font style="color:red">※注意：不能使用 groupdel 命令随意删除群组。此命令仅适用于删除那些 “不是任何用户初始组” 的群组，换句话说，如果有群组还是某用户的初始群组，则无法使用 groupdel 命令成功删除。</font></strong></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupdel groupname</span><br></pre></td></tr></table></figure></li><li><p><strong>实例</strong></p><ol><li><p>groupdel 命令删除 temp 群组失败，且提示“不能删除 temp 用户的初始组”。如果一定要删除 temp 群组，要么修改 temp 用户的 GID，也就是将其初始组改为其他群组，要么先删除 temp 用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd temp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行如下命令，可以看到 temp 用户建立的同时，还创建了 temp 群组，且将其作为 temp用户的初始组（组ID都是 505）</span></span><br><span class="line">[root@localhost ~]# grep &quot;temp&quot; /etc/passwd /etc/group /etc/gshadow</span><br><span class="line">/etc/passwd:temp:x:505:505::/home/temp:/bin/bash</span><br><span class="line">/etc/group:temp:x:505:</span><br><span class="line">/etc/gshadow:temp:!::</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面尝试删除 temp 群组</span></span><br><span class="line">[root@localhost ~]# groupdel temp</span><br><span class="line">groupdel:cannot remove the primary group of user &#x27;temp&#x27;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="8-4-20-gpasswd-把用户添加进组或从组中删除">8.4.20 gpasswd 把用户添加进组或从组中删除</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gpasswd [options] groupname</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td></td><td>选项为空时，表示给群组设置密码（仅 root 用户可用）</td></tr><tr><td><code>-A user1,...</code></td><td>将群组的控制权交给 user1,… 等用户管理，也就是说，设置 user1,… 等用户为群组的管理员（仅 root 用户可用）</td></tr><tr><td><code>-M user1,...</code></td><td>将 user1,… 加入到此群组中（仅 root 用户可用）</td></tr><tr><td><code>-r</code></td><td>移除群组的密码（仅 root 用户可用）</td></tr><tr><td><code>-R</code></td><td>让群组的密码失效（仅 root 用户可用）</td></tr><tr><td><code>-a user</code></td><td>将 user 用户加入到群组中</td></tr><tr><td><code>-d user</code></td><td>将 user 用户从群组中移除</td></tr></tbody></table><p>可设置多个普通用户作为群组的管理员，但也只能做“将用户加入群组”和“将用户移出群组”的操作。</p></li><li><p><strong>实例</strong></p><ol><li><p>设置 lamp 用户为 group1 群组的管理员：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建新群组 group1，并将群组交给 lamp 管理</span></span><br><span class="line">[root@localhost ~]# groupadd group1  &lt;-- 创建群组</span><br><span class="line">[root@localhost ~]# gpasswd group1   &lt;-- 设置密码吧！</span><br><span class="line">Changing the password for group group1</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br><span class="line">[root@localhost ~]# gpasswd -A lamp group1  &lt;==加入群组管理员为 lamp</span><br><span class="line">[root@localhost ~]# grep &quot;group1&quot; /etc/group /etc/gshadow</span><br><span class="line">/etc/group:group1:x:506:</span><br><span class="line">/etc/gshadow:group1:$1$I5ukIY1.$o5fmW.cOsc8.K.FHAFLWg0:lamp:</span><br></pre></td></tr></table></figure></li><li><p>用群主管理员加入群主成员:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以lamp用户登陆系统，并将用户 lamp 和 lamp1 加入group1群组。</span></span><br><span class="line">[lamp@localhost ~]#gpasswd -a lamp group1</span><br><span class="line">[lamp@localhost ~]#gpasswd -a lamp1 group1</span><br><span class="line">[lamp@localhost ~]#grep &quot;group1&quot; /etc/group</span><br><span class="line">group1:x:506:lamp,lamp1</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>usermod -G</code> 命令也可以将用户加入群组，但会产生一个问题，即使用此命令将用户加入到新的群组后，该用户之前加入的那些群组都将被清空:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新创建一个群组group2</span></span><br><span class="line">[root@localhost ~]# groupadd group2</span><br><span class="line">[root@localhost ~]# usermod -G group2 lamp</span><br><span class="line">[root@localhost ~]# grep &quot;group2&quot; /etc/group</span><br><span class="line">group2:x:509:lamp</span><br><span class="line">[root@localhost ~]# grep &quot;group1&quot; /etc/group</span><br><span class="line">group1:x:506:lamp1</span><br></pre></td></tr></table></figure><p>对比例 2 可以发现，虽然使用 usermod 命令成功地将 lamp 用户加入在 group2 群组中，但 lamp 用户原本在 group1 群组中，此时却被移出，这就是使用 usermod 命令造成的。因此，将用户加入或移出群组，最好使用 gpasswd 命令。</p></li></ol></li></ul><h4 id="8-4-21-newgrp-切换用户的有效组">8.4.21 newgrp 切换用户的有效组</h4><p>newgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。</p><p>每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。用户可以属于这么多用户组，用户在创建文件后，初始用户组的组身份生效。既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# newgrp 组名</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>newgrp命令的底层实现</strong></p><p>newgrp 命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。</p><blockquote><p>以下实例中，通过添加 shell 内置命令 “echo $$” 就可以发现，每次使用 newgrp 命令，都会切换到一个新的进程。</p></blockquote><p>在本节实例中，使用 newgrp 命令切换用户初始组的整个过程：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Z4121K230D9.gif" alt="newgrp 切换初始组程序运行过程图"></p></li><li><p><strong>实例</strong></p><p>通过一个实例，讲解此命令的具体用法和功能：</p><ol><li><p>首先，建立 3 个用户组 group1、group2 和 group3，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd group1</span><br><span class="line">[root@localhost ~]# groupadd group2</span><br><span class="line">[root@localhost ~]# groupadd group3</span><br></pre></td></tr></table></figure></li><li><p>创建一个用户 user1，同时指定 user1 的初始组为 group1，附加组为 group2 和 group3，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd -g group1 -G group2,group3 user1</span><br><span class="line">\#由于指定了初始组，因此不会在创建 user1 默认群组</span><br><span class="line">[root@localhost ~]# more /etc/group | grep user1</span><br><span class="line">group2:x:501:user1</span><br><span class="line">group3:x:502:user1</span><br></pre></td></tr></table></figure></li><li><p>对用户 user1 设置密码，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line">Changing password for user user1.</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure></li><li><p>切换至 user1 用户，通过 newgrp 切换用户组进行下列操作，读者可从中体会出 newgrp 命令的作用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\#切换至 user1 用户</span><br><span class="line">[root@localhost ~]# su - user1</span><br><span class="line">[root@localhost ~]# whoami</span><br><span class="line">user1</span><br><span class="line">\#使用 newgrp 命令一边切换 user1 的初始组，一边创建文件</span><br><span class="line">[root@localhost ~]# mkdir user1_doc</span><br><span class="line">[root@localhost ~]# newgrp group2</span><br><span class="line">[root@localhost ~]# mkdir user2_doc</span><br><span class="line">[root@localhost ~]# newgrp group3</span><br><span class="line">[root@localhost ~]# mkdir user3_doc</span><br><span class="line">\#查看各文件的详细信息</span><br><span class="line">[root@localhost ~]# ll</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 user1 group1 4096 Oct 24 01:18 user1_doc</span><br><span class="line">drwxr-xr-x 2 user1 group2 4096 Oct 24 01:18 user2_doc</span><br><span class="line">drwxr-xr-x 2 user1 group3 4096 Oct 24 01:19 user3_doc</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>​ 通过使用 newgrp 命令切换用户的初始组，所创建的文件各自属于不同的群组，这就是 newgrp 所发挥的作用，即通过切换附加组成为新的初始组，从而让用户获得使用各个附加组的权限。</p><h3 id="8-6-权限管理">8.6 权限管理</h3><h4 id="8-6-2-chgrp-修改文件和目录的所属组">8.6.2 chgrp 修改文件和目录的所属组</h4><p>Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。</p><p>与 <code>chown</code> 命令不同，<code>chgrp</code> 允许普通用户改变文件所属的组，只要该用户是该组的一员。</p><p>在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 <code>chgrp</code> 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><ul><li><p><strong>语法</strong></p><p>使用此命令需要注意的一点是，要被改变的群组名必须是真实存在的，否则命令无法正确执行，会提示 “invaild group name”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chgrp [options] group file</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-c</code>：<code>--changes</code></td><td>效果类似&quot;-v&quot;参数，但仅回报更改的部分</td></tr><tr><td><code>-f</code>：<code>--quiet</code>：<code>--silent</code></td><td>不显示错误信息</td></tr><tr><td><code>-h</code>：<code>--no-dereference</code></td><td>只对符号连接的文件作修改，而不改动其他任何相关文件</td></tr><tr><td><code>-R</code>：<code>--recursive</code></td><td>用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过</td></tr><tr><td><code>-reference=&lt;参考文件或目录&gt;</code></td><td>指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>当以 root 身份登录 Linux 系统时，主目录中会存在一个名为 install.log 的文件，我们可以使用如下方法修改此文件的所属组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd group1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建用于测试的群组 group1</span></span><br><span class="line">[root@localhost ~]# chgrp group1 install.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改install.log文件的所属组为group1</span></span><br><span class="line">[root@localhost ~]# ll install.log</span><br><span class="line">-rw-r--r--. 1 root group1 78495 Nov 17 05:54 install.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改生效</span></span><br><span class="line">[root@localhost ~]# chgrp testgroup install.log</span><br><span class="line">chgrp: invaild group name &#x27;testgroup&#x27;</span><br></pre></td></tr></table></figure><p>可以看到，在具有 group1 群组的前提下，我们成功修改了 install.log 文件的所属组，但我们再次试图将所属组修改为 testgroup 时，命令执行失败，就是因为系统的 /etc/group 文件中，没有 testgroup 群组。</p></li></ol></li></ul><h4 id="8-6-3-chown-修改文件和目录的所有者和所属组">8.6.3 chown 修改文件和目录的所有者和所属组</h4><p><strong><font style="color:red">只有<u>超级用户</u>和<u>属于组的文件所有者</u>才能变更文件关联组</font></strong>。非超级用户如需要设置关联组可能需要使用 <code>chgrp</code> 命令。</p><p>Linux chown（英文全拼：<strong>change owner</strong>）命令用于设置文件所有者和文件关联组的命令。</p><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 <code>chown</code> 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chown [options] user[:group] file</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归修改目录所属</span></span><br><span class="line">[root@localhost ~]# chown -R user file</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><ul><li>user : 新的文件拥有者的使用者 ID</li><li>group : 新的文件拥有者的使用者组(group)</li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>表示连同子目录中的所有文件，都更改所有者</td></tr><tr><td>-c</td><td>显示更改的部分的信息</td></tr><tr><td>-f</td><td>忽略错误信息</td></tr><tr><td>-v</td><td>显示详细的处理信息</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>修改文件的所有者，更多时候是为了得到更高的权限，举一个实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch file</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由root用户创建file文件</span></span><br><span class="line">[root@localhost ~]# ll file</span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:12 file</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件的所有者是root，普通用户user对这个文件拥有只读权限</span></span><br><span class="line">[root@localhost ~]# chown user file</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件的所有者</span></span><br><span class="line">[root@localhost ~]# ll file</span><br><span class="line">-rw-r--r--. 1 user root 0 Apr 17 05:12 file</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有者变成了user用户，这时user用户对这个文件就拥有了读、写权限</span></span><br></pre></td></tr></table></figure><p>可以看到，通过修改 file 文件的所有者，user 用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。</p></li><li><p>Linux 系统中，用户等级权限的划分是非常清楚的，root 用户拥有最高权限，可以修改任何文件的权限，而普通用户只能修改自己文件的权限（所有者是自己的文件），例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /home/user</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入user用户的家目录</span></span><br><span class="line">[root@localhost user]# touch test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由root用户新建文件<span class="built_in">test</span></span></span><br><span class="line">[root@localhost user]# ll test</span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:37 test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件所有者和所属组都是root用户</span></span><br><span class="line">[root@localhost user]# su - user</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换为user用户</span></span><br><span class="line">[user@localhost ~]$ chmod 755 test</span><br><span class="line">chmod:更改&quot;test&quot;的权限：不允许的操作 #user用户不能修改test文件的权限</span><br><span class="line">[user@localhost ~]$ exit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退回到root身份</span></span><br><span class="line">[root@localhost user]# chown user test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">由root用户把<span class="built_in">test</span>文件的所有者改为user用户</span></span><br><span class="line">[root@localhost user]# su - user</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换为user用户</span></span><br><span class="line">[user@localhost ~]$ chmod 755 test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user用户由于是<span class="built_in">test</span>文件的所有者，所以可以修改文件的权限</span></span><br><span class="line">[user@localhost ~]$ ll test</span><br><span class="line">-rwxr-xr-x. 1 user root 0 Apr 17 05:37 test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看权限</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="8-6-5-r、-w、-x-读写执行权限">8.6.5 (-r、-w、-x) 读写执行权限</h4><p>文件，是系统中用来存储数据的，包括普通的文本文件、数据库文件、二进制可执行文件，等等。那么，读（r）、写（w）、执行（x）权限到底指的是什么呢？</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/rwx2.png" alt="rwx2"></p><p><code>-rwxrwxrwx</code>从左至右用0-9这些数字来表示。第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><ul><li><p><strong>权限对文件的作用</strong></p><p>对于文件来说，执行权限是最高权限。给用户或群组设定权限时，是否赋予执行权限需要慎重考虑，否则会对系统安装造成严重影响。</p><table><thead><tr><th>rwx 权限</th><th>对文件的作用</th></tr></thead><tbody><tr><td>读权限（r）</td><td>表示可读取此文件中的实际内容，例如，可以对文件执行 cat、more、less、head、tail 等文件查看命令。</td></tr><tr><td>写权限（w）</td><td>表示可以编辑、新增或者修改文件中的内容，例如，可以对文件执行 vim、echo 等修改文件数据的命令。<br>注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。</td></tr><tr><td>执行权限（x）</td><td>表示该文件具有被系统执行的权限。Window系统中查看一个文件是否为可执行文件，是通过扩展名（.exe、.bat 等），<br>但在 Linux 系统中，文件是否能被执行，是通过看此文件是否具有 x 权限来决定的。也就是说，只要文件拥有 x 权限，<br>则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。</td></tr></tbody></table></li><li><p><strong>权限对目录的作用</strong></p><p>对目录来说，如果只赋予 r 权限，则此目录是无法使用的。很简单，只有 r 权限的目录，用户只能查看目录结构，根本无法进入目录（需要用 x 权限），更不用说使用了。因此，对于目录来说，常用来设定目录的权限其实只有 0（—）、5（r-x）、7（rwx）这 3 种。</p><table><thead><tr><th>rwx 权限</th><th>对目录的作用</th></tr></thead><tbody><tr><td>读权限（r）</td><td>表示具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有 r 权限，就可以在此目录下执行 ls 命令，查看目录中的内容。</td></tr><tr><td>写权限（w）</td><td>对于目录来说，w 权限是最高权限。对目录拥有 w 权限，表示可以对目录做以下操作：<br>·在此目录中建立新的文件或子目录；<br>·删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；<br>·对已存在的文件或目录做更名操作；<br>·移动此目录下的文件和目录的位置。<br>一旦对目录拥有 w 权限，就可以在目录下执行 touch、rm、cp、mv 等命令。</td></tr><tr><td>执行权限（x）</td><td>目录是不能直接运行的，对目录赋予 x 权限，代表用户可以进入目录，也就是说，赋予 x 权限的用户或群组可以使用 cd 命令。</td></tr></tbody></table></li><li><p>第一个字符的意义 <code>-rwxrwxrwx</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/rwx.png" alt="rwx"></p><p>第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li><p>当为[ <em>d</em> ]则是目录</p></li><li><p>当为[ <em>-</em> ]则是文件；</p></li><li><p>若是[ <em>l</em> ]则表示为链接文档(link file)；</p></li><li><p>若是[ <em>b</em> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</p></li><li><p>若是[ <em>c</em> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p></li></ul></li></ul><h4 id="8-6-6-chmod-修改文件或目录的权限">8.6.6 chmod 修改文件或目录的权限</h4><p><strong><font style="color:red">只有<u>文件所有者</u>和<u>超级用户</u>可以修改文件或目录的权限</font></strong></p><p>Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令。</p><p>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Untitled.png" alt="Untitled"></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod [who] [options] [operator] permission name</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><ul><li><p>who（用户类型）：<code>u</code> 表示该文件的拥有者，<code>g</code> 表示与该文件的拥有者属于同一个群体(group)者，<code>o</code> 表示其他以外的人，<code>a</code> 表示这三者皆是。</p></li><li><p>operator（操作符）：<code>+</code> 表示增加权限、<code>-</code> 表示取消权限、<code>=</code> 表示唯一设定权限</p></li><li><p>permission（权限）：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-R</td><td>连同子目录中的所有文件，也都修改设定的权限（递归的方式逐个变更）</td></tr><tr><td>-c</td><td>若该文件权限确实已经更改，才显示其更改动作</td></tr><tr><td>-f</td><td>若该文件权限无法被更改也不要显示错误讯息</td></tr><tr><td>-v</td><td>显示权限变更的详细资料</td></tr></tbody></table></li></ul></li><li><p><strong>使用数字来代表各个权限</strong></p><blockquote><p>r=4，w=2，x=1</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/rwxNum.png" alt="rwxNum"></p><ul><li><p>八进制语法</p><table><thead><tr><th>#</th><th>权限</th><th>rwx</th><th>二进制</th></tr></thead><tbody><tr><td>7</td><td>读 + 写 + 执行</td><td>rwx</td><td>111</td></tr><tr><td>6</td><td>读 + 写</td><td>rw-</td><td>110</td></tr><tr><td>5</td><td>读 + 执行</td><td>r-x</td><td>101</td></tr><tr><td>4</td><td>只读</td><td>r–</td><td>100</td></tr><tr><td>3</td><td>写 + 执行</td><td>-wx</td><td>011</td></tr><tr><td>2</td><td>只写</td><td>-w-</td><td>010</td></tr><tr><td>1</td><td>只执行</td><td>–x</td><td>001</td></tr><tr><td>0</td><td>无</td><td>—</td><td>000</td></tr></tbody></table></li></ul></li><li><p><strong>实例</strong></p><ol><li><p>设定 .bashrc 文件的权限为 rwxr-xr-x，则可执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod u=rwx,go=rx .bashrc</span><br><span class="line">[root@localhost ~]# ls -al .bashrc</span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure></li><li><p>增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -al .bashrc</span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br><span class="line">[root@localhost ~]# chmod a+w .bashrc</span><br><span class="line">[root@localhost ~]# ls -al .bashrc</span><br><span class="line">-rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="8-6-16-chattr-修改文件系统的权限属性">8.6.16 chattr 修改文件系统的权限属性</h4><p>管理 Linux 系统中的文件和目录，除了可以设定普通权限和特殊权限外，还可以利用文件和目录具有的一些隐藏属性。</p><p>chattr 命令，专门用来修改文件或目录的隐藏属性，只有 root 用户可以使用。该命令的基本格式为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chattr [+-=] [属性] 文件或目录名</span></span><br></pre></td></tr></table></figure><p>+ 表示给文件或目录添加属性，- 表示移除文件或目录拥有的某些属性，= 表示给文件或目录设定一些属性。</p><table><caption>表 1 chattr 命令常用的属性选项及功能</caption><tbody><tr><th>属性选项</th><th>功能</th></tr><tr><td>i</td><td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；<br>如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td></tr><tr><td>a</td><td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据；<br>如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td></tr><tr><td>u</td><td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td></tr><tr><td>s</td><td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。</td></tr></tbody></table><p>【例 1】 给文件赋予 i 属性</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch ftest</span></span><br><span class="line"><span class="comment">#建立测试文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chattr +i ftest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf ftest</span></span><br><span class="line"><span class="built_in">rm</span>:cannot remove <span class="string">&#x27;ftest&#x27;</span>:Operation not permitted</span><br><span class="line"><span class="comment">#无法删除&quot;ftesr&quot;，操作不允许</span></span><br><span class="line"><span class="comment">#被赋予i属性后，root不能删除</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo 111&gt;&gt;ftest</span></span><br><span class="line">bash:ftest:Permission denied</span><br><span class="line"><span class="comment">#权限不够，不能修改文件中的数据</span></span><br></pre></td></tr></table></figure><p>可以看到，设置有 i 属性的文件，即便是 root 用户，也无法删除和修改数据。</p><p>【例 2】为目录赋予 i 属性</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir dtest</span></span><br><span class="line"><span class="comment">#建立测试目录</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># touch dtest/abc</span></span><br><span class="line"><span class="comment">#再建立一个测试文件abc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chattr +i dtest</span></span><br><span class="line"><span class="comment">#给目录赋予i属性</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd dtest</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># touch bed</span></span><br><span class="line"><span class="built_in">touch</span>: cannot <span class="built_in">touch</span> <span class="string">&#x27;bed&#x27;</span>:Permission denied</span><br><span class="line"><span class="comment">#无法创建&quot;bcd&quot;，权限不够，dtest目录不能新建文件</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># echo 11&gt;&gt;abc</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># cat abc</span></span><br><span class="line">11</span><br><span class="line"><span class="comment">#可以修改文件内容</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># rm -rf abc</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;abc&#x27;</span>: Permission denied</span><br><span class="line"><span class="comment">#无法删除&quot;abc&quot;，权限不够</span></span><br></pre></td></tr></table></figure><p>一旦给目录设置 i 属性，即使是 root 用户，也无法在目录内部新建或删除文件，但可以修改文件内容。</p><p>给设置有 i 属性的文件删除此属性也很简单，只需将 chattr 命令中 + 改为 - 即可。</p><p>【例 3】演示 a 属性的作用。假设有这样一种应用，我们每天自动实现把服务器的日志备份到指定目录，备份目录可设置 a 属性，变为只可创建文件而不可删除。命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /back/log</span></span><br><span class="line"><span class="comment">#建立备份目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chattr +a /back/log</span></span><br><span class="line"><span class="comment">#赋予a属性</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /var/log/messages /back/log</span></span><br><span class="line"><span class="comment">#可以复制文件和新建文件到指定目录中</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf /back/log/messages</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;/back/log/messages&#x27;</span>: Permission denied</span><br><span class="line"><span class="comment">#无法删除 /back/log/messages，操作不允许</span></span><br></pre></td></tr></table></figure><p>注意，通常情况下，不要使用 chattr 命令修改 /、/dev/、/tmp/、/var/ 等目录的隐藏属性，很容易导致系统无法启动。另外，chatrr 命令常与 lsattr 命令合用，前者修改文件或目录的隐藏属性，后者用于查看是否修改成功。有关 lsattr 命令，放到下节讲解。</p><h4 id="8-6-18-sudo-系统权限管理">8.6.18 sudo 系统权限管理</h4><p>Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p><p>su 命令可以让普通用户切换到 root 身份去执行某些特权命令，但存在一些问题，比如说：</p><ul><li>仅仅为了一个特权操作就直接赋予普通用户控制系统的完整权限；</li><li>当多人使用同一台主机时，如果大家都要使用 su 命令切换到 root 身份，那势必就需要 root 的密码，这就导致很多人都知道 root 的密码；</li></ul><p>考虑到使用 su 命令可能对系统安装造成的隐患，最常见的解决方法是使用 sudo 命令，此命令也可以让你切换至其他用户的身份去执行命令。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sudo [-b] [-u newUserName] command</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sudo [-b] [-u 新使用者账号] 要执行的命令</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>将后续的命令放到背景中让系统自行运行，不对当前的 shell 环境产生影响</td></tr><tr><td>-u</td><td>后面可以接欲切换的用户名，若无此项则代表切换身份为 root</td></tr><tr><td>-l</td><td>此选项的用法为 sudo -l，用于显示当前用户可以用 sudo 执行那些命令</td></tr></tbody></table></li><li><p><strong>sudo命令的配置文件<code>/etc/sudoers</code></strong></p><p>修改 <code>/etc/sudoers</code>，不建议直接使用 vim，而是使用 visudo。因为修改 <code>/etc/sudoers</code> 文件需遵循一定的语法规则，使用 visudo 的好处就在于，当修改完毕 <code>/etc/sudoers</code> 文件，离开修改页面时，系统会自行检验 <code>/etc/sudoers</code> 文件的语法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">…省略部分输出…</span><br><span class="line">root ALL=(ALL) ALL  &lt;--大约 76 行的位置</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">%wheel ALL=(ALL) ALL   &lt;--大约84行的位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">%组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span></span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><table><thead><tr><th>模块</th><th>含义</th></tr></thead><tbody><tr><td>用户名或群组名</td><td>表示系统中的那个用户或群组，可以使用 sudo 这个命令。</td></tr><tr><td>被管理主机的地址</td><td>用户可以管理指定 IP 地址的服务器。这里如果写 ALL，<br>则代表用户可以管理任何主机；如果写固定 IP，则代表用户可以管理指定的服务器。<br>如果我们在这里写本机的 IP 地址，不代表只允许本机的用户使用指定命令，<br>而是代表指定的用户可以从任何 IP 地址来管理当前服务器。</td></tr><tr><td>可使用的身份</td><td>就是把来源用户切换成什么身份使用，（ALL）代表可以切换成任意身份。这个字段可以省略。</td></tr><tr><td>授权命令</td><td>表示 root 把什么命令命令授权给用户，换句话说，可以用切换的身份执行什么命令。需要注<br>意的是，此命令必须使用绝对路径写。默认值是 ALL，表示可以执行任何命令。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>本例中，无法使用sshd登入。 su - sshd 的方式成功切换到 sshd 账户中，因为此用户的默认 Shell 是 /sbin/nologin。这时就显现出 sudo 的优势，我们可以使用 sudo 以 sshd 的身份在 /tmp 目录下创建 mysshd 文件，可以看到，新创建的 mysshd 文件的所有者确实是 sshd。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  grep sshd /etc/passwd</span><br><span class="line">sshd:x:74:74:privilege-separated SSH:/var/empty/sshd:/sbin.nologin</span><br><span class="line">[root@localhost ~]#  sudo -u sshd touch /tmp/mysshd</span><br><span class="line">[root@localhost ~]#  ll /tmp/mysshd</span><br><span class="line">-rw-r--r-- 1 sshd sshd 0 Feb 28 17:42 /tmp/mysshd</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="8-7-查询">8.7 查询</h3><h4 id="8-7-1-find-查找文件或者目录">8.7.1 find 查找文件或者目录</h4><p>find 是 Linux 中强大的搜索命令，不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode 号等来搜索文件。但是 find 命令是直接在硬盘中进行搜索的，如果指定的搜索范围过大，find命令就会消耗较大的系统资源，导致服务器压力过大。所以，在使用 find 命令搜索时，不要指定过大的搜索范围。</p><p><code>/bin/find</code></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find [path] [expression] [[搜索内容][处理动作]]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件名称符合 name 的文件,并忽略大小写</span></span><br><span class="line">[root@localhost ~]# find / -iname [处理动作]</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><ul><li><p>path：查找开始的位置，为空字符串则为当前路径 <code>./</code> 。</p></li><li><p>expression：查找条件，如果为空字符串则使用 <code>-print</code> 为预设 。</p><table><thead><tr><th>查找条件</th><th>说明</th></tr></thead><tbody><tr><td><code>-amin n</code></td><td>在过去 n 分钟内被读取过</td></tr><tr><td><code>-anewer file</code></td><td>比文件 file 更晚被读取过的文件</td></tr><tr><td><code>-atime [[][+][-]]time</code></td><td>空字符：表示在前 n~n+1 天内读取过的文件;<br>+n：代表 n 天前读取的文件<br>-n：代表 n 天内读取的文件</td></tr><tr><td><code>-cmin n</code></td><td>在过去 n 分钟内被修改过</td></tr><tr><td><code>-cnewer file</code></td><td>比文件 file 更新的文件</td></tr><tr><td><code>-ctime [[][+][-]]time</code></td><td>空字符：表示在前 n~n+1 天内创建过的文件;<br>+n：代表 n 天前创建的文件<br>-n：代表 n 天内创建的文件</td></tr><tr><td><code>-empty</code></td><td>空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</td></tr><tr><td><code>-inum</code></td><td>按照 inode 号搜索</td></tr><tr><td><code>-ipath p</code>，<code>-path p</code></td><td>路径名称符合 p 的文件，ipath 会忽略大小写</td></tr><tr><td><code>-mtime [[][+][-]]time</code></td><td>空字符：表示在前 n~n+1 天内修改过的文件;<br>+n：代表 n 天前修改的文件<br>-n：代表 n 天内修改的文件</td></tr><tr><td><code>-mount, -xdev</code></td><td>只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</td></tr><tr><td><code>-name name</code>，<code>-iname name</code></td><td>文件名称符合 name 的文件。iname 会忽略大小写</td></tr><tr><td><code>-size [[+][-]]&lt;size&gt;&lt;units&gt;</code></td><td><code>+-</code>：加号表大于（省），减号表小于；<br>size：大小；<br>units：单位 <code>c</code>-Byte,<code>k</code>-kb，<code>M</code>-mb;</td></tr><tr><td><code>-type 类型</code></td><td>b: 区块装置文件<br>c: 字型装置文件<br>d: 查找目录<br>f: 一般文件<br>l: 符号连结<br>p: 具名贮列<br>s: socket</td></tr></tbody></table></li></ul></li><li><p><strong>实例</strong></p><ol><li><p>将当前目录及其子目录下所有文件后缀为 <strong>.c</strong> 的文件列出来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find . -name &quot;*.c&quot;</span><br></pre></td></tr></table></figure></li><li><p>将当前目录及其子目录中的所有文件列出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find . -type f</span><br></pre></td></tr></table></figure></li><li><p>将当前目录及其子目录下所有最近 20 天内更新过的文件列出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find . -ctime  20</span><br></pre></td></tr></table></figure></li><li><p>查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find /var/log -type f -mtime +7 -ok rm &#123;&#125; \\;</span><br></pre></td></tr></table></figure></li><li><p>查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find . -type f -perm 644 -exec ls -l &#123;&#125; \\;</span><br></pre></td></tr></table></figure></li><li><p>查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -type f -size 0 -exec ls -l &#123;&#125; \\;</span><br></pre></td></tr></table></figure></li></ol></li></ul><blockquote><p>参考文章：</p><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/779.html">Linux find命令：在目录中查找文件（超详解）</a></p></blockquote><h4 id="8-7-2-locate-快速定位文件路径">8.7.2 locate 快速定位文件路径</h4><p>Linux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [options] [样式]</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</td></tr><tr><td>-q</td><td>安静模式，不会显示任何错误讯息。</td></tr><tr><td>-n</td><td>至多显示 n个输出。</td></tr><tr><td>-r</td><td>使用正规运算式 做寻找的条件。</td></tr><tr><td>-o</td><td>指定资料库存的名称。</td></tr><tr><td>-d</td><td>指定资料库的路径</td></tr><tr><td>-h</td><td>显示辅助讯息</td></tr><tr><td>-V</td><td>显示程式的版本讯息</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>搜索etc目录下所有以sh开头的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# locate /etc/sh       </span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/shadow-</span><br><span class="line">/etc/shells</span><br><span class="line">[root@localhost ~]# locate -r &quot;/etc/\sh &quot;  # 正则，锚定词首</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/shadow-</span><br><span class="line">/etc/shells</span><br></pre></td></tr></table></figure></li><li><p>忽略大小写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# locate -i ~/d</span><br><span class="line">/root/Desktop/root/Documents/root/Downloads</span><br><span class="line">/root/d1</span><br><span class="line">/root/dd</span><br><span class="line">/var/lib/pcp/pmdas/root/domain.h</span><br></pre></td></tr></table></figure></li><li><p>更新数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# locate ~/a</span><br><span class="line">/root/anaconda-ks.cfg</span><br><span class="line">[root@localhost ~]# updatedb</span><br><span class="line">[root@localhost ~]# locate ~/a</span><br><span class="line">/root/a.sh</span><br><span class="line">/root/anaconda-ks.cfg</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="8-8-压缩和打包">8.8 压缩和打包</h3><h4 id="8-8-1-gzip-gunzip-压缩-解压缩">8.8.1 gzip/gunzip 压缩/解压缩</h4><p>gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为“.gz”。</p><ul><li><p><strong>gzip 压缩</strong></p><p><font style="color:red">gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。</font></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip [options] 源文件</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-c</code></td><td>将压缩数据输出到标准输出中，并保留源文件。</td></tr><tr><td><code>-d</code></td><td>对压缩文件进行解压缩。</td></tr><tr><td><code>-r</code></td><td>递归压缩指定目录下以及子目录下的所有文件。</td></tr><tr><td><code>-v</code></td><td>对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。</td></tr><tr><td><code>-l</code></td><td>对每一个压缩文件，显示以下字段：<br>压缩文件的大小；<br>未压缩文件的大小；<br>压缩比；<br>未压缩文件的名称。</td></tr><tr><td><code>-数字</code></td><td>用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>gzip 压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip install.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩instal.log 文件</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg install.log.gz install.log.syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成，但是源文件也消失了</span></span><br></pre></td></tr></table></figure></li><li><p>在使用 gzip 命令压缩文件时，源文件会消失，从而生成压缩文件。使用选项<code>-c</code>保留源文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip -c anaconda-ks.cfg &gt;anaconda-ks.cfg.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到压缩文件和源文件都存在</span></span><br></pre></td></tr></table></figure></li><li><p>试试用 gzip 命令可以压缩目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir test</span><br><span class="line">[root@localhost ~]# touch test/test1</span><br><span class="line">[root@localhost ~]# touch test/test2</span><br><span class="line">[root@localhost ~]# touch test/test3 #建立测试目录，并在里面建立几个测试文件</span><br><span class="line">[root@localhost ~]# gzip -r test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩目录，并没有报错</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是查看发现<span class="built_in">test</span>目录依然存在，并没有变为压缩文件</span></span><br><span class="line">[root@localhost ~]# ls test/</span><br><span class="line">testl .gz test2.gz test3.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩</span></span><br></pre></td></tr></table></figure><p>在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。</p></li></ol></li></ul></li><li><p><strong>gunzip 解压</strong></p><p>gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz）</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip [options] 文件</span><br></pre></td></tr></table></figure></li><li><p>选项</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code></td><td>递归处理，解压缩指定目录下以及子目录下的所有文件。</td></tr><tr><td><code>-c</code></td><td>把解压缩后的文件输出到标准输出设备。</td></tr><tr><td><code>-f</code></td><td>强制解压缩文件，不理会文件是否已存在等情况。</td></tr><tr><td><code>-l</code></td><td>列出压缩文件内容。</td></tr><tr><td><code>-v</code></td><td>显示命令执行过程。</td></tr><tr><td><code>-t</code></td><td>测试压缩文件是否正常，但不对其做解压缩操作。</td></tr></tbody></table></li><li><p>实例</p><ol><li><p>直接解压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip install.log.gz</span><br></pre></td></tr></table></figure></li><li><p>“gunzip -r&quot;依然只会解压缩目录下的文件，而不会解打包。要想解压缩”.gz&quot;格式，还可以使用 &quot;gzip -d&quot;命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip -r test/</span><br></pre></td></tr></table></figure></li><li><p>注意，如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下查看这个文本文件中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zcat anaconda-ks.cfg.gz</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h4 id="8-8-2-zip-unzip-压缩-解压缩">8.8.2 zip/unzip 压缩/解压缩</h4><p>我们经常会在 Windows 系统上使用 “.zip”格式压缩文件，其实“.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式（zip、rar等）之一，是一种相当简单的分别压缩每个文件的存储格式。</p><ul><li><p>zip</p><p>zip 命令，类似于 Windows 系统中的 winzip 压缩程序。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip [options] 源文件</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code></td><td>递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td></tr><tr><td><code>-m</code></td><td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td></tr><tr><td><code>-v</code></td><td>显示详细的压缩过程信息。</td></tr><tr><td><code>-q</code></td><td>在压缩的时候不显示命令的执行过程。</td></tr><tr><td><code>-压缩级别</code></td><td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td></tr><tr><td><code>-u</code></td><td>更新压缩文件，即往压缩文件中添加新文件。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>zip 命令的基本使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip ana.zip anaconda-ks.cfg</span><br><span class="line">adding: anaconda-ks.cfg (deflated 37%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩</span></span><br><span class="line">[root@localhost ~]# ll ana.zip</span><br><span class="line">-rw-r--r-- 1 root root 935 6月 1716:00 ana.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure><p>所有的压缩命令都可以同时压缩多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip test.zip install.log install.log.syslog</span><br><span class="line">adding: install.log (deflated 72%)</span><br><span class="line">adding: install.log.syslog (deflated 85%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同时压缩多个文件到test.zip压缩包中</span></span><br><span class="line">[root@localhost ~]#ll test.zip</span><br><span class="line">-rw-r--r-- 1 root root 8368 6月 1716:03 test.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure></li><li><p>使用 zip 命令压缩目录，需要使用“-r”选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir dir1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立测试目录</span></span><br><span class="line">[root@localhost ~]# zip -r dir1.zip dir1</span><br><span class="line">adding: dir1/(stored 0%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩目录</span></span><br><span class="line">[root@localhost ~]# ls -dl dir1.zip</span><br><span class="line">-rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>unzip</p><p>unzip 命令可以查看和解压缩 zip 文件。</p><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip [options] 压缩包名</span><br></pre></td></tr></table></figure></li><li><p>选项</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-d 目录名</code></td><td>将压缩文件解压到指定目录下。</td></tr><tr><td><code>-n</code></td><td>解压时并不覆盖已经存在的文件。</td></tr><tr><td><code>-o</code></td><td>解压时覆盖已经存在的文件，并且无需用户确认。</td></tr><tr><td><code>-v</code></td><td>查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td></tr><tr><td><code>-t</code></td><td>测试压缩文件有无损坏，但并不解压。</td></tr><tr><td><code>-x 文件列表</code></td><td>解压文件，但不包含文件列表中指定的文件。</td></tr></tbody></table></li><li><p>实例</p><ol><li><p>不论是文件压缩包，还是目录压缩包，都可以直接解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip dir1.zip</span><br><span class="line">Archive: dir1.zip</span><br><span class="line">creating: dirl/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压缩</span></span><br></pre></td></tr></table></figure></li><li><p>使用 -d 选项手动指定解压缩位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip -d /tmp/ ana.zip</span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把压缩包解压到指定位置</span></span><br></pre></td></tr></table></figure><p>1</p></li></ol></li></ul></li></ul><h4 id="8-8-3-tar-打包">8.8.3 tar 打包</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar [options] 源文件或目录</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  tar -cvf 打包后名字.tar 文件名1 文件名2 ...    # 打包并压缩</span><br><span class="line">[root@localhost ~]#  tar -xvf 需解压的文件.tar -C 解压的位置    # 解压</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.gz 文件</span></span><br><span class="line">[root@localhost ~]#  tar -zcvf 打包后名字.tar.gz 文件名1 文件名2 ...    # 打包并压缩</span><br><span class="line">[root@localhost ~]#  tar -zxvf 需解压的文件.tar.gz     # 解压</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.bz2 文件</span></span><br><span class="line">[root@localhost ~]#  tar -jcvf 打包后名字.tar.bz2 文件名1 文件名2 ...    # 打包并压缩</span><br><span class="line">[root@localhost ~]#  tar -jxvf 需解压的文件.tar.bz2     # 解压</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><ul><li><p>打包常用选项</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-c</code>:<code>--directory=&lt;目的目录&gt;</code></td><td>将多个文件或目录进行打包。</td></tr><tr><td><code>-A</code>:<code>--catenate</code></td><td>追加 tar 文件到归档文件。</td></tr><tr><td><code>-f 包名</code>：<code>--file=&lt;备份文件&gt;</code></td><td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示打包文件过程</td></tr></tbody></table></li><li><p>解打包常用选项</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-x</code>：<code>--extract</code>：<code>--get</code></td><td>对 tar 包做解打包操作。</td></tr><tr><td><code>-f</code>：<code>--file=&lt;备份文件&gt;</code></td><td>指定要解压的 tar 包的包名。</td></tr><tr><td><code>-t</code>：<code>--list</code></td><td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td></tr><tr><td><code>-C 目录</code>:<code>--directory=&lt;目的目录&gt;</code></td><td>指定解打包位置。</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示解打包的具体过程</td></tr></tbody></table></li></ul></li></ul><h3 id="8-9-文件系统管理">8.9 文件系统管理</h3><h4 id="8-9-1-df-查看文件系统硬盘使用情况">8.9.1 df 查看文件系统硬盘使用情况</h4><p>Linux df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。包括文件系统所在硬盘分区的总容量、已使用的容量、剩余容量等。</p><p>整个文件系统有关的数据，都保存在 Super block（超级块）中，而 df 命令主要读取的数据几乎都针对的是整个文件系统，所以 df 命令主要是从各文件系统的 Super block 中读取数据。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df [options] [目录或文件名]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以人们习惯的单位（通常使用 GB 或 MB）显示出来</span></span><br><span class="line">[root@localhost ~]# df -h</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已经使用的inode</span></span><br><span class="line">[root@localhost ~]# df -iTh</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有文件系统信息，包括系统特有的 /proc、/sysfs 等文件系统；</td></tr><tr><td><code>-m</code></td><td>以 MB 为单位显示容量；</td></tr><tr><td><code>-k</code></td><td>以 KB 为单位显示容量，默认以 KB 为单位；</td></tr><tr><td><code>-h</code></td><td>使用人们习惯的 KB、MB 或 GB 等单位自行显示容量；</td></tr><tr><td><code>-T</code></td><td>显示该分区的文件系统名称；</td></tr><tr><td><code>-i</code></td><td>不用硬盘容量显示，而是以含有 inode 的数量来显示。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>正常使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df</span><br><span class="line">Filesystem      1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2         9920624   3823112   5585444  41% /</span><br><span class="line">/dev/hdc3         4956316    141376   4559108   4% /home</span><br><span class="line">/dev/hdc1          101086     11126     84741  12% /boot</span><br><span class="line">tmpfs              371332         0    371332   0% /dev/shm</span><br></pre></td></tr></table></figure><blockquote><p>由 df 命令显示出的各列信息的含义分别是：</p><ul><li>Filesystem：表示该文件系统位于哪个分区，因此该列显示的是设备名称；</li><li>1K-blocks：此列表示文件系统的总大小，默认以 KB 为单位；</li><li>Used：表示用掉的硬盘空间大小；</li><li>Available：表示剩余的硬盘空间大小；</li><li>Use%：硬盘空间使用率。如果使用率高达 90% 以上，就需要额外注意，因为容量不足，会严重影响系统的正常运行；</li><li>Mounted on：文件系统的挂载点，也就是硬盘挂载的目录位置。</li></ul></blockquote></li><li><p>-aT</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -aT</span><br><span class="line">Filesystem    Type 1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2     ext3   9920624 3823112   5585444  41% /</span><br><span class="line">proc          proc         0       0         0   -  /proc</span><br><span class="line">sysfs        sysfs         0       0         0   -  /sys</span><br><span class="line">devpts      devpts         0       0         0   -  /dev/pts</span><br><span class="line">/dev/hdc3     ext3   4956316  141376   4559108   4% /home</span><br><span class="line">/dev/hdc1     ext3    101086   11126     84741  12% /boot</span><br><span class="line">tmpfs        tmpfs    371332       0    371332   0% /dev/shm</span><br><span class="line">none   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc</span><br><span class="line">sunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs</span><br></pre></td></tr></table></figure><p>注意，使用 -a 选项，会将很多特殊的文件系统显示出来，这些文件系统包含的大多是系统数据，存在于内存中，不会占用硬盘空间，因此你会看到，它们所占据的硬盘总容量为 0。</p></li></ol></li></ul><p>​</p><h4 id="8-9-2-du-统计目录或文件所占磁盘空间大小">8.9.2 du 统计目录或文件所占磁盘空间大小</h4><p>du 是统计目录或文件所占磁盘空间大小的命令。</p><p>需要注意的是，使用&quot;ls -r&quot;命令是可以看到文件的大小的。但是大家会发现，在使用&quot;ls -r&quot;命令査看目录大小时，目录的大小多数是 4KB，这是因为目录下的子目录名和子文件名是保存到父目录的 block（默认大小为 4KB）中的，如果父目录下的子目录和子文件并不多，一个 block 就能放下，那么这个父目录就只占用了一个 block 大小。大家可以将其想象成图书馆的书籍目录和实际书籍。如果我们用&quot;ls-l&quot;命令査看，则只能看到这些书籍占用了 1 页纸的书籍目录，但是实际书籍到底有多少是看不到的，哪怕它堆满了几个房间。</p><p>但是我们在统计目录时，不是想看父目录下的子目录名和子文件名到底占用了多少空间，而是想看父目录下的子目录和子文件的总磁盘占用量大小，这时就需要使用 du 命令才能统计目录的真正磁盘占用量大小。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du [options] [目录或文件名]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只统计磁盘占用量总的大小，同时使用习惯单位显示</span></span><br><span class="line">[root@localhost ~]# du -sh</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</td></tr><tr><td><code>-h</code></td><td>使用习惯单位显示磁盘占用量，如 KB、MB 或 GB 等</td></tr><tr><td><code>-s</code></td><td>统计总磁盘占用量，而不列出子目录和子文件的磁盘占用量</td></tr></tbody></table></li><li><p><strong>du命令和df命令的区别</strong></p><p>有时我们会发现，使用 du 命令和 df 命令去统计分区的使用情况时，得到的数据是不一样的。那是因为df命令是从文件系统的角度考虑的，通过文件系统中未分配的空间来确定文件系统中已经分配的空间大小。也就是说，在使用 df 命令统计分区时，不仅要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。</p><p>而 du 命令是面向文件的，只会计算文件或目录占用的磁盘空间。也就是说，df 命令统计的分区更准确，是真正的空闲空间。</p></li></ul><h4 id="8-9-3-lsblk-查看设备挂载情况">8.9.3 lsblk 查看设备挂载情况</h4><p>在linux中观察磁盘分区的状态可以使用命令lsblk ,如下图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/image-20230118000226278.png" alt="image-20230118000226278"></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsblk [options]</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>仅列出磁盘本身，并不会列出该磁盘的分区数据</td></tr><tr><td><code>-f</code></td><td>同时列出该磁盘内的文件系统名称</td></tr><tr><td><code>-i</code></td><td>使用 ASCII的线段输出，不要使用复杂的编码（再某些环境下很有用）</td></tr><tr><td><code>-m</code></td><td>同时输出该装置在 /dev 底下的权限数据（rwx 的数据）</td></tr><tr><td><code>-p</code></td><td>列出该装置的完整文件名!而不是仅列出最后的名字而已。</td></tr><tr><td><code>-t</code></td><td>列出该磁盘装置的详细数据，包括磁盘队列机制、预读写的数据量大小等</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>-p参数之后就显示出了完整的文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# lsblk -p</span><br><span class="line">NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">/dev/sda      8:0    0   20G  0 disk </span><br><span class="line">├─/dev/sda1   8:1    0  300M  0 part /boot</span><br><span class="line">├─/dev/sda2   8:2    0    1G  0 part [SWAP]</span><br><span class="line">└─/dev/sda3   8:3    0 18.7G  0 part /</span><br><span class="line">/dev/sr0     11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure></li><li><p>-f 参数之后就显示出了uuid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# lsblk -f</span><br><span class="line">NAME   FSTYPE LABEL UUID                                 MOUNTPOINT</span><br><span class="line">sda                                                      </span><br><span class="line">├─sda1 xfs          f8e94199-eac8-45d5-9cff-80f7696d8fe3 /boot</span><br><span class="line">├─sda2 swap         9aaf14d0-ed51-4220-b5fd-032b7ae14e36 [SWAP]</span><br><span class="line">└─sda3 xfs          0f37330d-bb9f-43b4-a71f-463043b5c786 /</span><br><span class="line">sr0   </span><br><span class="line">[root@loaclhost ~]#</span><br><span class="line">[root@loaclhost ~]# blkid</span><br><span class="line">/dev/sda1: UUID=&quot;f8e94199-eac8-45d5-9cff-80f7696d8fe3&quot; TYPE=&quot;xfs&quot; </span><br><span class="line">/dev/sda2: UUID=&quot;9aaf14d0-ed51-4220-b5fd-032b7ae14e36&quot; TYPE=&quot;swap&quot; </span><br><span class="line">/dev/sda3: UUID=&quot;0f37330d-bb9f-43b4-a71f-463043b5c786&quot; TYPE=&quot;xfs&quot;</span><br></pre></td></tr></table></figure><p>① 上面演示了使用-f参数显示分区的uuid,其实直接使用blkid也是可以显示uuid的。</p><p>② 使用parted命令可以显示分区的格式（Partition Table）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# parted /dev/sda print</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sda: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    Type     File system     标志</span><br><span class="line"> 1      1049kB  316MB   315MB   primary  xfs             启动</span><br><span class="line"> 2      316MB   1389MB  1074MB  primary  linux-swap(v1)</span><br><span class="line"> 3      1389MB  21.5GB  20.1GB  primary  xfs</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="8-9-4-mount-umount-挂载-卸载">8.9.4 mount/umount 挂载/卸载</h4><ul><li><p>mount 挂载</p><p>所有的硬件设备必须挂载之后才能使用，只不过，有些硬件设备（比如硬盘分区）在每次系统启动时会自动挂载，而有些（比如 U 盘、光盘）则需要手动进行挂载。</p><p>挂载指的是将硬件设备的文件系统和 Linux 系统中的文件系统，通过指定目录（作为挂载点）进行关联。而要将文件系统挂载到 Linux 系统上，就需要使用 mount 挂载命令。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount [-t 系统类型] [-L 卷标名] [-o 特殊选项] [-n] ] 设备文件名 挂载点</span><br></pre></td></tr></table></figure></li><li><p>选项</p><ul><li><p>-t 系统类型：指定欲挂载的文件系统类型。Linux 常见的支持类型有 EXT2、EXT3、EXT4、iso9660（光盘格式）、vfat、reiserfs 等。如果不指定具体类型，挂载时 Linux 会自动检测；</p></li><li><p>-L 卷标名：除了使用设备文件名（例如 /dev/hdc6）之外，还可以利用文件系统的卷标名称进行挂载；</p></li><li><p>-n：在默认情况下，系统会将实际挂载的情况实时写入 /etc/mtab 文件中，但在某些场景下（例如单人维护模式），为了避免出现问题，会刻意不写入，此时就需要使用这个选项；</p></li><li><p>-o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步/异步等，如果不指定，则使用默认值（defaults）。具体的特殊选项参见表 1（挂载参数）。</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>rw/ro</td><td>是否对挂载的文件系统拥有读写权限，rw 为默认值，表示拥有读写权限；ro 表示只读权限。</td></tr><tr><td>async/sync</td><td>此文件系统是否使用同步写入（sync）或异步（async）的内存机制，默认为异步 async。</td></tr><tr><td>dev/nodev</td><td>是否允许从该文件系统的 block 文件中提取数据，为了保证数据安装，默认是 nodev。</td></tr><tr><td>auto/noauto</td><td>是否允许此文件系统被以 mount -a 的方式进行自动挂载，默认是 auto。</td></tr><tr><td>suid/nosuid</td><td>设定文件系统是否拥有 SetUID 和 SetGID 权限，默认是拥有。</td></tr><tr><td>exec/noexec</td><td>设定在文件系统中是否允许执行可执行文件，默认是允许。</td></tr><tr><td>user/nouser</td><td>设定此文件系统是否允许让普通用户使用 mount 执行实现挂载，默认是不允许（nouser），仅有 root 可以。</td></tr><tr><td>defaults</td><td>定义默认值，相当于 rw、suid、dev、exec、auto、nouser、async 这 7 个选项。</td></tr><tr><td>remount</td><td>重新挂载已挂载的文件系统，一般用于指定修改特殊权限。</td></tr></tbody></table></li></ul></li><li><p>实例</p><ol><li><p>挂载分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/disk1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立挂载点目录</span></span><br><span class="line">[root@localhost ~]# mount /dev/sdb1 /mnt/disk1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载分区</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>umount 卸载</p><p>umount 命令用于卸载已经挂载的硬件设备</p><ul><li><p>语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# umount 设备文件名或挂载点</span><br></pre></td></tr></table></figure></li><li><p>实例</p><p>卸载时有可能会出现以下情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /mnt/cdrom/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入光盘挂载点</span></span><br><span class="line">[root@localhost cdrom]\# umount /mnt/cdrom/</span><br><span class="line">umount: /mnt/cdrom: device is busy.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">报错，设备正忙</span></span><br></pre></td></tr></table></figure><p>这种报错是因为我们已经进入了挂载点，因此，如果要卸载某硬件设备，在执行 umount 命令之前，用户须退出挂载目录。</p><p>卸载硬件设备成功与否，除了执行 umount 命令不报错之外，还可以使用 <code>df</code> 命令或 <code>mount -l</code> 来查看目标设备是否还挂载在系统中。</p></li></ul></li></ul><h4 id="8-9-5-挂载光盘">8.9.5 挂载光盘</h4><p>CentOS6.x以后的系统，光盘设备文件名是/dev/sr0。不论哪个系统都有软连接/dev/cdrom，与可以作为光盘的设备文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# ll /dev/cdrom</span><br><span class="line">lrwxrwxrwx. 1 root root 3 1月  18 08:43 /dev/cdrom -&gt; sr0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dev/cdrom就是/dev/sr0的软链接</span></span><br></pre></td></tr></table></figure><ul><li><p>挂载光盘的步骤</p><p>Linux系统下在根目录中默认给我们提供了三个空文件夹：<br>media（推荐挂光盘）<br>misc（推荐挂网络存储盘）<br>mnt（推荐挂U盘或者移动硬盘）</p><ol><li><p>创建一个空目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/cdrom</span><br></pre></td></tr></table></figure></li><li><p>找到光盘的设备文件名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# ll /dev/cdrom</span><br><span class="line">lrwxrwxrwx. 1 root root 3 1月  18 08:43 /dev/cdrom -&gt; sr0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光盘设备文件名是/dev/sr0</span></span><br></pre></td></tr></table></figure></li><li><p>挂载光盘</p><p>如果是用虚拟机模拟的系统，要先执行插入光盘的步骤，否则在这里会报错<code>mount: no medium found on /dev/sr0</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -t iso9660  /dev/sr0 /mnt/cdrom/</span><br><span class="line">mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class="line">mount: /dev/sr0 已经挂载或 /mnt/cdrom 忙</span><br><span class="line">       /dev/sr0 已经挂载到 /mnt/cdrom 上</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t文件系统：加入文件系统类型来指定挂载的类型，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以ext3、ext4、iso9660等文件系统。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载光盘就用iso9660类型的文件系统类型。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以直接省略-t iso9660，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载光盘时候系统自动添加。</span></span><br></pre></td></tr></table></figure></li><li><p>最后执行mount命令在确认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# mount</span><br><span class="line">...省略部分内容</span><br><span class="line">/dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,noquota)</span><br><span class="line">tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,seclabel,size=99568k,mode=700)</span><br><span class="line">/dev/sr0 on /mnt/cdrom type iso9660 (ro,relatime)       &lt;-- 光盘已经挂载</span><br></pre></td></tr></table></figure></li></ol></li><li><p>访问光盘数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# ls /mnt/cdrom</span><br><span class="line">CentOS_BuildTag  EFI  EULA  GPL  images  isolinux  LiveOS  Packages  repodata  RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Testing-7  TRANS.TBL</span><br></pre></td></tr></table></figure></li><li><p>卸载挂载点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为设备文件名和挂载点已经连接到一起，卸载哪一个都可以</span></span><br><span class="line">[root@localhost ~]# umount /dev/sr0</span><br><span class="line">[root@localhost ~]# umount /mnt/cdrom</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有时候会出现下述报错：设备正忙，以为此时位置正在光盘里边cdrom目录中，要退出在进行卸载。</span></span><br><span class="line">[root@localhost cdrom]# umount /dev/sr0</span><br><span class="line">umount:/mnt/cdrom: device is busy.</span><br><span class="line">(In some cases useful info about processes that use the device is found by 1sof(8) or fuser(1))</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：卸载的时候需要退出光盘目录，才能正常卸载。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="8-9-6-挂载u盘">8.9.6 挂载u盘</h4><h4 id="8-9-7-etc-fatab-配置-开机自动挂载硬件设备">8.9.7 /etc/fatab 配置-开机自动挂载硬件设备</h4><p>如果我们想实现开机自动挂载某个硬件设备，需要使用 root 身份在 /etc/fstab 文件中添加此设备即可。</p><ul><li><p><strong>查看 <code>/etc/fatab</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/fstab</span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults 1 1</span><br><span class="line">UUID=0b23d315-33a7-48a4-bd37-9248e5c44345 /boot ext4 defaults 1 2</span><br><span class="line">UUID=4021be19-2751-4dd2-98cc-383368c39edb swap swap defaults 0 0</span><br><span class="line">\#只有这三个是真正的硬盘分区，下面的都是虚拟文件系统或交换分区</span><br><span class="line">tmpfs /dev/shm tmpfs defaults 0 0</span><br><span class="line">devpts /dev/pts devpts gid=5, mode=620 0 0</span><br><span class="line">sysfs /sys sysfe defaults 0 0</span><br><span class="line">proc /proc proc defaults 0 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字段的含义:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">UUID/文件名 挂载点 文件系统的类型 各种挂载参数 指定分区是否被dump备份 指定分区是否被fsck检测</span></span><br></pre></td></tr></table></figure><p>tmpfs、devpts、sysfs 和 proc 这几行，它们分别是与共享内存、终端窗口、设备信息和内核参数相关联的特殊设备。</p><ul><li><p>UUID</p><p>UUID 即通用唯一标识符，是一个 128 位比特的数字，可以理解为就是硬盘的 ID，UUID 由系统自动生成和管理。</p><p>① 用 dumpe2fs 命令（后续会讲）就可以查看到每个分区的 UUID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs /dev/sdb5</span><br><span class="line">dumpe2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem volume name: test_label</span><br><span class="line">Last mounted on: &lt;not available&gt;</span><br><span class="line">Filesystem UUID: 63f238f0-a715-4821-8ed1-b3d18756a3ef</span><br><span class="line">\#UUID</span><br><span class="line">...省略部分输出..</span><br></pre></td></tr></table></figure><p>② 也可以通过查看每个硬盘UUID的链接文件名来确定UUID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /dev/disk/by-uuid/</span><br><span class="line">总用量 0</span><br><span class="line">Irwxrwxrwx. 1 root root 10 4 月 11 00:17 0b23d315-33a7-48a4-bd37-9248e5c44345</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sdal</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4 月 11 00:17 4021 be19-2751 -4dd2-98cc-383368c39edb</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sda2</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4 月 11 00:17 63f238f0-a715-4821-8ed1-b3d18756a3ef</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sdb5</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4月 11 00:17 6858b440-ad9e-45cb-b411 -963c5419e0e8</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sdb6</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4月 11 00:17 c2ca6f57-b15c-43ea-bca0-f239083d8bd2</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sda3</span></span><br></pre></td></tr></table></figure></li><li><p>挂载点</p><p>需要强调的是，挂载点一定要是已经建立的空目录。</p></li><li><p>文件系统类型</p><p>默认文件系统是 ext4。</p><table><thead><tr><th>文件系统</th><th>描 述</th></tr></thead><tbody><tr><td>Ext</td><td>Linux 中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用,是为 Linux 核心所做的第一个文件系统，最大可支持 2GB 的文件系统。</td></tr><tr><td>Ext2</td><td>是 Ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是 Ext2 文件系统。于 1993 年发布，支持最大 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024x1024KB) Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成。 目录项:包括文件名和inode节点号。 Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。 数据块：文件的具体内容存放地。 将硬盘分区时会划分出目录块、inode Table区块和data block数据区域。一个文件由一个目录项、inode和数据区域块组成。 Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。 当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据</td></tr><tr><td>Ext3</td><td>是 Ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大 2TB 的文件</td></tr><tr><td>Ext4</td><td>是 Ext3 文件系统的升级版。Ext4 在性能、伸缩性和可靠性方面进行了大量改进。Ext4 的变化可以说是翻天覆地的，比如向下兼容 Ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块 概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用 barrier 等。它是 CentOS 6.3 的默认文件系统</td></tr><tr><td>xfs</td><td>被业界称为最先进、最具有可升级性的文件系统技术，由 SGI 公司设计，目前最新的 CentOS 7 版本默认使用的就是此文件系统。</td></tr><tr><td>swap</td><td>swap 是 Linux 中用于交换分区的文件系统（类似于 Windows 中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的 2 倍，但是不要超过 2GB。它是 Linux 的必需分区</td></tr><tr><td>NFS</td><td>NFS 是网络文件系统（Network File System）的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td></tr><tr><td>iso9660</td><td>光盘的标准文件系统。Linux 要想使用光盘，必须支持 iso9660 文件系统</td></tr><tr><td>fat</td><td>就是 Windows 下的 fatl6 文件系统，在 Linux 中识别为 fat</td></tr><tr><td>vfat</td><td>就是 Windows 下的 fat32 文件系统，在 Linux 中识别为 vfat。支持最大 32GB 的分区和最大 4GB 的文件</td></tr><tr><td>NTFS</td><td>就是 Windows 下的 NTFS 文件系统，不过 Linux 默认是不能识别 NTFS 文件系统的，如果需要识别，则需要重新编译内核才能支持。它比 fat32 文件系统更加安全，速度更快，支持最大 2TB 的分区和最大 64GB 的文件</td></tr><tr><td>ufs</td><td>Sun 公司的操作系统 Solaris 和 SunOS 所采用的文件系统</td></tr><tr><td>proc</td><td>Linux 中基于内存的虚拟文件系统，用来管理内存存储目录 /proc</td></tr><tr><td>sysfs</td><td>和 proc —样，也是基于内存的虚拟文件系统，用来管理内存存储目录 /sysfs</td></tr><tr><td>tmpfs</td><td>也是一种基于内存的虚拟文件系统，不过也可以使用 swap 交换分区</td></tr></tbody></table></li><li><p>挂载参数</p><p>参数和 mount 命令的挂载参数一致。</p></li><li><p>指定分区是否被 dump 备份</p><p>0 代表不备份，1 代表备份，2 代表不定期备份。</p></li><li><p>指定分区是否被 fsck 检测</p><p>0 代表不检测，其他数字代表检测的优先级，1 的优先级比 2 高。所以先检测 1 的分区，再检测 2 的分区。一般分区的优先级是 1，其他分区的优先级是 2。</p></li></ul></li></ul><h4 id="8-9-8-fdisk-硬盘分区">8.9.8 fdisk 硬盘分区</h4><p>我们在安装操作系统的过程中已经对系统硬盘进行了分区，但如果新添加了一块硬盘，想要正常使用就需要使用fdisk分区。</p><p>在 Linux 中有专门的分区命令 fdisk 和 parted。其中 fdisk 命令较为常用，但不支持大于 2TB 的分区；如果需要支持大于 2TB 的分区，则需要使用 parted 命令，当然 parted 命令也能分配较小的分区。</p><p><strong><font style="color:red">注意，千万不要在当前的硬盘上尝试使用 fdisk，这会完整删除整个系统，一定要再找一块硬盘，或者使用虚拟机。</font></strong></p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk [options]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出系统分区</span></span><br><span class="line">[root@localhost ~]# fdisk 设备文件名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给硬盘分区</span></span><br></pre></td></tr></table></figure></li><li><p>常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk -l</span><br></pre></td></tr></table></figure></li><li><p><strong><code>fdisk -l</code> 命令输出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk -l							#查询本机可以识别的硬盘和分区</span><br><span class="line">Disk /dev/sda:32.2 GB, 32212254720 bytes				#硬盘文件名和硬盘大小</span><br><span class="line">255 heads, 63 sectors/track, 3916 cylinders				#共255个磁头、63个扇区和3916个柱面</span><br><span class="line">Units = cylinders of 16065 *512 = 8225280 bytes			#每个柱面的大小</span><br><span class="line">Sector size (logical/physical): 512 bytes/512 bytes		#每个扇区的大小</span><br><span class="line">I/O size (minimum/optimal): 512 bytes/512 bytes			#硬盘文件名和硬盘大小</span><br><span class="line">Disk identifier: 0x0009e098</span><br><span class="line"></span><br><span class="line">Device Boot Start End Blocks ld System					#设备文件名启动分区 起始柱面 终止柱面容量 ID 系统</span><br><span class="line">/dev/sda1 * 1 26 204800 83 Linux</span><br><span class="line">Partition 1 does not end on cylinder boundary.			#分区1没有占满硬盘</span><br><span class="line">/dev/sda2 26 281 2048000 82 Linux swap / Solaris</span><br><span class="line">Partition 2 does not end on cylinder boundary			#分区2没有占满硬盘</span><br><span class="line">/dev/sda3 281 3917 29203456 83 Linux</span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes				#第二个硬盘识别，这个硬盘的大小</span><br><span class="line">255 heads, 63 sectors/track, 2610 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes/512 bytes Disk identifier: 0x00000000</span><br></pre></td></tr></table></figure><blockquote><ul><li>Device：分区的设备文件名。</li><li>Boot：是否为启动引导分区，在这里 /dev/sda1 为启动引导分区。</li><li>Start：起始柱面，代表分区从哪里开始。</li><li>End：终止柱面，代表分区到哪里结束。</li><li>Blocks：分区的大小，单位是 KB。</li><li>id：分区内文件系统的 ID。在 fdisk 命令中，可以 使用 “i” 查看。</li><li>System：分区内安装的系统是什么。</li></ul></blockquote></li><li><p>选项</p><table><thead><tr><th>选项</th><th>说 明</th></tr></thead><tbody><tr><td>-b<size></size></td><td>扇区大小(512、1024、2048或4096)</td></tr><tr><td>-c</td><td>兼容模式：“dos”或“nondos”(默认)</td></tr><tr><td>-l</td><td>列出指定的外围设备的分区表状况</td></tr><tr><td>-h</td><td>打印此帮助文本</td></tr><tr><td>-u<size></size></td><td>搭配&quot;-l&quot;参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址；<br>显示单位：“cylinders”(柱面)或“sectors”(扇区，默认)；</td></tr><tr><td>-v</td><td>打印版本信息</td></tr><tr><td>-C<number></number></td><td>指定柱面数</td></tr><tr><td>-H<number></number></td><td>指定磁头数</td></tr><tr><td>-S<number></number></td><td>指定每个磁道的扇区数</td></tr></tbody></table></li><li><p><strong>分区交互界面的命令</strong></p><table><thead><tr><th>命令</th><th>说 明</th></tr></thead><tbody><tr><td>a</td><td>设置可引导标记</td></tr><tr><td>b</td><td>编辑 bsd 磁盘标签</td></tr><tr><td>c</td><td>设置 DOS 操作系统兼容标记</td></tr><tr><td>d</td><td>删除一个分区</td></tr><tr><td>1</td><td>显示已知的文件系统类型。82 为 Linux swap 分区，83 为 Linux 分区</td></tr><tr><td>m</td><td>显示帮助菜单</td></tr><tr><td>n</td><td>新建分区</td></tr><tr><td>0</td><td>建立空白 DOS 分区表</td></tr><tr><td>P</td><td>显示分区列表</td></tr><tr><td>q</td><td>不保存退出</td></tr><tr><td>s</td><td>新建空白 SUN 磁盘标签</td></tr><tr><td>t</td><td>改变一个分区的系统 ID</td></tr><tr><td>u</td><td>改变显示记录单位</td></tr><tr><td>V</td><td>验证分区表</td></tr><tr><td>w</td><td>保存退出</td></tr><tr><td>X</td><td>附加功能（仅专家）</td></tr></tbody></table></li></ul><h4 id="8-9-9-parted-创建分区">8.9.9 parted 创建分区</h4><p>虽然我们可以使用 fdisk命令对硬盘进行快速的分区，但对高于 2TB 的硬盘分区，此命令却无能为力，此时就需要使用 parted 命令。</p><ul><li><p><strong>语法</strong></p><p>parted 命令是可以在命令行直接分区和格式化的，不过 parted 交互模式才是更加常用的命令方式，进入交互模式的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted 硬盘设备文件名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入交互模式</span></span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>分区交互界面的命令</strong></p><table><thead><tr><th>parted交互命令</th><th>说 明</th></tr></thead><tbody><tr><td>check NUMBER</td><td>做一次简单的文件系统检测</td></tr><tr><td>cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER</td><td>复制文件系统到另一个分区</td></tr><tr><td>help [COMMAND]</td><td>显示所有的命令帮助</td></tr><tr><td>mklabel,mktable LABEL-TYPE</td><td>创建新的磁盘卷标（分区表）</td></tr><tr><td>mkfs NUMBER FS-TYPE</td><td>在分区上建立文件系统</td></tr><tr><td>mkpart PART-TYPE [FS-TYPE] START END</td><td>创建一个分区</td></tr><tr><td>mkpartfs PART-TYPE FS-TYPE START END</td><td>创建分区，并建立文件系统</td></tr><tr><td>move NUMBER START END</td><td>移动分区</td></tr><tr><td>name NUMBER NAME</td><td>给分区命名</td></tr><tr><td>print [devices|free|list,all|NUMBER]</td><td>显示分区表、活动设备、空闲空间、所有分区</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>rescue START END</td><td>修复丢失的分区</td></tr><tr><td>resize NUMBER START END</td><td>修改分区大小</td></tr><tr><td>rm NUMBER</td><td>删除分区</td></tr><tr><td>select DEVICE</td><td>选择需要编辑的设备</td></tr><tr><td>set NUMBER FLAG STATE</td><td>改变分区标记</td></tr><tr><td>toggle [NUMBER [FLAG]]</td><td>切换分区表的状态</td></tr><tr><td>unit UNIT</td><td>设置默认的单位</td></tr><tr><td>Version</td><td>显示版本</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>进入交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打算继续划分/dev/sdb硬盘</span></span><br><span class="line">GNU Parted 2.1</span><br><span class="line">使用/dev/sdb</span><br><span class="line">Welcome to GNU Parted! Type &#x27;help&#x27; to view a list of commands.</span><br><span class="line">(parted)   &lt;--parted 的等待输入交互命令的位置，输入 help，可以看到在交互模式下支持的所有命令</span><br></pre></td></tr></table></figure></li><li><p>查看分区表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入<span class="built_in">print</span>指令</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">硬盘参数，是虚拟机</span></span><br><span class="line">Disk/dev/sdb: 21.5GB</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">硬盘大小</span></span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扇区大小</span></span><br><span class="line">Partition Table: msdos</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区表类型，是MBR分区表</span></span><br><span class="line">Number Start End Size Type File system 标志</span><br><span class="line">1 32.3kB 5379MB 5379MB primary</span><br><span class="line">2 5379MB 21.5GB 16.1GB extended</span><br><span class="line">5 5379MB 7534MB 2155MB logical ext4</span><br><span class="line">6 7534MB 9689MB 2155MB logical ext4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">看到了我们使用fdisk命令创建的分区，其中1分区没被格式化；2分区是扩展分区，不能被格式化</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 print 命令可以査看分区表信息，包括硬盘参数、硬盘大小、扇区大小、分区表类型和分区信息。分区信息共有 7 列，分别如下：</p><ol><li>Number：分区号，比如，1号就代表 /dec/sdb1；</li><li>Start：分区起始位置。这里不再像 fdisk 那样用柱面表示，使用字节表示更加直观；</li><li>End：分区结束位置；</li><li>Size：分区大小；</li><li>Type：分区类型，有 primary、extended、logical 等类型；</li><li>Filesystem：文件系统类型；</li><li>标志：分区的标记。</li></ol></blockquote></li><li><p>修改成 GPT 分区表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(partcd) mklabel gpt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改分区表命令</span></span><br><span class="line">警告：正在使用/dev/sdb上的分区。由于/dev/sdb分区已经挂载，所以有警告。注意，如果强制修改，那么原有分区及数据会消失</span><br><span class="line">忽略/Ignore/放弃/Cancel? ignore</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入ignore忽略报错</span></span><br><span class="line">警告：The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入 <span class="built_in">yes</span></span></span><br><span class="line">警告：WARNING: the kernel failed to re-read the partition table on /dev/sdb (设 备或资源忙）.As a result, it may not reflect all of your changes until after reboot.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下次重启后才能生效</span></span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下分区表</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区表已经变成 GPT</span></span><br><span class="line">Number Start End Size File system Name 标志</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有的分区都消失了</span></span><br></pre></td></tr></table></figure><p>修改了分区表，如果这块硬盘上已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才能生效。</p><p>另外，我们转换分区表的目的是支持大于 2TB 的分区，如果分区并没有大于 2TB，那么这一步是可以不执行的。</p><p><font style="color:red">注意，一定要把 /etc/fstab 文件和原有分区中的内容删除才能重启，否则会报错。</font></p></li><li><p>建立分区</p><p>因为修改过了分区表，所以/dev/sdb硬盘中的所有数据都消失了，我们就可以重新对这块硬盘分区了。不过，在建立分区时，默认文件系统就只能是 ext2 了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(parted)mkpart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入创建分区命令，后面不要参数，全部靠交互</span></span><br><span class="line">指定</span><br><span class="line">分区名称？ []?disk1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区名称，这里命名为disk 1</span></span><br><span class="line">文件系统系统？ [ext2]?</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件系统类型，直接回车，使用默认文件系统ext2</span></span><br><span class="line">起始点？ 1MB</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区从1MB开始</span></span><br><span class="line">结束点？5GB分区到5GB结束</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区完成</span></span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B Partition Table: gpt</span><br><span class="line">Number Start End Size Rle system Name 标志</span><br><span class="line">1 1049kB 5000MB 4999MB disk1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区1已经出现</span></span><br></pre></td></tr></table></figure><p>不知道大家有没有注意到，我们现在用 print 查看的分区和第一次查看 MBR 分区表的分区时有些不一样了，少了 Type 这个字段，也就是分区类型字段，多了 Name（分区名）字段。分区类型是用于标识主分区、扩展分区和逻辑分区的，不过这种标识只在 MBR 分区表中使用，现在已经变成了 GPT 分区表，所以就不再有 Type 类型了。</p></li><li><p>建立文件系统</p><p>分区分完后，还需要进行格式化。我们知道，如果使用 parted 交互命令格式化，则只能格式化成 ext2 文件系统。我们在这里要演示一下 parted 命令的格式化方法，所以就格式化成 ext2 文件系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkfs</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式化命令（很奇怪，也是mkfs，但是这只是parted的交互命令）</span></span><br><span class="line">WARNING: you are attempting to use parted to operate on (mkfs) a file system.</span><br><span class="line">parted&#x27;s file system manipulation code is not as robust as what you&#x27;ll find in</span><br><span class="line">dedicated, file-system-specific packages like e2fsprogs. We recommend</span><br><span class="line">you use parted only to manipulate partition tables, whenever possible.</span><br><span class="line">Support for performing most operations on most types of file systems</span><br><span class="line">will be removed in an upcoming release.</span><br><span class="line">警告：The existing file system will be destroyed and all data on the partition will be lost. Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">警告你格式化丟失，没关系，已经丢失过了</span></span><br><span class="line">分区编号？ 1</span><br><span class="line">文件系统类型 [ext2]?</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定文件系统类型，写别的也没用，直接回车</span></span><br><span class="line">(parted) print #格式化完成，查看一下</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21,5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Number Start End Size File system Name标志</span><br><span class="line">1 1049kB 5000MB 4999MB ext2 diski</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拥有了文件系统</span></span><br></pre></td></tr></table></figure><p>如果要格式化成 ext4 文件系统，那么请 mkfs 命令帮忙吧（注意：不是 parted 交互命令中的 mkfs，而是系统命令 mkfs)。</p></li><li><p>调整分区大小</p><p>parted 命令还有一大优势，就是可以调整分区的大小（在 Windows 中也可以实现，不过要么需要转换成动态磁盘，要么需要依赖第三方工具，如硬盘分区魔术师）。起始 Linux 中 LVM 和 RAID 是可以支持分区调整的，不过这两种方法也可以看成动态磁盘方法，使用 parted 命令调整分区更加简单。</p><p><font style="color:red">注意，parted 调整已经挂载使用的分区时，是不会影响分区中的数据的，也就是说，数据不会丢失。但是一定要先卸载分区，再调整分区大小，否则数据是会出现问题的。另外，要调整大小的分区必须已经建立了文件系统（格式化），否则会报错。</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(parted) resize</span><br><span class="line">分区编号？ 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定要修改的分区编号</span></span><br><span class="line">起始点？ [1049kB]? 1MB</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区起始位置</span></span><br><span class="line">结束点？ [5000MB]? 6GB</span><br><span class="line">分区结束位置</span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21,5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Number Start End Size File system Name标志</span><br><span class="line">1 1049kB 6000MB 5999MB ext2 diski</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区大小改变</span></span><br></pre></td></tr></table></figure></li><li><p>删除分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">命令如下：</span><br><span class="line">(parted) rm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除分区命令</span></span><br><span class="line">分区编号？ 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定分区编号</span></span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Number Start End Size File system Name 标志 #分区消失</span><br></pre></td></tr></table></figure><p><strong><font style="color:#000;background:#ff0">注意，parted 中所有的操作都是立即生效的，没有保存生效的概念。这一点和 fdisk 交互命令明显不同，所以做的所有操作大家要加倍小心。</font></strong></p></li></ol></li></ul><h4 id="8-9-10-mkfs-格式化分区（为分区写入文件系统）">8.9.10 mkfs 格式化分区（为分区写入文件系统）</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs [-t 文件系统格式] 分区设备文件名</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-t 文件系统格式</code></td><td>用于指定格式化的文件系统，如 ext3、ext4</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>格式化 <code>/dev/sdb6</code> 分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t ext4 /dev/sdb6</span><br><span class="line">mke2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=  &lt;--这里指的是卷标名，我们没有设置卷标</span><br><span class="line">OS type：Linux</span><br><span class="line">Block size=4096 (log=2) &lt;--block 的大小配置为 4K</span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">131648 inodes, 526120 blocks &lt;--由此配置决定的inode/block数量</span><br><span class="line">26306 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=541065216 17 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">7744 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">32768, 98304, 163840, 229376, 294912</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (16384 blocks):done</span><br><span class="line">Writing superblocks and filesystem accounting information:done</span><br><span class="line">This filesystem will be automatically checked every 39 mounts or 180 days, whichever comes first. Use tune2fs -c or -i to override.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样就创建起来所需要的 Ext4 文件系统了！简单明了！</span></span><br></pre></td></tr></table></figure><p>虽然 mkfs 命令非常简单易用，但其不能调整分区的默认参数（比如块大小是 4096 Bytes），这些默认参数除非特殊清况，否则不需要调整。如果想要调整，就需要使用 mke2fs 命令重新格式化。</p></li></ol></li></ul><h4 id="8-9-11-mkfs2-格式化硬盘-（为硬盘写入文件系统）">8.9.11 mkfs2 格式化硬盘 （为硬盘写入文件系统）</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs [选项] 分区设备文件名</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td><code>-t 文件系统</code></td><td>指定格式化成哪个文件系统， 如 ext2、ext3、ext4；</td></tr><tr><td><code>-b 字节</code></td><td>指定 block 的大小；</td></tr><tr><td><code>-i 字节</code></td><td>指定&quot;字节 inode &quot;的比例，也就是多少字节分配一个 inode；</td></tr><tr><td><code>-j</code></td><td>建立带有 ext3 日志功能的文件系统；</td></tr><tr><td><code>-L 卷标名</code></td><td>给文件系统设置卷标名，就不使用 e2label 命令设定了；</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>格式化 <code>/dev/sdb6</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs -t ext4 -b 2048 /dev/sdb6</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式化分区，并指定block的大小为2048 Bytes</span></span><br><span class="line">mke2fe 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type：Linux</span><br><span class="line">Block size=2048 (log=1)  &lt;--block 的大小配置为 2K</span><br><span class="line">Fragment size=2048 (log=1)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks 131560</span><br><span class="line">inodes,1052240 blocks 52612 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=538968064 65 block groups</span><br><span class="line">16384 blocks per group, 16384 fragments per group</span><br><span class="line">2024 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">16384, 49152, 81920, 114688, 147456, 409600, 442368, 802816</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (32768 blocks):done</span><br><span class="line">Writing superblocks and filesystem accounting information:done</span><br><span class="line">This filesystem will be automatically checked every 38 mounts or 180 days, whichever comes first. Use tune2fs -c or-i to override.</span><br></pre></td></tr></table></figure><p>如果没有特殊需要，建议使用 mkfs 命令对硬盘分区进行格式化。</p></li></ol></li></ul><h4 id="8-9-12-虚拟内存和物理内存">8.9.12 虚拟内存和物理内存</h4><p>我们都知道，直接从内存读写数据要比从硬盘读写数据快得多，因此更希望所有数据的读取和写入都在内存中完成，然而内存是有限的，这样就引出了物理内存与虚拟内存的概念。</p><p>物理内存就是系统硬件提供的内存大小，是真正的内存。相对于物理内存，在 Linux 下还有一个虚拟内存的概念，虚拟内存是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间（又称 swap 空间）。</p><p>作为物理内存的扩展，Linux 会在物理内存不足时，使用交换分区的虚拟内存，更详细地说，就是内核会将暂时不用的内存块信息写到交换空间，这样一来，物理内存得到了释放，这块内存就可以用于其他目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。</p><p>Linux 的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p><p>要深入了解 Linux 内存运行机制，需要知道下面提到的几个方面：</p><ul><li>首先，Linux 系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux 也会交换出暂时不用的内存页面，因为这样可以大大节省等待交换所需的时间。</li><li>其次，Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，Linux 内核根据“最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到虚拟内存。</li></ul><p>有时我们会看到这么一个现象，Linux 物理内存还有很多，但是交换空间也使用了很多，其实这并不奇怪。例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动交换进物理内存（除非有这个必要），那么此时系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。</p><p>最后，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此一来，虚拟内存中可能没有足够的空间来存储这些交换页面，最终会导致 Linux 出现假死机、服务异常等问题。Linux 虽然可以在一段时间内自行恢复，但是恢复后的系统己经基本不可用了。</p><blockquote><p>因此，合理规划和设计 Linux 内存的使用是非常重要的，关于物理内存和交换空间的大小设置问题，取决于实际所用的硬盘大小，但大致遵循这样一个基本原则：</p><ol><li>如果内存较小（根据经验，物理内存小于 4GB），一般设置 swap 分区大小为内存的 2 倍；</li><li>如果物理内存大于 4GB，而小于 16GB，可以设置 swap 分区大小等于物理内存；</li><li>如果内存大小在 16GB 以上，可以设置 swap 为 0，但并不建议这么做，因为设置一定大小的 swap 分区是有一定作用的。</li></ol></blockquote><h4 id="8-9-12-swap分区">8.9.12 swap分区</h4><p>我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。</p><p>也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。</p><p>使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比 RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。相比较而言，Windows 不会为 swap 单独划分一个分区，而是使用分页文件实现相同的功能，在概念上，Windows 称其为虚拟内存，从某种意义上将，这个叫法更容易理解。因此，初学者将 swap 交换分区理解为虚拟内存是没有任何问题的。有时服务器的访问量确实很大，有可能出现 swap 分区不够用的情况，所以我们需要学习 swap 分区的构建方法。</p><ul><li><p>相关命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化swap文件系统</span></span><br><span class="line">mkswap [options] device [size]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动交换分区、观察交换分区信息-s等</span></span><br><span class="line">swapon [options] [specialfile...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#内存交换分区关闭使用</span></span><br><span class="line">swapon [options] [specialfile...]</span><br></pre></td></tr></table></figure></li></ul><ol><li><p><strong>通过物理分区构建swap分区</strong>（推荐）</p><p>创建swap前提条件,需要有一块没有使用完的硬盘（就是一块物理硬盘需要有剩余空间未分配）。</p><ul><li><p>首先查看的方式有很多，我这里用<code>lsblk</code>：(sdb物理硬盘，一共有10G，才用了不到7G，还有3G可以用)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]# lsblk</span><br><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda            8:0    0   10G  0 disk </span><br><span class="line">└─sda1         8:1    0   10G  0 part /</span><br><span class="line">sdb            8:16   0   10G  0 disk </span><br><span class="line">├─sdb1         8:17   0    5G  0 part </span><br><span class="line">│ └─vg0-lvm1 253:0    0  772M  0 lvm  </span><br><span class="line">└─sdb2         8:18   0  512M  0 part </span><br><span class="line">sr0           11:0    1 1024M  0 rom </span><br></pre></td></tr></table></figure><p>查看现在的swap空间：<code>free -lm</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]# free -lm</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           979        892         87         14          0        144</span><br><span class="line">Low:           979        892         87</span><br><span class="line">High:            0          0          0</span><br><span class="line">-/+ buffers/cache:        747        232</span><br><span class="line">Swap:            0          0          0 # 可以看到现在是没有swap空间的</span><br></pre></td></tr></table></figure></li><li><p>使用fdisk创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]# fdisk /dev/sdb 【硬盘根据实际情况选择】</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): p【打印】</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x229e658e</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Command (m for help): n【创建分区】</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p【主分区】</span><br><span class="line">Partition number (2-4, default 2):  【直接回车即可】</span><br><span class="line">First sector (10487808-20971519, default 10487808): 【选择开始块，直接回车即可】</span><br><span class="line">Using default value 10487808</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-20971519, default 20971519): +512M 【自定义大小】</span><br><span class="line">Partition 2 of type Linux and of size 512 MiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): t 【转换格式】</span><br><span class="line">Partition number (1,2, default 2): 2【选择硬盘id】</span><br><span class="line">Hex code (type L to list all codes): L【查看所有序号】</span><br><span class="line"> 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        </span><br><span class="line"> 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-</span><br><span class="line"> 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-</span><br><span class="line"> 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-</span><br><span class="line"> 4  FAT16 &lt;32M      40  Venix 80286     85  Linux extended  c7  Syrinx         </span><br><span class="line"> 5  Extended        41  PPC PReP Boot   86  NTFS volume set da  Non-FS data    </span><br><span class="line"> 6  FAT16           42  SFS             87  NTFS volume set db  CP/M / CTOS / .</span><br><span class="line"> 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   </span><br><span class="line"> 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt         </span><br><span class="line"> 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     </span><br><span class="line"> a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        </span><br><span class="line"> b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      </span><br><span class="line"> c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs        </span><br><span class="line"> e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            </span><br><span class="line"> f  W95 Ext&#x27;d (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/</span><br><span class="line">10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b</span><br><span class="line">11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      </span><br><span class="line">12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      </span><br><span class="line">14  Hidden FAT16 &lt;3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary  </span><br><span class="line">16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    </span><br><span class="line">17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE </span><br><span class="line">18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto</span><br><span class="line">1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep        </span><br><span class="line">1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT            </span><br><span class="line">1e  Hidden W95 FAT1 80  Old Minix      </span><br><span class="line">Hex code (type L to list all codes): 82 【直接输入序号回车（如82就是swap分区）</span><br><span class="line">Changed type of partition &#x27;Linux&#x27; to &#x27;Linux swap / Solaris&#x27;</span><br><span class="line"></span><br><span class="line">Command (m for help): p【打印，看刚才修改的id磁盘是否变为linux swap】</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x229e658e</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line">/dev/sdb2        10487808    11536383      524288   82  Linux swap / Solaris</span><br><span class="line"></span><br><span class="line">Command (m for help): w 【保存】</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.</span><br><span class="line">Command (m for help): w 【保存】</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.</span><br><span class="line">[root@server0 ~]# </span><br><span class="line">[root@server0 ~]# partprobe /dev/sdb  #更新硬盘信息</span><br></pre></td></tr></table></figure></li><li><p>格式化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]# lsblk   #fdisk –l 也可以看到分区信息</span><br><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda            8:0    0   10G  0 disk </span><br><span class="line">└─sda1         8:1    0   10G  0 part /</span><br><span class="line">sdb            8:16   0   10G  0 disk </span><br><span class="line">├─sdb1         8:17   0    5G  0 part </span><br><span class="line">│ └─vg0-lvm1 253:0    0  772M  0 lvm  </span><br><span class="line">└─sdb2         8:18   0  512M  0 part </span><br><span class="line">sr0           11:0    1 1024M  0 rom  </span><br><span class="line">[root@server0 ~]# mkswap /dev/sdb2  #格式化为swap，注意分区别搞错了</span><br><span class="line">Setting up swapspace version 1, size = 524284 KiB</span><br><span class="line">no label, UUID=38f22d84-e4fb-4d6a-b157-48912f761bfe  #无标签，uuid=…</span><br></pre></td></tr></table></figure></li><li><p>永久挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@station ~]# blkid【查看swap对应的分区uuid并复制】 </span><br><span class="line">[root@server0 ~]# vim /etc/fstab  # 最后一行添加下面内容</span><br><span class="line">[root@server0 ~]# tail -n 1 /etc/fstab # 查询最后一行的内容</span><br><span class="line">UUID=74bb6046-bf04-49c6-a4a2-d4fb3aebc6b7    swap   swap   defaults 0 0  </span><br><span class="line">[root@server0 ~]#</span><br><span class="line">[root@server0 ~]# swapon -a #立即挂载</span><br></pre></td></tr></table></figure><p>swap属于特殊文件，<code>mount -a</code> 是不会自动挂载的，需要输入<code>swapon -a</code> 才会自动挂载。</p></li><li><p>激活swap分区<font style="color:red">（如果上面永久挂载中执行了<code>swapon -a</code>后，忽略该步骤！）</font></p><p>激活swap命令：<code>swapon /dev/sd*</code>,如果不激活的话，即使挂载了 swap 依然不会生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]# free -l</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       1003456     927988      75468      15172        372     160828</span><br><span class="line">Low:       1003456     927988      75468</span><br><span class="line">High:            0          0          0</span><br><span class="line">-/+ buffers/cache:     766788     236668</span><br><span class="line">Swap:            0          0          0</span><br><span class="line"></span><br><span class="line">[root@server0 ~]#</span><br><span class="line">[root@server0 ~]# swapon /dev/sdb2 #激活swap</span><br><span class="line">[root@server0 ~]# free –l #激活后swap 就有值了，这样 swap分区也全部完成</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       1003456     928344      75112      15172        376     160888</span><br><span class="line">Low:       1003456     928344      75112</span><br><span class="line">High:            0          0          0</span><br><span class="line">-/+ buffers/cache:     767080     236376</span><br><span class="line">Swap:       524284          0     524284</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>通过文件来构建swap分区</strong></p><p>1.的方法适合磁盘留有剩余空间没有使用。但如果磁盘空间全部分区完毕，那么该如何创建swap分区呢？我们可以通过制作一个大的文件来构建swap分区。虽然磁盘的空间已经全部分完了，但只要其中任意一个分区还有剩余空间，该方法就可以使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建swap目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/swap</span><br><span class="line"><span class="comment">#创建swap文件,这里表示创建一个swapfile文件，文件大小count为1G</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/var/swap/swapfile bs=1024 count=1000000</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换为swap文件</span></span><br><span class="line">mkswap /var/swap/swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载激活swap文件</span></span><br><span class="line">swapon /var/swap/swapfile</span><br><span class="line"><span class="comment">#附：卸载命令	</span></span><br><span class="line"><span class="comment">#swapoff /var/swap/swapfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置开机自启动</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/var/swap/swapfile   swap  swap  defaults  0  0&quot;</span> &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure><ul><li><p>修改内核 (优化，如果没有需求则不改)</p><p>vm.swappiness参数如果为0，表示关闭swap，即使配置了swap也不会生效，所以我们这里要配置下vm.swappiness的值。</p><p>centos7默认vm.swappiness为30，也就是说，你的物理内存使用到100-30=70%时，就开始使用swap，因为内存的速度要比磁盘的速度快的多，一旦使用到swap，会加大磁盘IO，造成大量页的换进换出，影响系统性能，所以正常情况下，我们应该尽可能的使用物理内存，减少对swap虚拟内存的使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/vm/swappiness</span><br><span class="line">或</span><br><span class="line">sysctl -a | grep swappiness</span><br></pre></td></tr></table></figure><p>我这里调整值为10</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure><p>保存后，执行以下命令，使其生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>此时就是说，当物理内存使用到100-10=90%时，开始使用swap。</p></li></ul></li></ol><h4 id="8-9-25-添加磁盘及分区挂载">8.9.25 添加磁盘及分区挂载</h4><p>查看初始磁盘情况：方法1：查看<code>/dev</code>下sd开头的文件<code>ls /dev</code>，没有sdb磁盘。方法2：<code>fdisk -l</code>命令 查看系统中的磁盘信息，此时是没有sdb磁盘。</p><ol><li><p><strong>使用虚拟机添加硬盘</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/39a1089d38a0400fb7f62a07b10c76bf.gif" alt="在这里插入图片描述"></p></li><li><p>使用fdisk分区</p><p>⚠:如果提示 <strong>“Permission denied”</strong> 则是没有权限，在终端中输入 <strong><code>su</code></strong> 并填写密码进入到<strong>超级管理员模式</strong>即可。</p><p>使用命令查看分区：<code>fdisk -l</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/da9bf932811b424186a061792973b3b6.png" alt="在这里插入图片描述"></p><p>上图红色部分就是我们在 <strong>第二步</strong> 新建的磁盘 分区的路径名字为 <code>/dev/sdb</code></p><p>将这个空白分区分为两个20G的分区,输入分区的路径，也就是 <strong><code>fdisk /dev/sdb</code></strong> 进入到该分区下。</p><p>切换到该分区后我们输入 <code>p</code> 查看当前的分区的详细信息：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/a96b72eede464349a7ec4172635a44ef.png" alt="在这里插入图片描述"></p><p>可以看到，有40多G的空白分区接下来我们对磁盘进行操作，分出两个 <strong>20G</strong> 的分区</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/8eaff871f94e480e87bcf213e924efe6.gif" alt="在这里插入图片描述"></p><p><strong>注意: 操作完成后，输入</strong> <code>w</code> <strong>保存并退出</strong><br>这样我们就已经新建了一个<strong>20G</strong>的<strong>分区</strong>，重复上述操作两次即可新建出两个<strong>20G</strong>的<strong>分区</strong>。</p><p>在我们新建第二块分区时，可能会出现下面的问题。值超出范围<code>Value out of range.</code>。</p><p>分区<strong>的大小要小于你定义的</strong>虚拟磁盘**大小。适当减少 **1G 就可以了。此时输入 <code>fdisk -l</code> 查看新建的分区</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/91814c7ce1f54145af28d9aba2cb94e2.png" alt="在这里插入图片描述"></p><p><strong><code>/dev/sdb1</code></strong> 和 <strong><code>/dev/sdb2</code></strong> 就是我们新建的两个分区了</p></li><li><p>格式化分区并挂载硬盘</p><p>输入 <code>df -TH</code> 可以查看当前 <strong>分区格式</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/ab1e598cc8f747fcaf8c07729cb3c348.png" alt="在这里插入图片描述"></p><p>格式化改成 <strong>ext4</strong> 格式,输入 <code>mkfs.ext4 /dev/sdb1</code> 与 <code>mkfs.ext4 /dev/sdb2</code> 把这两个分区格式化一遍。</p><p>挂载分区，输入 <code>mkdir /sdb1</code> 与 <code>mkdir /sdb2</code>，再输入 <code>mount /dev/sdb1 /sdb1</code> 与 <code>mount /dev/sdb2 /sdb2</code> 将分区挂载到这两个目录。</p></li></ol><h3 id="8-10-系统管理">8.10 系统管理</h3><h4 id="8-10-1-进程管理">8.10.1 进程管理</h4><p>无论是 Linux 系统管理员还是普通用户，监视系统进程的运行情况并适时终止一些失控的进程，是每天的例行事务。和 Linux 系统相比，进程管理在 Windows 中更加直观，它主要是使用&quot;任务管理器&quot;来进行进程管理的。</p><ul><li><p><strong>使用&quot;任务管理器&quot;目的</strong></p><ol><li><p>利用&quot;应用程序&quot;和&quot;进程&quot;标签来査看系统中到底运行了哪些程序和进程；</p></li><li><p>利用&quot;性能&quot;和&quot;用户&quot;标签来判断服务器的健康状态；</p></li><li><p>在&quot;应用程序&quot;和&quot;进程&quot;标签中强制中止任务和进程；</p></li></ol></li><li><p><strong>进程和程序</strong></p><p>进程是正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。</p><p>这么讲很难理解，那我们换一种说法。程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。而进程是正在执行中的程序。当程序被执行时，执行人的权限和属性，以及程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 PID（进程 ID）。</p><p>也就是说，在操作系统中，所有可以执行的程序与命令都会产生进程。只是有些程序和命令非常简单，如 ls 命令、touch 命令等，它们在执行完后就会结束，相应的进程也就会终结，所以我们很难捕捉到这些进程。但是还有一些程和命令，比如 httpd 进程，启动之后就会一直驻留在系统当中，我们把这样的进程称作常驻内存进程。</p><p>某些进程会产生一些新的进程，我们把这些进程称作子进程，而把这个进程本身称作父进程。比如，我们必须正常登录到 Shell 环境中才能执行系统命令，而 Linux 的标准 Shell 是 bash。我们在 bash 当中执行了 ls 命令，那么 bash 就是父进程，而 ls 命令是在 bash 进程中产生的进程，所以 ls 进程是 bash 进程的子进程。也就是说，子进程是依赖父进程而产生的，如果父进程不存在，那么子进程也不存在了。</p></li><li><p><strong>进程管理的作用</strong></p><p>在使用 Windows 系统的过程中，使用任务管理器，很大程度上是为了强制关闭“未反应”的软件，也就是杀死进程。的确，这是很多使用进程管理工具或进程管理命令的人最常见的使用方法。不过，杀死进程（强制中止进程）只是进程管理工作中最不常用的手段，因为每个进程都有自己正确的结束方法，而杀死进程是在正常方法已经失效的情况下的后备手段。</p><p>进程管理主要有以下 3 个作用：</p><ol><li><p>判断服务器的健康状态</p><p>运维工程师最主要的工作就是保证服务器安全、稳定地运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。</p><p>进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的 CPU 占用率、内存占用率过高，就需要人为介入解决问题了。这又出现了一个问题，我们发现服务器的 CPU 或内存占用率很高，该如何介入呢？是直接终止高负载的进程吗？</p><p>当然不是，应该判断这个进程是否是正常进程，如果是正常进程，则说明你的服务器已经不能满足应用需求，你需要更好的硬件或搭建集群了；如果是非法进程占用了系统资源，则更不能直接中止进程，而要判断非法进程的来源、作用和所在位置，从而把它彻底清除。</p><p>当然，如果服务器数量很少，我们完全可以人为通过进程管理命令来进行监控与干预，但如果服务器数量较多，那么人为手工监控就变得非常困难了，这时我们就需要相应的监控服务，如 cacti 或 nagios。总之，进程管理工作中最重要的工作就是判断服务器的健康状 态，最理想的状态是服务器宕机之前就解决问题，从而避免服务器的宕机。</p></li><li><p>查看系统中所有的进程</p><p>我们需要查看看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务、是否有非法服务在运行。</p></li><li><p>杀死进程</p><p>这是进程管理中最不常用的手段。当需要停止服务时，会通过正确关闭命令来停止服务（如 apache 服务可以通过 service httpd stop 命令来关闭）。只有在正确终止进程的手段失效的情况下，才会考虑使用 kill 命令杀死进程。</p><p>其实，进程管理和 Windows 中任务管理器的作用非常类似，不过大家在使用任务管理器时是为了杀死进程，而不是为了判断服务器的健康状态。</p></li></ol></li></ul><h4 id="8-10-2-ps-查看正在运行的进程">8.10.2 ps 查看正在运行的进程</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]# ps [options]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><p>ps 命令有些与众不同，它的部分选项不能加入&quot;-“，比如命令&quot;ps aux”，其中&quot;aux&quot;是选项，但是前面不能带“-”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统中所有的进程，使用 BS 操作系统格式</span></span><br><span class="line">[root@localhost ~]# ps -l</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前登录产生的进程</span></span><br><span class="line">[root@localhost ~]# ps -le</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统中所有的进程，使用 Linux 标准命令格式</span></span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示一个终端的所有进程，除会话引线外；</td></tr><tr><td>u</td><td>显示进程的归属用户及内存的使用情况；</td></tr><tr><td>x</td><td>显示没有控制终端的进程；</td></tr><tr><td>-l</td><td>长格式显示更加详细的信息；</td></tr><tr><td>-e</td><td>显示所有进程；</td></tr><tr><td>-f</td><td>查看子父进程的关系；</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p><code>aux</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统中所有的进程</span></span><br><span class="line">USER PID %CPU %MEM  VSZ  RSS   TTY STAT START TIME COMMAND</span><br><span class="line">root   1  0.0  0.2 2872 1416   ?   Ss   Jun04 0:02 /sbin/init</span><br><span class="line">root   2  0.0  0.0    0    0   ?    S   Jun04 0:00 [kthreadd]</span><br><span class="line">root   3  0.0  0.0    0    0   ?    S   Jun04 0:00 [migration/0]</span><br><span class="line">root   4  0.0  0.0    0    0   ?    S   Jun04 0:00 [ksoftirqd/0]</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>该进程是由哪个用户产生的。</td></tr><tr><td>PID</td><td>进程的 ID。</td></tr><tr><td>%CPU</td><td>该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。</td></tr><tr><td>%MEM</td><td>该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。</td></tr><tr><td>VSZ</td><td>该进程占用虚拟内存的大小，单位为 KB。</td></tr><tr><td>RSS</td><td>该进程占用实际物理内存的大小，单位为 KB。</td></tr><tr><td>TTY</td><td>该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。</td></tr><tr><td>STAT</td><td>进程状态。常见的状态有以下几种：-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。-R：该进程正在运行。-S：该进程处于睡眠状态，可被唤醒。-T：停止状态，可能是在后台暂停或进程处于除错状态。-W：内存交互状态（从 2.6 内核开始无效）。-X：死掉的进程（应该不会出现）。-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。-&lt;：高优先级（以下状态在 BSD 格式中出现）。-N：低优先级。-L：被锁入内存。-s：包含子进程。-l：多线程（小写 L）。-+：位于后台。</td></tr><tr><td>START</td><td>该进程的启动时间。</td></tr><tr><td>TIME</td><td>该进程占用 CPU 的运算时间，注意不是系统时间。</td></tr><tr><td>COMMAND</td><td>产生此进程的命令名。</td></tr></tbody></table></li><li><p><code>-le</code></p><p>&quot;ps aux&quot;命令可以看到系统中所有的进程，&quot;ps -le&quot;命令也能看到系统中所有的进程。由于 “-l” 选项的作用，所以 “ps -le” 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">F S UID PID PPID C  PRI Nl ADDR  SZ WCHAN TTY      TIME  CMD</span><br><span class="line">4 S   0   1    0 0  80   0 -    718 -     ?    00:00:02  init</span><br><span class="line">1 S   0   2    0 0  80   0 -      0 -     ?    00:00:00  kthreadd</span><br><span class="line">1 S   0   3    2 0 -40   - -      0 -     ?    00:00:00  migration/0</span><br><span class="line">1 S   0   4    2 0  80   0 -      0 -     ?    00:00:00  ksoflirqd/0</span><br><span class="line">1 S   0   5    2 0 -40   - -      0 -     ?    00:00:00  migration/0</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>含义</th></tr></thead><tbody><tr><td>F</td><td>进程标志，说明进程的权限，常见的标志有两个: 1：进程可以被复制，但是不能被执行；4：进程使用超级用户权限；</td></tr><tr><td>S</td><td>进程状态。具体的状态和&quot;psaux&quot;命令中的 STAT 状态一致；</td></tr><tr><td>UID</td><td>运行此进程的用户的 ID；</td></tr><tr><td>PID</td><td>进程的 ID；</td></tr><tr><td>PPID</td><td>父进程的 ID；</td></tr><tr><td>C</td><td>该进程的 CPU 使用率，单位是百分比；</td></tr><tr><td>PRI</td><td>进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行；</td></tr><tr><td>NI</td><td>进程的优先级，数值越小，该进程越早被执行；</td></tr><tr><td>ADDR</td><td>该进程在内存的哪个位置；</td></tr><tr><td>SZ</td><td>该进程占用多大内存；</td></tr><tr><td>WCHAN</td><td>该进程是否运行。&quot;-&quot;代表正在运行；</td></tr><tr><td>TTY</td><td>该进程由哪个终端产生；</td></tr><tr><td>TIME</td><td>该进程占用 CPU 的运算时间，注意不是系统时间；</td></tr><tr><td>CMD</td><td>产生此进程的命令名；</td></tr></tbody></table></li></ol></li></ul><h4 id="8-10-3-top-持续监听进程运行状态">8.10.3 top 持续监听进程运行状态</h4><p>top 命令可以动态地持续监听进程地运行状态，与此同时，该命令还提供了一个交互界面，用户可以根据需要，人性化地定制自己的输出，进而更清楚地了进程的运行状态。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top [选项]</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定 top 命令每隔几秒更新。默认是 3 秒；</td></tr><tr><td>-b</td><td>使用批处理模式输出。一般和&quot;-n&quot;选项合用，用于把 top 命令重定向到文件中；</td></tr><tr><td>-n 次数</td><td>指定 top 命令执行的次数。一般和&quot;-&quot;选项合用；</td></tr><tr><td>-p 进程PID</td><td>仅查看指定 ID 的进程；</td></tr><tr><td>-s</td><td>使 top 命令在安全模式中运行，避免在交互模式中出现错误；</td></tr><tr><td>-u 用户名</td><td>只监听某个用户的进程；</td></tr></tbody></table></li><li><p>交互命令</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>?：h</td><td>显示交互模式的帮助；</td></tr><tr><td>P</td><td>按照 CPU 的使用率排序，默认就是此选项；</td></tr><tr><td>M</td><td>按照内存的使用率排序；</td></tr><tr><td>N</td><td>按照 PID 排序；</td></tr><tr><td>T</td><td>按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序；</td></tr><tr><td>k</td><td>按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号；</td></tr><tr><td>r</td><td>按照 PID 给某个进程重设优先级（Nice）值；</td></tr><tr><td>q</td><td>退出 top 命令；</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>top 命令的执行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 12:26:46 up 1 day, 13:32, 2 users, load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.7%id, 0.1%wa, 0.0%hi, 0.1%si, 0.0%st</span><br><span class="line">Mem: 625344k total, 571504k used, 53840k free, 65800k buffers</span><br><span class="line">Swap: 524280k total, 0k used, 524280k free, 409280k cached</span><br><span class="line">PID   USER PR NI VIRT  RES  SHR S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">19002 root 20  0 2656 1068  856 R  0.3  0.2 0:01.87 top</span><br><span class="line">1     root 20  0 2872 1416 1200 S  0.0  0.2 0:02.55 init</span><br><span class="line">2     root 20  0    0    0    0 S  0.0  0.0 0:00.03 kthreadd</span><br><span class="line">3     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0</span><br><span class="line">4     root 20  0    0    0    0 S  0.0  0.0 0:00.15 ksoftirqd/0</span><br><span class="line">5     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0</span><br><span class="line">6     root RT  0    0    0    0 S  0.0  0.0 0:10.01 watchdog/0</span><br><span class="line">7     root 20  0    0    0    0 S  0.0  0.0 0:05.01 events/0</span><br><span class="line">8     root 20  0    0    0    0 S  0.0  0.0 0:00.00 cgroup</span><br><span class="line">9     root 20  0    0    0    0 S  0.0  0.0 0:00.00 khelper</span><br><span class="line">10    root 20  0    0    0    0 S  0.0  0.0 0:00.00 netns</span><br><span class="line">11    root 20  0    0    0    0 S  0.0  0.0 0:00.00 async/mgr</span><br><span class="line">12    root 20  0    0    0    0 S  0.0  0.0 0:00.00 pm</span><br><span class="line">13    root 20  0    0    0    0 S  0.0  0.0 0:01.70 sync_supers</span><br><span class="line">14    root 20  0    0    0    0 S  0.0  0.0 0:00.63 bdi-default</span><br><span class="line">15    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kintegrityd/0</span><br><span class="line">16    root 20  0    0    0    0 S  0.0  0.0 0:02.52 kblockd/0</span><br><span class="line">17    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpid</span><br><span class="line">18    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpi_notify</span><br></pre></td></tr></table></figure><p>我们解释一下命令的输出。top 命令的输出内容是动态的，默认每隔 3 秒刷新一次。命令的输出主要分为两部分：</p><ol><li><p>第一部分是前五行（显示的是整个系统的资源使用状况，我们就是通过这些输出来判断服务器的资源使用状态的）</p><p>1.1 第一行为任务队列信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>12:26:46</td><td>系统当前时间</td></tr><tr><td>up 1 day, 13:32</td><td>系统的运行时间.本机己经运行 1 天 13 小时 32 分钟</td></tr><tr><td>2 users</td><td>当前登录了两个用户</td></tr><tr><td>load average: 0.00,0.00，0.00</td><td>系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 （这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU 的核数）</td></tr></tbody></table><p>1.2 第二行为进程信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Tasks: 95 total</td><td>系统中的进程总数</td></tr><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>94 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>正在停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数。如果不是 0，则需要手工检查僵尸进程</td></tr></tbody></table><p>1.3 第三行为 CPU 信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Cpu(s): 0.1 %us</td><td>用户模式占用的 CPU 百分比</td></tr><tr><td>0.1%sy</td><td>系统模式占用的 CPU 百分比</td></tr><tr><td>0.0%ni</td><td>改变过优先级的用户进程占用的 CPU 百分比</td></tr><tr><td>99.7%id</td><td>空闲 CPU 占用的 CPU 百分比</td></tr><tr><td>0.1%wa</td><td>等待输入/输出的进程占用的 CPU 百分比</td></tr><tr><td>0.0%hi</td><td>硬中断请求服务占用的 CPU 百分比</td></tr><tr><td>0.1%si</td><td>软中断请求服务占用的 CPU 百分比</td></tr><tr><td>0.0%st</td><td>st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比</td></tr></tbody></table><p>1.4 第四行为物理内存信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Mem: 625344k total</td><td>物理内存的总量，单位为KB</td></tr><tr><td>571504k used</td><td>己经使用的物理内存数量</td></tr><tr><td>53840k&amp;ee</td><td>空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存</td></tr><tr><td>65800k buffers</td><td>作为缓冲的内存数量</td></tr></tbody></table><p>1.5 第五行为交换分区（swap）信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Swap: 524280k total</td><td>交换分区（虚拟内存）的总大小</td></tr><tr><td>Ok used</td><td>已经使用的交换分区的大小</td></tr><tr><td>524280k free</td><td>空闲交换分区的大小</td></tr><tr><td>409280k cached</td><td>作为缓存的交换分区的大小</td></tr></tbody></table><p>我们通过 top 命令的第一部分就可以判断服务器的健康状态。如果 1 分钟、5 分钟、15 分钟的平均负载高于 1，则证明系统压力较大。如果 CPU 的使用率过高或空闲率过低，则证明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。</p><p>这时，我们就应该判断是什么进程占用了系统资源。如果是不必要的进程，就应该结束这些进程；如果是必需进程，那么我们该増加服务器资源（比如増加虚拟机内存），或者建立集群服务器。</p><p>&lt;----&gt;</p><p>解释一下缓冲（buffer）和缓存（cache）的区别：<font style="color:red">（缓存（cache）是用来加速数据从硬盘中&quot;读取&quot;的，而缓冲（buffer）是用来加速数据&quot;写入&quot;硬盘的）</font></p><ul><li>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。</li><li>缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</li></ul></li><li><p>第二部分从第六行开始（显示的是系统中进程的信息）</p><ul><li><p>PID：进程的 ID。</p></li><li><p>USER：该进程所属的用户。</p></li><li><p>PR：优先级，数值越小优先级越高。</p></li><li><p>NI：优先级，数值越小、优先级越高。</p></li><li><p>VIRT：该进程使用的虚拟内存的大小，单位为 KB。</p></li><li><p>RES：该进程使用的物理内存的大小，单位为 KB。</p></li><li><p>SHR：共享内存大小，单位为 KB。</p></li><li><p>S：进程状态。</p></li><li><p>%CPU：该进程占用 CPU 的百分比。</p></li><li><p>%MEM：该进程占用内存的百分比。</p></li><li><p>TIME+：该进程共占用的 CPU 时间。</p></li><li><p>COMMAND：进程的命令名。</p></li></ul></li></ol></li><li><p>top 命令中止某个进程</p><p>进入交互后按 <code>k</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 14:10:15 up 1 day, 15:15， 3 users, load average: 0.00，0.00, 0.00</span><br><span class="line">Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.0%us, 0.0%sy, 0.0%ni,100.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</span><br><span class="line">Mem: 625344k total, 574248k used, 51096k free, 66840k buffers</span><br><span class="line">Swap: 524280k total, Ok used, 524280k free, 409324k cached</span><br><span class="line">PID to kill:15273</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按<span class="string">&quot;k&quot;</span>键，会提示输入要杀死进程的PID</span></span><br><span class="line">PID     USER PR NI VIRT  RES SHR S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">15273 daemon 20  0 4520 1192 580 S  0.0 0.2  0:00.00 httpd</span><br><span class="line">..省略部分输出...</span><br></pre></td></tr></table></figure><p>输入要中止进程的 PID，比如要中止 <code>15273</code> 这个 apache 进程，接下来 top 命令提示我们输入信号，信号 <code>9</code> 代表强制中止，这时就能够强制中止 15273 进程了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top - 14:11:42 up 1 day, 15:17， 3 users, load average: 0.00，0.00, 0.00</span><br><span class="line">Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.0%us, 0.3%sy, 0.0%ni, 99.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</span><br><span class="line">Mem: 625344k total, 574248k used, 51096k free, 66856k buffers</span><br><span class="line">Swap: 524280k total, 0k used, 524280k free, 409324k cached</span><br><span class="line">Kill PID 15273 with signal [15]:9</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提示输入信号，信号9代表强制中止</span></span><br><span class="line">PID     USER PR NI VIRT  RES SHR S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">15273 daemon 20  0 4520 1192 580 S 0.0   0.2 0:00.00 httpd</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure></li><li><p>改变某个进程的优先级，就要利用 <code>r</code> 交互命令：需要注意的是，我们能够修改的只有 NI（Nice） 的优先级，而不能修改 PR（Priority） 的优先级。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top -p 18977</span><br><span class="line">top - 14:17:09 up 1 day, 15:22, 3 users, load average: 0.00，0.00, 0.00</span><br><span class="line">Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.3%us, 0.0%sy, 0.0%ni, 99.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</span><br><span class="line">Mem: 625344k total, 574124k used, 51220k free, 66896k buffers</span><br><span class="line">Swap: 524280k total, 0k used, 524280k free, 409324k cached</span><br><span class="line">PID to renice:</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入<span class="string">&quot;r&quot;</span>交互命令之后，提示输入要修改优先级的进程的PID</span></span><br><span class="line">PID   USER PR NI  VIRT  RES SHR  S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">18977 root 20 0  11592 3304 2572 S  0.0 0.5  0:04.37 sshd</span><br></pre></td></tr></table></figure><p>输入 “r” 交互命令，会提示输入需要修改优先级的进程的 PID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Renice PID 18977 to value: 10</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入PID后，需要输入Nice的优先级号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我们把18977进程的优先级调整为10,回车后就能看到</span></span><br><span class="line">PID   USER PR NI  VIRT  RES SHR  S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">18977 root 30 10 11592 3304 2572 R  0.0 0.5  0:04.38 sshd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">18977进程的优先级已经被修改了</span></span><br></pre></td></tr></table></figure></li><li><p>如果在操作终端执行 top 命令，则并不能看到系统中所有的进程，默认看到的只是 CPU 占比靠前的进程。如果我们想要看到所有的进程，则可以把 top 命令的执行结果重定向到文件中。不过 top 命令是持续运行的，这时就需要使用 “-b” 和 “-n” 选项了。具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top -b -n 1 &gt; /root/top.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让top命令只执行一次，然后把执行结果保存到top.log文件中，这样就能看到所有的进程了</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="8-10-5-lsof">8.10.5 lsof</h4><p>lsof 命令，“list opened files”的缩写，直译过来，就是列举系统中已经被打开的文件。通过 lsof 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof [options]</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td><code>-c 字符串</code></td><td>只列出以字符串开头的进程打开的文件。</td></tr><tr><td><code>+d 目录名</code></td><td>列出某个目录中所有被进程调用的文件。</td></tr><tr><td><code>-u 用户名</code></td><td>只列出某个用户的进程打开的文件。</td></tr><tr><td><code>-p pid</code></td><td>列出某个 PID 进程打开的文件。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p><code>lsof</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof | more</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询系统中所有进程调用的文件</span></span><br><span class="line">COMMAND PID  USER  FD    TYPE  DEVICE  SIZE/OFF  NODE  NAME</span><br><span class="line">init               1      root    cwd  DIR    8，3       4096        2           /</span><br><span class="line">init               1      root    rtd    DIR    8，3       4096        2           /</span><br><span class="line">init               1      root    txt     REG   8，3       145180    130874 /sbin/init</span><br><span class="line">init               1      root    mem REG   8，3       142472    665291 /lib/ld-2.12.so</span><br><span class="line">init               1      root    mem REG   8，3       58704      655087 /lib/libnss_files-2.12.so</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><p>这个命令的输出非常多。它会按照 PID，从 1 号进程开始列出系统中所有的进程正在调用的文件名。</p></li><li><p><code>lsof 路径</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof /sbin/init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询某个文件被哪个进程调用</span></span><br><span class="line">COMMAND PID USER  FD  TYPE  DEVICE  SIZE/OFF  NODE    NAME</span><br><span class="line">init               1     root    txt  REG   8，3      145180     130874   /sbin/init</span><br></pre></td></tr></table></figure><p>sof 命令也可以反过来查询某个文件被哪个进程调用。这个例子就查询到 /sbin/init 文件是被 init 进程调用的。</p></li></ol></li></ul><h4 id="8-10-4-pstree-查看进程树">8.10.4 pstree 查看进程树</h4><p>Linux pstree(英文全称：display a tree of processes）) 命令将所有进程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本进程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的进程。</p><ul><li><p>yum 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install psmisc</span><br></pre></td></tr></table></figure></li><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pstree [options] [[PID][userName]</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示启动每个进程对应的完整指令，包括启动进程的路径、参数等。</td></tr><tr><td>-c</td><td>不使用精简法显示进程信息，即显示的进程中包含子进程和父进程。</td></tr><tr><td>-n</td><td>根据进程 PID 号来排序输出，默认是以程序名排序输出的。</td></tr><tr><td>-p</td><td>显示进程的 PID。</td></tr><tr><td>-u</td><td>显示进程对应的用户名称。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p><code>-p</code> 显示进程的 PID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# pstree -p</span><br><span class="line">systemd(1)─┬─NetworkManager(542)─┬─dhclient(628)</span><br><span class="line">           │                     ├─&#123;NetworkManager&#125;(563)</span><br><span class="line">           │                     └─&#123;NetworkManager&#125;(567)</span><br><span class="line">...省略部分输出...</span><br><span class="line">           ├─sshd(893)───sshd(1146)─┬─bash(1150)───pstree(8599)		#Pstree命令进程是在远程连接中被执行的</span><br><span class="line">           │                        ├─bash(1171)───top(1248)</span><br><span class="line">           │                        ├─bash(8589)───sleep(8598)</span><br><span class="line">           │                        └─sftp-server(1165)</span><br><span class="line">           ├─systemd-journal(367)</span><br><span class="line">           ├─systemd-logind(547)</span><br><span class="line">           ├─systemd-udevd(397)</span><br><span class="line">           ├─tuned(891)─┬─&#123;tuned&#125;(1139)</span><br><span class="line">           │            ├─&#123;tuned&#125;(1140)</span><br><span class="line">           │            ├─&#123;tuned&#125;(1142)</span><br><span class="line">           │            └─&#123;tuned&#125;(1143)</span><br><span class="line">           └─vmtoolsd(535)─┬─&#123;vmtoolsd&#125;(562)</span><br><span class="line">                           └─&#123;vmtoolsd&#125;(575)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如果想知道某个用户都启动了哪些进程，使用 pstree 命令可以很容易实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@1ocalhost ~]# pstree mysql</span><br><span class="line">mysqid---6*[&#123;mysqid&#125;]</span><br></pre></td></tr></table></figure><p>此输出结果显示了 mysql 用户对应的进程为 mysqid，并且 mysqid 进程拥有 5 个子进程（外加 1 个父进程，共计 6 个进程）。</p></li></ol></li></ul><h4 id="8-10-6-kill-终止进程">8.10.6 kill 终止进程</h4><p>kill 命令的执行原理是这样的，kill 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。</p><p><strong><font style="color:red">注意<code>/user/sbin/sshd -D</code> 此守护进程不能关闭，否则将无法远程登录，需要去机房重启sshd服务守护进程要谨慎的处理否则可能会造成重大故障！</font></strong></p><p>kill 命令只是“发送”一个信号，因此，只有当信号被程序成功“捕获”，系统才会执行 kill 命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则 kill 命令将会失效。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill [options] PID</span><br></pre></td></tr></table></figure><p>kill 命令是按照 PID 来确定进程的，所以 kill 命令只能识别 PID，而不能识别进程名。Linux 定义了几十种不同类型的信号，读者可以使用 kill -l 命令查看所有信号及其编号，这里仅列出几个常用的信号，如表 1 所示。</p></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-l &lt;信息编号&gt;</code></td><td>打印指定编号的信息名称；<br>若不加&lt;信息编号&gt;选项，则 -l 参数会列出全部的信息名称</td></tr><tr><td><code>-&lt;信息名称或编号&gt; &lt;程序&gt;</code><br><code>-s &lt;信息名称或编号&gt; &lt;程序&gt;</code></td><td>指定要送出的信息。<br><code>-1 nginx</code> #（以信息1为例）nginx 进程重启。<br>详情请看常用信息名称表。<br>&lt;程序&gt;可以是程序的PID或是PGID，也可以是工作编号。</td></tr></tbody></table></li><li><p>信息名称表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX   </span><br></pre></td></tr></table></figure><p>常用信息名称表：</p><table><thead><tr><th>信息编号</th><th>信息名</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>EXIT</td><td>程序退出时收到该信息。</td></tr><tr><td>1</td><td>HUP</td><td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td></tr><tr><td>2</td><td>INT</td><td>表示结束进程，但并不是强制性的，常用的 “Ctrl+C” 组合键发出就是一个 kill -2 的信号。</td></tr><tr><td>3</td><td>QUIT</td><td>退出。</td></tr><tr><td>9</td><td>KILL</td><td>杀死进程，即强制结束进程。</td></tr><tr><td>11</td><td>SEGV</td><td>段错误。</td></tr><tr><td>15</td><td>TERM</td><td>正常结束进程，是 kill 命令的默认信号。</td></tr><tr><td>19</td><td>STOP</td><td>让进程暂停</td></tr></tbody></table><p>需要注意的是，表中省略了各个信号名称的前缀 SIG，也就是说，SIGTERM 和 TERM 这两种写法都对，kill 命令都可以理解。</p></li></ul><h4 id="8-10-7-killall-终止特定的一类进程">8.10.7 killall 终止特定的一类进程</h4><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# killall [选项] [信号] 进程名</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>交互式，询问是否要杀死某个进程</td></tr><tr><td><code>-l</code></td><td>忽略进程名的大小写</td></tr></tbody></table></li><li><p><strong>实例</strong></p><ol><li><p>杀死 httpd 进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service httpd start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动RPM包默认安装的apache服务</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;httpd&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root 1600 0.0 0.2 4520 1696? Ss 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1601 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1602 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1603 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1604 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1605 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看httpd进程</span></span><br><span class="line">[root@localhost ~]# killall httpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">杀死所有进程名是httpd的进程</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;httpd&quot; | grep -v &quot;grep&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询发现所有的httpd进程都消失了</span></span><br></pre></td></tr></table></figure></li><li><p>交互式杀死 sshd 进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux | grep &quot;sshd&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root 1733 0.0 0.1 8508 1008? Ss 19:47 0:00/usr/sbin/sshd</span><br><span class="line">root 1735 0.1 0.5 11452 3296? Ss 19:47 0:00 sshd: root@pts/0</span><br><span class="line">root 1758 0.1 0.5 11452 3296? Ss 19:47 0:00 sshd: root@pts/1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询系统中有3个sshd进程。1733是sshd服务的进程，1735和1758是两个远程连接的进程</span></span><br><span class="line">[root@localhost ~]# killall -i sshd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">交互式杀死sshd进程</span></span><br><span class="line">杀死sshd(1733)?(y/N)n</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个进程是sshd的服务进程，如果杀死，那么所有的sshd连接都不能登陆</span></span><br><span class="line">杀死 sshd(1735)?(y/N)n</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是当前登录终端，不能杀死我自己吧</span></span><br><span class="line">杀死 sshd(1758)?(y/N)y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">杀死另一个sshd登陆终端</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="8-10-8-crontab-循环执行定时任务">8.10.8 crontab 循环执行定时任务</h4><p>Linux crontab 是用来定期执行程序的命令。</p><p>crontab 命令需要 crond 服务支持。crond 是 Linux 下用来周期地执行某种任务或等待处理某些事件的一个守护进程，和 Windows 中的计划任务有些类似。</p><p>在安装完成操作系统后，默认会安装 crond 服务工具，且 crond 服务默认就是自启动的。crond 进程每分钟会定期检查是否有要执行的任务，如果有，则会自动执行该任务。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# crontab [options] [file]</span><br></pre></td></tr></table></figure><p>位于<code>/var/spool/cron/</code></p></li><li><p><strong>通过 <code>/etc/cron.allow</code> 和 <code>/etc/cron.deny</code> 文件来限制某些用户是否可以使用 crontab 命令:</strong></p><ul><li>当系统中有 <code>/etc/cron.allow</code> 文件时，只有写入此文件的用户可以使用 crontab 命令，没有写入的用户不能使用 crontab 命令。同样，如果有此文件，<code>/etc/cron.deny</code> 文件会被忽略，因为 <code>/etc/cron.allow</code> 文件的优先级更高。</li><li>当系统中只有 /etc/cron.deny 文件时，写入此文件的用户不能使用 crontab 命令，没有写入文件的用户可以使用 crontab 命令。</li><li>这个规则基本和 at 命令的规则一致，同样是 <code>/etc/cron.allow</code> 文件比 <code>/etc/cron.deny</code> 文件的优先级高，Linux 系统中默认只有 <code>/etc/cron.deny</code> 文件。</li></ul></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-u user</td><td>用来设定某个用户的 crontab 服务，例如 “-u demo” 表示设备 demo 用户的 crontab 服务，此选项一般有 root 用户来运行。</td></tr><tr><td>-e</td><td>编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件。</td></tr><tr><td>-l</td><td>显示某用户的 crontab 文件内容，如果不指定用户，则表示显示当前用户的 crontab 文件内容。</td></tr><tr><td>-r</td><td>从 /var/spool/cron 删除某用户的 crontab 文件，如果不指定用户，则默认删除当前用户的 crontab 文件。</td></tr><tr><td>-i</td><td>在删除用户的 crontab 文件时，给确认提示。</td></tr></tbody></table><p>每个用户都可以实现自己的 crontab 定时任务，只需使用这个用户身份执行“<code>crontab -e</code>”命令即可。当然，这个用户不能写入 <code>/etc/cron.deny</code> 文件。</p></li><li><p><strong>其实 crontab 定时任务非常简单，只需执行“crontab -e”命令，然后输入想要定时执行的任务即可。不过，当我们执行“crontab -e”命令时，打开的是一个空文件，而且操作方法和 Vim 是一致的。那么，这个文件的格式才是我们真正需要学习的内容。文件格式如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ！]# crontab -e</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入 crontab 编辑界面。会打开Vim编辑你的任务</span></span><br><span class="line">* * * * * 执行的任务</span><br></pre></td></tr></table></figure><p>这个文件中是通过 5 个“*”来确定命令或任务的执行时间的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12)</span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure><p>在时间表示中，还有一些特殊符号需要学习</p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*（星号）</td><td>代表任何时间。比如第一个&quot;*&quot;就代表一小时种每分钟都执行一次的意思。</td></tr><tr><td>,（逗号）</td><td>代表不连续的时间。比如&quot;0 8,12,16 * * * 命令&quot;就代表在每天的 8 点 0 分、12 点 0 分、16 点 0 分都执行一次命令。</td></tr><tr><td>-（中杠）</td><td>代表连续的时间范围。比如&quot;0 5 * * 1-6 命令&quot;，代表在周一到周六的凌晨 5 点 0 分执行命令。</td></tr><tr><td>/（正斜线）</td><td>代表每隔多久执行一次。比如&quot;* /10* * * * 命令&quot;，代表每隔 10 分钟就执行一次命令。</td></tr></tbody></table><p>当“crontab -e”编辑完成之后，一旦保存退出，那么这个定时任务实际就会写入 <code>/var/spool/cron/</code> 目录中，每个用户的定时任务用自己的用户名进行区分。而且 crontab 命令只要保存就会生效，只要 crond 服务是启动的。知道了这 5 个时间字段的含义，我们多举几个时间的例子来熟悉一下时间字段</p><table><thead><tr><th>时间</th><th>含义</th></tr></thead><tbody><tr><td>45 22 * * * 命令</td><td>在 22 点 45 分执行命令</td></tr><tr><td>0 17 * * 1 命令</td><td>在每周一的 17 点 0 分执行命令</td></tr><tr><td>0 5 1,15 * * 命令</td><td>在每月 1 日和 15 日的凌晨 5 点 0 分执行命令</td></tr><tr><td>40 4 * * 1-5 命令</td><td>在每周一到周五的凌晨 4 点 40 分执行命令</td></tr><tr><td>/10 4 * * * 命令</td><td>在每天的凌晨 4 点，每隔 10 分钟执行一次命令</td></tr><tr><td>0 0 1,15 * 1 命令</td><td>在每月 1 日和 15 日，每周一 0 点 0 分都会执行命令，注意：星期几和几日最好不要同时出现，因为它们定义的都是天，非常容易让管理员混淆</td></tr></tbody></table></li><li><p><strong>在书写 crontab 定时任务时，需要注意以下几个事项：</strong></p><ul><li><p>6 个选项都不能为空，必须填写。如果不确定，则使用“*”代表任意时间。</p></li><li><p>crontab 定时任务的最小有效时间是分钟，最大有效时间是月。像 2018 年某时执行、3 点 30 分 30 秒这样的时间都不能被识别。</p></li><li><p>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都以天为单位，非常容易让管理员混淆。</p></li><li><p>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都使用绝对路径。有时使用相对路径的命令会报错。</p></li></ul></li></ul><h4 id="8-10-9-free-查看内存使用状态">8.10.9 free 查看内存使用状态</h4><p>free 命令用来显示系统内存状态，包括系统物理内存、虚拟内存（swap 交换分区）、共享内存和系统缓存的使用情况，其输出和 top 命令的内存部分非常相似。</p><ul><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free [options]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free -lh -s n</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示人性化的内存信息，包括占用内存的高低；n秒刷新一次</span></span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>以 Byte（字节）为单位，显示内存使用情况。</td></tr><tr><td>-h</td><td>显示人性化的内存大小信息</td></tr><tr><td>-k</td><td>以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项。</td></tr><tr><td>-l</td><td>显示占用内存的高低</td></tr><tr><td>-m</td><td>以 MB 为单位，显示内存使用情况。</td></tr><tr><td>-g</td><td>以 GB 为单位，显示内存使用情况。</td></tr><tr><td>-t</td><td>在输出的最终结果中，输出内存和 swap 分区的总量。</td></tr><tr><td>-o</td><td>不显示系统缓冲区这一列。</td></tr><tr><td>-s 间隔秒数</td><td>根据指定的间隔时间，持续显示内存使用情况。</td></tr></tbody></table></li><li><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free -m</span><br><span class="line">                  total       used    free   shared   buffers    cached</span><br><span class="line">Mem:           725        666      59           0       132         287</span><br><span class="line">-/+ buffers/cache:     245     479</span><br><span class="line">Swap:           996            0     996</span><br></pre></td></tr></table></figure><blockquote><ul><li>total 是总内存数；</li><li>used 是已经使用的内存数；</li><li>free 是空闲的内存数；</li><li>shared 是多个进程共享的内存总数；</li><li>buffers 是缓冲内存数；</li><li>cached 是缓存内存数。</li></ul></blockquote></li></ul><h4 id="8-10-10-w-who-查看登陆用户信息">8.10.10 w who 查看登陆用户信息</h4><ul><li><p><strong><code>w</code> 语法</strong></p><p>Linux 中，使用 w 或 who 命令都可以查看服务器上目前已登录的用户信息，两者的区别在于，w 命令除了能知道目前已登陆的用户信息，还可以知道每个用户执行任务的情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w [options] [username]</span><br></pre></td></tr></table></figure></li></ul><p>​</p><ul><li><p><strong><code>w</code> 选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>不显示输出信息的标题</td></tr><tr><td>-l</td><td>用长格式输出</td></tr><tr><td>-s</td><td>用短格式输出，不显示登陆时间，JCPU 和 PCPU 时间</td></tr><tr><td>-V</td><td>显示版本信息</td></tr></tbody></table></li><li><p><strong><code>w</code> 实例</strong></p><p>显示当前用户登陆信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 13:13:56 up 13:00,  1 user,  load average: 0.08, 0.02, 0.01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前的系统时间、系统从启动至今已运行的时间、登陆到系统中的用户数和系统平均负载(平均负载（load average）指的是在 1 分钟、5 分钟、15 分钟内系统的负载状况)</span></span><br><span class="line">USER   TTY    FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root    tty1    -                        11:04       0.00s  0.36s   0.00s  -bash</span><br><span class="line">root    pts/0  192.168.0.108   13:15       0.00s   0.06s   0.02s   w</span><br></pre></td></tr></table></figure><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>登录到系统的用户。</td></tr><tr><td>TTY</td><td>登录终端。</td></tr><tr><td>FROM</td><td>表示用户从哪里登陆进来，一般显示远程登陆主机的 IP 地址或者主机名。</td></tr><tr><td>LOGIN@</td><td>用户登陆的日期和时间。</td></tr><tr><td>IDLE</td><td>表示某个程序上次从终端开始执行到现在所持续的时间。</td></tr><tr><td>JCPU</td><td>和该终端连接的所有进程占用的 CPU 运算时间。这个时间里并不包括过去的后台作业时间，但是包括当前正在运行的后台作业所占用的时间。</td></tr><tr><td>PCPU</td><td>当前进程所占用的 CPU 运算时间。</td></tr><tr><td>WHAT</td><td>当前用户正在执行的进程名称和选项，换句话说，就是表示用户当前执行的是什么命令。</td></tr></tbody></table></li><li><p><strong><code>who</code> 语法</strong></p><p>who 命令只能显示当前登陆的用户信心，但无法知晓每个用户正在执行的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who [options] [file]</span><br></pre></td></tr></table></figure></li></ul><p>​ who 命令默认是通过 /var/run/utmp 文件来获取登陆用户信息，但如果通过 file 指定另一个文件，则 who 命令将不再默认读取 /var/run/utmp 文件，而是读取该指定文件来获取信息。</p><ul><li><p><strong><code>who</code> 选项</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>列出所有信息，相当于所有选项。</td></tr><tr><td>-b</td><td>列出系统最近启动的时间日期。</td></tr><tr><td>-l</td><td>列出所有可登陆的终端信息。</td></tr><tr><td>-m</td><td>仅列出关于当前终端的信息，<code>who -m</code> 命令等同于 <code>who am i</code>。</td></tr><tr><td>-q</td><td>列出在本地系统上的用户和用户数的清单。</td></tr><tr><td>-r</td><td>显示当前系统的运行级别。</td></tr><tr><td>-s</td><td>仅显示名称、线路和时间字段信息，这是 who 命令的默认选项。</td></tr><tr><td>-u</td><td>显示当前每个用户的用户名、登陆终端、登陆时间、线路活动和进程标识。</td></tr><tr><td>-T 或 -w</td><td>显示 tty 终端的状态，“+”表示对任何人可写，“-”表示仅对 root 用户或所有者可写，“？”表示遇到线路故障</td></tr></tbody></table></li><li><p><strong><code>who</code> 实例</strong></p><p>显示系统最新启动日期，以及每个用户的登陆详情、终端状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who     &lt;--等同于 who -s</span><br><span class="line">root tty1 2013-06-07 09：53</span><br><span class="line">root pts/0 2013-06-07 09：53 (192.168.0.108)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名 登录终端 登录时间（登录来源IP）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="8-11-端口管理">8.11 端口管理</h3><h4 id="8-11-1-netstat-显示网络状态">8.11.1 netstat 显示网络状态</h4><ul><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y net-tools</span><br></pre></td></tr></table></figure></li><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat [options]</span><br></pre></td></tr></table></figure></li><li><p><strong>常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tunlp | grep 进程号/端口 # 查看该进程或端口网络信息</span><br><span class="line">[root@localhost ~]# netstat -anp | grep 进程号/端口 # 查看该进程或端口网络信息</span><br><span class="line">[root@localhost ~]# netstat -anp | grep 3306 | wc -l # 统计进程数，如果接近预设值，说明不够用，需要增加</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><strong>-a或–all</strong></td><td>显示所有连线中的Socket。</td></tr><tr><td>-A&lt;网络类型&gt;或–&lt;网络类型&gt;</td><td>列出该网络类型连线中的相关地址。</td></tr><tr><td>-c或–continuous</td><td>持续列出网络状态。</td></tr><tr><td>-C或–cache</td><td>显示路由器配置的快取信息。</td></tr><tr><td>-e或–extend</td><td>显示网络其他相关信息。</td></tr><tr><td>-F或–fib</td><td>显示路由缓存。</td></tr><tr><td>-g或–groups</td><td>显示多重广播功能群组组员名单。</td></tr><tr><td>-h或–help</td><td>在线帮助。</td></tr><tr><td>-i或–interfaces</td><td>显示网络界面信息表单。</td></tr><tr><td><strong>-l或–listening</strong></td><td>显示监控中的服务器的Socket。</td></tr><tr><td>-M或–masquerade</td><td>显示伪装的网络连线。</td></tr><tr><td><strong>-n或–numeric</strong></td><td>直接使用IP地址，而不通过域名服务器。</td></tr><tr><td>-N或–netlink或–symbolic</td><td>显示网络硬件外围设备的符号连接名称。</td></tr><tr><td>-o或–timers</td><td>显示计时器。</td></tr><tr><td><strong>-p或–programs</strong></td><td>显示正在使用Socket的程序识别码和程序名称。</td></tr><tr><td><strong>-r或–route</strong></td><td>显示Routing Table。</td></tr><tr><td>-s或–statistics</td><td>显示网络工作信息统计表。</td></tr><tr><td>-t或–tcp</td><td>显示TCP传输协议的连线状况。</td></tr><tr><td>-u或–udp</td><td>显示UDP传输协议的连线状况。</td></tr><tr><td>-v或–verbose</td><td>显示指令执行过程。</td></tr><tr><td>-V或–version</td><td>显示版本信息。</td></tr><tr><td>-w或–raw</td><td>显示RAW传输协议的连线状况。</td></tr><tr><td>-x或–unix</td><td>此参数的效果和指定&quot;-A unix&quot;参数相同。</td></tr><tr><td>–ip或–inet</td><td>此参数的效果和指定&quot;-A inet&quot;参数相同。</td></tr></tbody></table></li></ul><h2 id="9）系统备份">9）系统备份</h2><h3 id="1-备份的重要性">1.备份的重要性</h3><p>虽然 Linux 系统难免会因内部环境、底层硬件、外来黑客等因素的影响出现问题，但作为一名系统管理人员，自身的职责并不是要保证系统永远不出问题（事实上也是不可能做到的），而是要在系统出现故障或者崩溃时，能以最快的速度，用最短时间恢复系统的运行，保证数据的安全，从而将故障带来的损失降到最低。</p><p>要实现这样的目标，就要求系统管理人员对系统和业务应用有一个合理的备份恢复策略，完美的备份策略可以保证业务的 0 宕机时间和数据的完全恢复。有人说，既然数据备份非常重要，那我把重要数据在硬盘中保存一份，在移动硬盘中也保存一份，再刻录一张光盘，这样数据应该非常安全了吧？</p><p>对个人用户来讲，这样保存数据已经足够了；但是对企业用户来讲，还是有安全隐患的，因为这些数据还是放在同一个地方的。还记得美国的“9·11”事件吗？像美国纽约世贸中心那样的庞然大物也轰然倒塌。当然，相比这样的灾难来讲，数据的损失已经是微不足道的了，不过这仍然说明异地备份的重要性。所以，我们在备份数据的时候，不仅要把数据保存在多个存储介质中，还要考虑把重要数据异地保存。</p><h3 id="2-备份策略">2.备份策略</h3><p>常用的备份策略有完全备份和增量备份，而增量备份有可细分为累计增量备份和差异增量备份。下面来分别讲述不同备份策略以及之间的区别。</p><ul><li><p><strong>完全备份</strong></p><p>完全备份是指把所有需要备份的数据全部备份。当然，完全备份可以备份整块硬盘、整个分区或某个具体的目录。对于 Linux 操作系统来说，完全备份指的就是将根目录下的所有文件进行备份。</p><p>完全备份的好处是，所有数据都进行了备份，系统中任何数据丢失都能恢复，且恢复效率较高。如果完全备份备份的是整块硬盘，那么甚至不需要数据恢复，只要把备份硬盘安装上，服务器就会恢复正常。</p><p>完全备份的缺点也很明显，那就是需要备份的数据量较大，备份时间较长，备份了很多无用数据，占用的空间较大，所以完全备份不可能每天执行。</p><p>我们一般会对关键服务器进行整盘完全备份，如果出现问题，则可以很快地使用备份硬盘进行替换，从而减少损失。我们甚至会对关键服务器搭设一台一模一样的服务器，这样只要远程几个命令（或使用 Shell 脚本自动检测，自动进行服务器替换），备份服务器就会接替原本的服务器，使故障响应时间大大缩短。</p></li><li><p><strong>累计增量备份</strong></p><p>在一个数据量很大的业务应用中，每天对 Linux 系统进行完全备份是不现实的，这就需要用到增量备份策略。</p><p>累计增量备份是指先进行一次完全备份，服务器运行一段时间之后，比较当前系统和完全备份的备份数据之间的差异，只备份有差异的数据。服务器继续运行，再经过一段时间，进行第二次增量备份。在进行第二次增量备份时，当前系统和第一次增量备份的数据进行比较，也是只备份有差异的数据。第三次增量备份是和第二次增量备份的数据进行比较，以此类推。</p><p>因此，累计增量备份就是只备份每天增加或者变化的数据，而不备份系统中没有变动的数据。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Q0291641164c.jpg" alt="累计增量备份"></p><p>假设我们在第一天进行一次完全备份。第二天增量备份时，只会备份第二天和第一天之间的差异数据，但是第二天的总备份数据是完全备份加第一次增量备份的数据。第三天增量备份时，只会备份第三天和第二天之间的差异数据，但是第三天的总备份数据是完全备份加第一次增量备份的数据，再加第二次增量备份的数据。当然，第四天增量备份时，只会备份第四天和第三天的差异数据，但是第四天的总备份数据是完全备份加第一次增量备份的数据，加第二次增量备份的数据，再加第三次增量备份的数据。</p><p>采用累计增量备份的好处是，每次备份需要备份的数据较少，耗时较短，占用的空间较小；坏处是数据恢复比较麻烦，如果图上的例子，那么当进行数据恢复时，就要先恢复完全备份的数据，再依次恢复第一次增量备份的数据、第二次增量备份的数据和第三次增量备份的数据，最终才能恢复所有的数据。</p></li><li><p><strong>差异增量备份</strong></p><p>差异增量备份（后续简称差异备份）也要先进行一次完全备份，但是和累计增量备份不同的是，每次差异备份都备份和原始的完全备份不同的数据。也就是说，差异备份每次备份的参照物都是原始的完全备份，而不是上一次的差异备份。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Q02916415T37.jpg" alt="差异增量备份"></p><p>假设我们在第一天也进行一次完全备份。第二天差异备份时，会备份第二天和第一天之间的差异数据，而第二天的备份数据是完全备份加第一次差异备份的数据。第三天进行差异备份时，仍和第一天的原始数据进行对比，把第二天和第三天所有的数据都备份在第二次差异备份中，第三天的备份数据是完全备份加第二次差异备份的数据。第四天进行差异备份时，仍和第一天的原始数据进行对比，把第二天、第三天和第四天所有的不同数据都备份到第三次差异备份中，第四天的备份数据是完全备份加第三次差异备份的数据。</p><p>相比较而言，差异备份既不像完全备份一样把所有数据都进行备份，也不像增量备份在进行数据恢复时那么麻烦，只要先恢复完全备份的数据，再恢复差异备份的数据即可。不过，随着时间的增加，和完全备份相比，变动的数据越来越多，那么差异备份也可能会变得数据量庞大、备份速度缓慢、占用空间较大。</p></li></ul><h3 id="3-tar命令备份数据">3.tar命令备份数据</h3><p>下面通过 tar 命令做的一个 Web 服务器的备份脚本，详细了解 tar 命令作为备份工具时的具体用法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">BAKDATE=`<span class="built_in">date</span> +%y%m%d`</span><br><span class="line">DATA3=`<span class="built_in">date</span> -d <span class="string">&quot;3 days ago&quot;</span> +%y%m%d`</span><br><span class="line">osdata=/disk1</span><br><span class="line">userdata=/disk2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;backup OS data starting&quot;</span></span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/etc.data/etc_<span class="variable">$BAKDATE</span>.tar.gz /etc</span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/boot.data/boot_<span class="variable">$BAKDATE</span>.tar.gz /boot</span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/home.data/home_<span class="variable">$BAKDATE</span>.tar.gz /home</span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/root.data/root_<span class="variable">$BAKDATE</span>.tar.gz /root</span><br><span class="line">tar -zcvf /<span class="variable">$userdata</span>/usr_data/usrlocal_<span class="variable">$BAKDATE</span>.tar.gz /usr/local</span><br><span class="line">tar -zcvf /<span class="variable">$userdata</span>/var_www/www_<span class="variable">$BAKDATE</span>.tar.gz /var/www</span><br><span class="line"><span class="built_in">cp</span> -r /<span class="variable">$osdata</span>/* /<span class="variable">$userdata</span></span><br><span class="line"><span class="built_in">cp</span> -r /<span class="variable">$userdata</span>/* /<span class="variable">$osdata</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Backup OS data complete!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;delete OS data 3 days ago&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/etc.data/etc_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/boot.data/boot_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/home.data/home_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/root.data/root_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/usr_data/usrlocal_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/var_www/www_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/etc.data/etc_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/boot.data/boot_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/home.data/home_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/root.data/root_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/usr_data/usrlocal_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/var_www/www_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;delete cws ok!&quot;</span></span><br></pre></td></tr></table></figure><p>上面这段脚本完成的工作是，将系统和用户的备份数据分别保存在两个不同的本地磁盘 disk1 和 disk2 中，并且保留最近 3 天的数据，3 天前的数据自动删除。主要备份的数据有 /etc 目录、/boot 目录、/home 目录、/root 目录、/usr/local 目录和 /var/www 目录。当然这里只是举个例子，凡是存放数据的重要目录，都需要进行备份。</p><h2 id="20）工具">20）工具</h2><h3 id="1-VI-VIM-文档编辑器">.1 VI/VIM 文档编辑器</h3><ul><li><p><strong>概念</strong></p><p>VI是Unix操作系统和类Unix操作系统中最通用的文本编辑器</p><p>VIM编辑器是从VI发展出来的一个性能更加强大的文本编辑器。可以主动的以字体颜色辨别语法的正确性，方便程序设计。VIM与VI完全兼容。</p></li><li><p><strong>模式转换</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Snipaste_2022-12-08_19-29-30.png" alt="Snipaste_2022-12-08_19-29-30"></p></li><li><p><strong>一般模式</strong></p><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>yy</td><td>复制光标当前一行</td></tr><tr><td>y数字y</td><td>复制一段（从光标当前行到后n行）（同数字yy）</td></tr><tr><td>p</td><td>箭头移动到目的行黏贴（数字p 复制x次）</td></tr><tr><td>u</td><td>撤销上一步</td></tr><tr><td>dd</td><td>删除光标当前行</td></tr><tr><td>d数字d</td><td>删除光标（含）后多少行</td></tr><tr><td>x</td><td>剪切一个字符（当前光标），相当于del</td></tr><tr><td>X</td><td>剪切一个字符（当前光标的前一个），相当于Backspace</td></tr><tr><td>yw</td><td>复制一个词</td></tr><tr><td>dw</td><td>删除一个词</td></tr><tr><td>shift+6（^）</td><td>移动到行头</td></tr><tr><td>shift+4（$）</td><td>移动到尾</td></tr><tr><td>shift+r</td><td>变为插入模式</td></tr><tr><td>w</td><td>移动到下一个词（词头位置）</td></tr><tr><td>e</td><td>移动到当前词尾</td></tr><tr><td>1+G</td><td>移动到页头，数字</td></tr><tr><td>G</td><td>移动到页尾</td></tr><tr><td>数字N+G</td><td>移动到目标行</td></tr></tbody></table></li><li><p><strong>编辑模式</strong></p><p>按下以下按键时，在画面的左下方会出现【INSERT 或 REPLACE】的字样。回到一般模式按【Esc】。</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td>i</td><td>当前光标前</td></tr><tr><td>a</td><td>当前光标后</td></tr><tr><td>o</td><td>当前光标下一行</td></tr><tr><td>I</td><td>光标所在行最前</td></tr><tr><td>A</td><td>光标所在行最后</td></tr><tr><td>O</td><td>光标所在行的上一行</td></tr></tbody></table></li><li><p>指令模式</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>:w</td><td>保存</td></tr><tr><td>:q</td><td>退出</td></tr><tr><td>:wq</td><td>保存后退出</td></tr><tr><td>:q!</td><td>不保存强制退出</td></tr><tr><td>/要查找的词</td><td>n查找下一个，N往上查找</td></tr><tr><td>:noh</td><td>取消高亮</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>关闭行号</td></tr><tr><td>😒/old/new</td><td>替换当前行匹配到的第一个old为new</td></tr><tr><td>😒/old/new/g</td><td>替换当前行匹配到的所有old为new</td></tr><tr><td>:%s/old/new</td><td>替换文档中每一行匹配到的第一个old为new</td></tr><tr><td>:%s/old/new/g</td><td>替换文档中所有的old为new</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/20190919184602447.png" alt="20190919184602447"></p></li></ul><h3 id="2-wget-下载文件工具">.2 wget 下载文件工具</h3><ul><li><p><strong>介绍</strong></p><p>Linux系统中的 wget 是一个下载文件的工具，它用在命令行下。对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。</p><p>wget 可以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。在递归下载的时候，wget 遵循Robot Exclusion标准(/robots.txt). wget可以在下载的同时，将链接转换成指向本地文件，以方便离线浏览。</p><p>wget 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性.如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p></li><li><p>安装</p><p>默认的yum源不支持直接下载，使用curl更换源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure></li><li><p><strong>语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# wget [options] [URL地址]</span><br></pre></td></tr></table></figure></li><li><p><strong>选项</strong></p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a &lt;日志文件&gt;</td><td>在指定的日志文件中记录资料的执行过程；</td></tr><tr><td>-A &lt;后缀名&gt;</td><td>指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；</td></tr><tr><td>-b</td><td>进行后台的方式运行wget；</td></tr><tr><td>-B &lt;连接地址&gt;</td><td>设置参考的连接地址的基地地址；</td></tr><tr><td>-c</td><td>继续执行上次终端的任务(断点续传)；</td></tr><tr><td>-C &lt;标志&gt;</td><td>设置服务器数据块功能标志on为激活，off为关闭，默认值为on；</td></tr><tr><td>-d</td><td>调试模式运行指令；</td></tr><tr><td>-D &lt;域名列表&gt;</td><td>设置顺着的域名列表，域名之间用“，”分隔；</td></tr><tr><td>-e &lt;指令&gt;</td><td>作为文件“.wgetrc”中的一部分执行指定的指令；</td></tr><tr><td>-h</td><td>显示指令帮助信息；</td></tr><tr><td>-i &lt;文件&gt;</td><td>从指定文件获取要下载的URL地址；</td></tr><tr><td>-l &lt;目录列表&gt;</td><td>设置顺着的目录列表，多个目录用“，”分隔；</td></tr><tr><td>-L</td><td>仅顺着关联的连接；</td></tr><tr><td>-O &lt;新文件名&gt;</td><td><strong>下载并以不同的文件名保存</strong></td></tr><tr><td>-r</td><td>递归下载方式；</td></tr><tr><td>-nc</td><td>文件存在时，下载文件不覆盖原有文件；</td></tr><tr><td>-nv</td><td>下载时只显示更新和出错信息，不显示指令的详细执行过程；</td></tr><tr><td>-q</td><td>不显示指令执行过程；</td></tr><tr><td>-nh</td><td>不查询主机名称；</td></tr><tr><td>-v</td><td>显示详细执行过程；</td></tr><tr><td>-V</td><td>显示版本信息；</td></tr><tr><td><code>--limit-rate=&lt;300k&gt;</code></td><td><strong>限速300k下载</strong></td></tr><tr><td>–passive-ftp</td><td>使用被动模式PASV连接FTP服务器；</td></tr><tr><td>–follow-ftp</td><td>从HTML文件中下载FTP连接文件。</td></tr><tr><td>–user-agent=&lt;请求头&gt;</td><td>伪装代理下载</td></tr></tbody></table></li><li><p><strong>eg.</strong></p><ol><li><p><strong>伪装代理名称下载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --user-agent=<span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot;</span> http://www.coonote.com/testfile.zip</span><br></pre></td></tr></table></figure><p>有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过<code>--user-agent</code>参数伪装。</p></li><li><p><strong>测试下载链接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --spider URL</span><br></pre></td></tr></table></figure><p>如果下载链接正确，将会显示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text/html]</span><br><span class="line">Remote file exists and could contain further links,</span><br><span class="line">but recursion is disabled -- not retrieving.</span><br></pre></td></tr></table></figure><p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget --spider url</span><br><span class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists.</span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found</span><br><span class="line">Remote file does not exist -- broken <span class="built_in">link</span>!!!</span><br></pre></td></tr></table></figure><p>你可以在以下几种情况下使用<code>--spider</code>参数：</p><ul><li><p>定时下载之前进行检查</p></li><li><p>间隔检测网站是否可用</p></li><li><p>检查网站页面的死链接</p></li></ul></li><li><p><strong>增加重试次数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --tries=40 URL</span><br></pre></td></tr></table></figure><p>如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用<code>--tries</code>增加重试次数。</p></li><li><p><strong>下载多个文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -i filelist.txt</span><br></pre></td></tr></table></figure><p>首先，保存一份下载链接文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; filelist.txt</span><br><span class="line">url1</span><br><span class="line">url2</span><br><span class="line">url3</span><br><span class="line">url4</span><br></pre></td></tr></table></figure><p>接着使用这个文件和参数<code>-i</code>下载。</p></li><li><p><strong>镜像网站</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p>下载整个网站到本地。</p><ul><li><code>--miror</code>开户镜像下载。</li><li><code>-p</code>下载所有为了html页面显示正常的文件。</li><li><code>--convert-links</code>下载后，转换成本地的链接。</li><li><code>-P ./LOCAL</code>保存所有文件和目录到本地指定目录。</li></ul><p><strong>过滤指定格式下载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --reject=gif ur</span><br></pre></td></tr></table></figure><p>下载一个网站，但你不希望下载图片，可以使用这条命令。</p><p>1</p></li><li><p><strong>把下载信息存入日志文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -o download.log URL</span><br></pre></td></tr></table></figure><p>不希望下载信息直接显示在终端而是在一个日志文件，可以使用。</p></li><li><p><strong>限制总下载文件大小</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -Q5m -i filelist.txt</span><br></pre></td></tr></table></figure><p>当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</p></li><li><p><strong>下载指定格式文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r -A.pdf url</span><br></pre></td></tr></table></figure><p>可以在以下情况使用该功能：</p><ul><li>下载一个网站的所有图片。</li><li>下载一个网站的所有视频。</li><li>下载一个网站的所有PDF文件。</li></ul></li><li><p><strong>FTP下载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget ftp-url</span><br><span class="line">wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><p>可以使用wget来完成ftp链接的下载。</p><p>使用wget匿名ftp下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget ftp-url</span><br></pre></td></tr></table></figure><p>使用wget用户名和密码认证的ftp下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><p>1</p></li></ol></li></ul><h3 id="3-curl-文件传输工具">.3 curl 文件传输工具</h3><ul><li><p><strong>概述</strong></p><p>该命令设计用于在没有用户交互的情况下工作。</p><p>curl 是一个工具，用于传输来自服务器或者到服务器的数据。「向服务器传输数据或者获取来自服务器的数据」</p><p>可支持的协议有（DICT、FILE、FTP、FTPS、GOPHER、HTTP、HTTPS、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=IMAP&amp;spm=1001.2101.3001.7020">IMAP</a>、IMAPS、LDAP、LDAPS、POP3、POP3S、RTMP、RTSP、SCP、SFTP、SMTP、SMTPS、TELNET和TFTP）。</p><p>curl提供了大量有用的技巧，比如代理支持、用户身份验证、FTP上传、HTTP post、SSL连接、cookie、文件断点续传、Metalink等等。正如你将在下面看到的，这些特性的数量会让您头晕目眩！</p></li></ul><p><strong>一、常用命令</strong></p><p><strong>1.1 发送GET请求</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl URL</span><br><span class="line">curl URL?a=1&amp;b=nihao</span><br></pre></td></tr></table></figure><p><strong>1.2 发送POST请求</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d <span class="string">&#x27;a=1&amp;b=nihao&#x27;</span> URL</span><br></pre></td></tr></table></figure><p><strong>1.3 发送json格式请求：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;abc&quot;:123,&quot;bcd&quot;:&quot;nihao&quot;&#125;&#x27; URL</span><br><span class="line">curl -H &quot;Content-Type: application/json&quot; -X POST -d @test.json URL</span><br></pre></td></tr></table></figure><p>其中，<strong>-H</strong>代表header头，<strong>-X</strong>是指定什么类型请求(POST/GET/HEAD/DELETE/PUT/PATCH)，<strong>-d</strong>代表传输什么数据。这几个是最常用的。</p><p>查看所有curl命令： man curl或者curl -h<br>请求头：H,A,e<br>响应头：I,i,D<br>cookie：b,c,j<br>传输：F(POST),G(GET),T(PUT),X<br>输出：o,O,w<br>断点续传：r<br>调试：v,–trace,–trace-ascii,–trace-time</p><p><strong>二、curl命令语法与curl命令参数详解</strong></p><p><strong>2.1 curl命令语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [options] [URL...]</span><br></pre></td></tr></table></figure><p><strong>2.2 curl命令参数详解</strong></p><p>由于linux curl功能十分强大，所以命令参数十分多，下表只是爱E族(<a target="_blank" rel="noopener" href="http://aiezu.com">aiezu.com</a>)帅选出来的部分参数，更多参数请运行“man curl”命令查看。</p><table><tbody><tr><th>参数组</th><th>参数</th><th>描述</th></tr><tr><th>url</th><td>url</td><td>需要抓取的一到多个URLs；<br>多个下面通配符的方式：<br>　　1、http://{www,ftp,mail}.aiezu.com；<br>　　2、http://aiezu.com/images/[001-999].jpg；<br>　　3、http://aiezu.com/images/[1-999].html；<br>　　4、ftp://aiezu.com/file[a-z].txt</td></tr><tr><th colspan="1" rowspan="4">请<br>求<br>头</th><td>-H "name: value"<br>--header "name: value"</td><td>(HTTP)添加一个http header(http请求头)；</td></tr><tr><td>-H "name:"<br>--header "name:"</td><td>(HTTP)移除一个http header(http请求头)；</td></tr><tr><td>-A "string"<br>--user-agent "string"<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_referer_useragent.html" title="【参考】">【参考】</a></td><td>(HTTP)设置Http请求头“User-Agent”，服务器通过“User-Agent”可以判断客户端使用的浏览器名称和操作系统类型，伪造此参数能导致服务器做出错误判断。<br>也可以使用“-H”, “--header option”设置此选项；</td></tr><tr><td>-e&nbsp;&lt;URL&gt;<br>--referer &lt;URL&gt;<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_referer_useragent.html" title="【参考】">【参考】</a></td><td>(HTTP)设置访问时的来源页面，告诉http服务从哪个页面进入到此页面；<br>-e "aiezu.com"相当于“-H "Referer: www.qq.com"”；</td></tr><tr><th colspan="1" rowspan="3">响<br>应<br>头</th><td>-I<br>--head</td><td>(HTTP)只输出HTTP-header，不获取内容(HTTP/FTP/FILE)。<br>用于HTTP服务时，获取页面的http头；<br>&nbsp; （如：curl -I http://aiezu.com）<br>用于FTP/FILE时，将会获取文件大小、最后修改时间；<br>&nbsp; （如：curl -I file://test.txt）</td></tr><tr><td>-i<br>--include</td><td>(HTTP)输出HTTP头和返回内容；</td></tr><tr><td>-D&nbsp;&lt;file&gt;<br>--dump-header &lt;file&gt;</td><td>(HTTP)转储http响应头到指定文件；</td></tr><tr><th colspan="1" rowspan="3">cookie</th><td>-b name=data<br>--cookie name=data<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_http_cookie.html" title="【参考】">【参考】</a></td><td>(HTTP)发送cookie数据到HTTP服务器，数据格式为："NAME1=VALUE1; NAME2=VALUE2"；<br><br>如果行中没有“=”，将把参数值当作cookie文件名；<br><br>这个cookie数据可以是由服务器的http响应头“Set-Cookie:”行发送过来的；</td></tr><tr><td>-c filename<br>--cookie-jar file name<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_http_cookie.html" title="【参考】">【参考】</a></td><td>(HTTP)完成操作后将服务器返回的cookies保存到指定的文件；<br>指定参数值为“-”将定向到标准输出“如控制台”；</td></tr><tr><td>-j<br>--junk-session-cookies</td><td>(HTTP)告诉curl放弃所有的"session cookies"；<br>相当于重启浏览器；</td></tr><tr><th colspan="1" rowspan="5">代理</th><td>-x host:port<br>-x [protocol://[user:pwd@]host[:port]<br>--proxy [protocol://[user:pwd@]host[:port]<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_proxy_http_socks.html" title="【参考】">【参考】</a></td><td>使用HTTP代理访问；如果未指定端口，默认使用8080端口;<br>protocol默认为http_proxy，其他可能的值包括：<br>http_proxy、HTTPS_PROXY、socks4、socks4a、socks5；<br>如：<br>--proxy 8.8.8.8:8080；<br>-x "http_proxy://aiezu:123@aiezu.com:80"</td></tr><tr><td>-p<br>--proxytunnel</td><td>将“-x”参数的代理，作为通道的方式去代理非HTTP协议，如ftp；</td></tr><tr><td>--socks4 &lt;host[:port]&gt;<br>--socks4a &lt;host[:port]&gt;<br>--socks5 &lt;host[:port]&gt;<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_proxy_http_socks.html" title="【参考】">【参考】</a></td><td>使用SOCKS4代理；<br>使用SOCKS4A代理；<br>使用SOCKS5代理；<br>此参数会覆盖“-x”参数；</td></tr><tr><td>--proxy-anyauth<br>--proxy-basic<br>--proxy-diges<br>--proxy-negotiate<br>--proxy-ntlm</td><td>http代理认证方式，参考：<br>--anyauth<br>--basic<br>--diges<br>--negotiate<br>--ntlm</td></tr><tr><td>-U&nbsp;&lt;user:password&gt;<br>--proxy-user &lt;user:password&gt;</td><td>设置代理的用户名和密码；</td></tr><tr><th colspan="1" rowspan="5">数据<br>传输</th><td>-G<br>--get<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_getpost_datafile_json.html" title="【参考】">【参考】</a></td><td>如果使用了此参数，“-d/”、“--data”、“--data-binary”参数设置的数据，讲附加在url上，以GET的方式请求；&nbsp;</td></tr><tr><td>-d @file<br>-d "string"<br>--data "string"<br>--data-ascii "string"<br>--data-binary "string"<br>--data-urlencode "string"<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_getpost_datafile_json.html" title="【参考】">【参考】</a></td><td>(HTTP)使用HTTP POST方式发送“key/value对”数据，相当于浏览器表单属性（method="POST"，enctype="application/x-www-form-urlencoded"）<br>　　-d，--data：HTTP方式POST数据；<br>　　--data-ascii：HTTP方式POST ascii数据；<br>　　--data-binary：HTTP方式POST二进制数据；<br>　　--data-urlencode：HTTP方式POST数据（进行urlencode）；<br>如果数据以“@”开头，后紧跟一个文件，将post文件内的内容；</td></tr><tr><td>-F name=@file<br>-F name=&lt;file<br>-F name=content<br>--form name=content<br><a target="_blank" rel="noopener" href="http://aiezu.com/article/linux_curl_getpost_datafile_json.html" title="【参考】">【参考】</a></td><td>(HTTP)使用HTTP POST方式发送类似“表单字段”的多类型数据，相当于同时设置浏览器表单属性（method="POST"，enctype="multipart/form-data"），可以使用此参数上传二进制文件。<br><br>如果字段内容以“@”开头，剩下的部分应该是文件名，curl将会上传此文件，如：<br>curl -F "pic=@pic.jpg" http://aiezu.com；<br>curl -F "page=@a.html;type=text/html" http://aiezu.com<br>curl -F "page=@/tmp/a;filename=a.txt" http://aiezu.com<br><br>如果字段内容以“&lt;”开头，剩下的部分应该是文件名，curl将从文件中获取作为此字段的值，如：curl -F "text=&lt;text.txt" http://aiezu.com；</td></tr><tr><td>--form-string &lt;key=value&gt;</td><td>(HTTP)类似于“--form”，但是“@”、“&lt;”无特殊含义；</td></tr><tr><td>-T file<br>--upload-file file</td><td>通过“put”的方式将文件传输到远程网址；<br><br>选项参数只使用字符"-"，将通过stdin读入文件内容；<br>如：<br>cat test.txt|curl "http://aiezu.com/a.php" -T -&nbsp;<br>curl "http://aiezu.com/a.php" -T - &lt;test.txt<br><br>此参数也可以使用通配符：<br>curl -T "{file1,file2}" http://aiezu.com<br>curl -T "img[1-1000].png" http://aiezu.com</td></tr><tr><th colspan="1" rowspan="2">断点<br>续传</th><td>-C&nbsp;&lt;offset&gt;<br>--continue-at&nbsp;&lt;offset&gt;</td><td>断点续转，从文件头的指定位置开始继续下载/上传；<br>offset续传开始的位置，如果offset值为“-”，curl会自动从文件中识别起始位置开始传输；</td></tr><tr><td>-r&nbsp;&lt;range&gt;<br>--range &lt;range&gt;</td><td>(HTTP/FTP/SFTP/FILE) 只传输内容的指定部分：<br>0-499：最前面500字节；<br>-500：最后面500字节；<br>9500-：最前面9500字节；<br>0-0,-1：最前面和最后面的1字节；<br>100-199,500-599：两个100字节；</td></tr><tr><th colspan="1" rowspan="6"><br><br><br>认证</th><td>--basic</td><td>(HTTP)告诉curl使用HTTP Basic authentication（HTTP协议时），这是默认认证方式；</td></tr><tr><td>--ntlm</td><td>(HTTP)使用NTLM身份验证方式，用于HTTP协议；<br>一般用于IIS使用NTLM的网站；</td></tr><tr><td>--digest</td><td>(HTTP)使用HTTP Digest authentication加密，用于HTTP协议；<br>配合“-u/--user”选项，防止密码使用明文方式发送；</td></tr><tr><td>--negotiate</td><td>(HTTP)使用GSS-Negotiate authentication方式，用于HTTP协议；<br>它主要目的是为它的主要目的是为kerberos5认证提供支持支持；</td></tr><tr><td>--anyauth</td><td>(HTTP)告诉curl自动选择合适的身份认证方法，并选用最安全的方式；</td></tr><tr><td>-u user:password<br>--user user:password</td><td>使用用户名、密码认证，此参数会覆盖“-n”、“--netrc”和“--netrc-optional”选项；<br><br>如果你只提供用户名，curl将要求你输入密码；<br><br>如果你使用“SSPI”开启的curl库做“NTLM”认证，可以使用不含用户名密码的“-u:”选项，强制curl使用当前登录的用户名密码进行认证；<br><br>此参数相当于设置http头“Authorization：”；</td></tr><tr><th colspan="1" rowspan="6">证书</th><td>-E&nbsp;&lt;证书[:密码]&gt;<br>--cert&nbsp;&lt;证书[:密码]&gt;</td><td>(SSL)指定“PEM”格式的证书文件和证书密码；</td></tr><tr><td>--cert-type &lt;type&gt;</td><td>(SSL)告诉curl所提供证书的类型：PEM、DER、ENG等；<br>默认为“PEM”；</td></tr><tr><td>--cacert &lt;CA证书&gt;</td><td>(SSL)告诉curl所以指定的CA证书文件，必须是“PEM”格式；</td></tr><tr><td>--capath &lt;CA证书路径&gt;</td><td>(SSL)告诉curl所以指定目录下的CA证书用来验证；<br>这些证书必须是“PEM”格式；</td></tr><tr><td>--crlfile &lt;file&gt;</td><td>(HTTPS/FTPS)提供一个PEM格式的文件，用于指定被吊销的证书列表；</td></tr><tr><td>-k<br>--insecure</td><td>(SSL)设置此选项将允许使用无证书的不安全SSL进行连接和传输。</td></tr><tr><th colspan="1" rowspan="5">SSL<br>其他</th><td>--ciphers &lt;list of ciphers&gt;</td><td>(SSL)指定SSL要使用的加密方式；如：“aes_256_sha_256”；</td></tr><tr><td>--engine &lt;name&gt;</td><td>设置一个OpenSSL加密引擎用于加密操作；<br>使用“curl --engine list”查看支持的加密引擎列表；</td></tr><tr><td>--random-file</td><td>(SSL)指定包含随机数据的文件路径名；数据是用来为SSL连接产生随机种子为；</td></tr><tr><td>--egd-file&nbsp;&lt;file&gt;</td><td>(SSL)为随机种子生成器EGD(Entropy Gathering Daemon socket)指定的路径名；</td></tr><tr><td>-1/--tlsv1<br>--tlsv1.0<br>--tlsv1.1<br>--tlsv1.2<br>-2/--sslv2<br>-3/--sslv3</td><td>(SSL)使用TLS版本2与远程服务器通讯；<br>(SSL)使用TLS 1.0版本与远程服务器通讯；<br>(SSL)使用TLS 1.1版本与远程服务器通讯；<br>(SSL)使用TLS 1.2版本与远程服务器通讯；<br>(SSL)使用SSL版本2与远程服务器通讯；<br>(SSL)使用SSL版本3与远程服务器通讯；</td></tr><tr><th colspan="1" rowspan="4">私钥<br>公钥</th><td>--key &lt;key&gt;</td><td>(SSL/SSH)指定一个私钥文件名；为指定时自动尝试使用下面文件：“~/.ssh/id_rsa”、“~/.ssh/id_dsa”、“./id_rsa'”、 “./id_dsa”；</td></tr><tr><td>--key-type &lt;type&gt;</td><td>(SSL)指定私钥文件类型，支持：DER、PEM、ENG，默认是PEM；</td></tr><tr><td>--pass&nbsp;&lt;phrase&gt;</td><td>(SSL/SSH)指定私钥文件的密码；</td></tr><tr><td>--pubkey &lt;key&gt;</td><td>(SSH)使用指定文件提供的您公钥；</td></tr><tr><th colspan="1" rowspan="11">FTP</th><td>-P<br>--ftp-port &lt;接口&gt;</td><td>(FTP)FTP主动模式时，设置一个地址等待服务器的连接，如：<br>网卡：eth1<br>IP：8.8.8.8<br>主机名：aiezu.com<br>可以加端口号：eth1:20000-21000;</td></tr><tr><td>--crlf</td><td>(FTP)上传时将换行符(LF)转换为回车换行(CRLF)；</td></tr><tr><td>--ftp-account [data]</td><td>(FTP)ftp帐号信息；</td></tr><tr><td>--ftp-method [method]</td><td>(FTP)可选值：multicwd/nocwd/singlecwd；</td></tr><tr><td>--ftp-pasv</td><td>(FTP)使用使用PASV(被动)/EPSV模式；</td></tr><tr><td>--ftp-skip-pasv-ip</td><td>(FTP)使用PASV的时,跳过指定IP；</td></tr><tr><td>--ftp-create-dirs</td><td>(FTP)上传时自动创建远程目录；</td></tr><tr><td>-l<br>--list-only</td><td>(FTP)列出ftp文件列表；</td></tr><tr><td>-B<br>--use-ascii</td><td>(FTP/LDAP)使用Ascii传输模式，用于FTP、LDAP；在ftp中相当与使用了“type=A;”模式。</td></tr><tr><td>--disable-epsv</td><td>(FTP)告诉curl在PASV(被动模式)时不要使用EPSV；</td></tr><tr><td>--disable-eprt</td><td>(FTP)告诉curl在主动模式时禁用EPRT和LPRT；</td></tr><tr><th colspan="1" rowspan="3">限速</th><td>--limit-rate&nbsp;&lt;speed&gt;</td><td>限制curl使用的最大带宽；如果未指定单位，默认单位为“bytes/秒”，你也可以指定单位为“K”、“M”、“G”等单位，如：“--limit-rate 1m”为限制最大使用带宽为“1m字节/秒”；</td></tr><tr><td>-y<br>--speed-time &lt;time&gt;</td><td>If a download is slower than speed-limit bytes per second during a speed-time period, the download gets aborted. If speed-time is used, the default speed-limit will be 1 unless set with -Y.<br>This option controls transfers and thus will not affect slow connects etc. If this is a concern for you, try the&nbsp;--connect-timeout&nbsp;option.</td></tr><tr><td>-Y<br>--speed-limit &lt;speed&gt;</td><td>If a download is slower than this given speed (in bytes per second) for speed-time seconds it gets aborted. speed-time is set with -y and is 30 if not set.</td></tr><tr><th colspan="1" rowspan="14">其他<br>选项</th><td>-0/--http1.0</td><td>(HTTP) 强制curl使用HTTP 1.0而不是使用默认的HTTP 1.1；</td></tr><tr><td>--interface &lt;name&gt;</td><td>使用指定的网卡接口访问；<br>curl --interface eth0 http://aiezu.com<br>curl --interface 10.0.0.101 http://aiezu.com</td></tr><tr><td>-X&nbsp;&lt;command&gt;<br>--request &lt;command&gt;</td><td>（HTTP）指定与服务器通信使用的请求方法，如：GET、PUT、POST、DELETE等，默认GET；</td></tr><tr><td>--keepalive-time &lt;seconds&gt;</td><td>设置keepalive时间</td></tr><tr><td>--no-keepalive</td><td>关闭keepalive功能；</td></tr><tr><td>--no-buffer</td><td>禁用对输出流缓冲；</td></tr><tr><td>--buffer</td><td>启用输出流缓冲；</td></tr><tr><td>-L<br>--location</td><td>(HTTP/HTTPS)追随http响应头“Location：”定向到跳转后的页面；<br>(在http响应码为3XX时使用，如301跳转、302跳转)</td></tr><tr><td>--location-trusted</td><td>(HTTP/HTTPS)同“--location”，但跳转后会发送跳转前的用户名和密码；</td></tr><tr><td>--compressed</td><td>(HTTP)请求对返回内容使用压缩算法进行压缩；curl支持对gzip压缩进行解压；</td></tr><tr><td>--connect-timeout &lt;seconds&gt;</td><td>指定最大连接超时，单位“秒”；</td></tr><tr><td>-m seconds<br>--max-time seconds</td><td>限制整个curl操作的最长时间，单位为秒；</td></tr><tr><td>-s<br>--silent</td><td>安静模式。不要显示进度表或错误消息；</td></tr><tr><td>-#<br>--progress-bar</td><td>显示进度条；</td></tr><tr><th colspan="1" rowspan="4">错误<br>选项</th><td>-f<br>--fail</td><td>(HTTP)连接失败时（400以上错误）不返回默认错误页面，而是返回一个curl错误码“22”；</td></tr><tr><td>--retry &lt;num&gt;<br>--retry-delay &lt;seconds&gt;<br>--retry-max-time&nbsp;&lt;seconds&gt;</td><td>失败重试次数；<br>重试间隔时间；<br>最大重试时间；</td></tr><tr><td>-S<br>--show-error</td><td>安静模式下显示错误信息；</td></tr><tr><td>--stderr &lt;file&gt;</td><td>错误信息保存文件；</td></tr><tr><th colspan="1" rowspan="4">输出</th><td>-o file<br>--output file</td><td>将返回内容输出到文件。<br>如果是用过通配符获取多个url，可以使用“#”后跟“数字序号”，curl会自动将它替换对应的关键词，如：<br>　　curl "http://aiezu.com/{a,b}.txt" -o "#1.txt";<br>　　将保存为：“a.txt”,“b.txt”;<br><br>　　curl "http://aiezu.com/{a,b}_[1-3].txt" -o "#1#2.txt";<br>　　将保存为：a1.txt、a2.txt、a3.txt、b1.txt、b2.txt、b3.txt<br><br>　　如果要根据规则创建保存目录，参考：“--create-dirs”<br><br>指定“-”将定向到标准输出“如控制台”；&nbsp;</td></tr><tr><td>-O<br>--remote-name</td><td>将返回内容输出到当前目录下，和url中文件名相同的文件中（不含目录）；</td></tr><tr><td>--create-dirs</td><td>与“-o”参数配合使用，创建必要的本地目录层次结构</td></tr><tr><td>-w<br>--write-out format</td><td>操作完成后在返回信息尾部追加指定的内容；要追加的内容可以是一个字符串“string”、从文件中获取“@filename”、从标准输入中获取“@-”<br><br>格式参数中可以用%{variable_name} 方式使用响应信息的相关变量，如：%{content_type}、%{http_code}、%{local_ip}...，更多变量参考“man curl”获取；<br><br>格式参数可以使用“\n”、“\r”、“\t”等转义字符；</td></tr><tr><th colspan="1" rowspan="5">调试</th><td>--trace &lt;file&gt;</td><td>转储所有传入和传出的数据到文件，包括描述信息；<br>使用“-”作为文件名将输出发送到标准输出。</td></tr><tr><td>--trace-ascii file</td><td>转储所有传入和传出的数据到文件，包括描述信息，只转储ASCII部分，更容易阅读；<br>使用“-”作为文件名将输出发送到标准输出。<br>这个选项会覆盖之前使用的-v、 --verbose、 --trace-ascii选项；</td></tr><tr><td>--trace-time</td><td>转储文件中添加时间信息；</td></tr><tr><td>-K<br>--config &lt;config file&gt;</td><td>从配置文件中读取参数，参考：http://curl.haxx.se/docs/</td></tr><tr><td>-v<br>--verbose</td><td>显示更详细的信息，调试时使用；</td></tr><tr><th colspan="1" rowspan="2">帮助</th><td>-M<br>--manual</td><td>显示完整的帮助手册；</td></tr><tr><td>-h<br>--help</td><td>linux curl用法帮助；</td></tr></tbody></table><p>curl -h 的完整参数解释：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><code>-a/--append</code></td><td>上传文件时，附加到目标文件</td></tr><tr><td><code>--anyauth</code></td><td>可以使用“任何”身份验证方法</td></tr><tr><td><code>--basic</code></td><td>使用HTTP基本验证</td></tr><tr><td><code>-B/--use-ascii</code></td><td>使用ASCII文本传输</td></tr><tr><td><code>-d/--data &lt;data&gt;</code></td><td>HTTP POST方式传送数据</td></tr><tr><td><code>--data-ascii &lt;data&gt;</code></td><td>以ascii的方式post数据</td></tr><tr><td><code>--data-binary &lt;data&gt;</code></td><td>以二进制的方式post数据</td></tr><tr><td>–negotiate</td><td>使用HTTP身份验证</td></tr><tr><td>–digest</td><td>使用数字身份验证</td></tr><tr><td>–disable-eprt</td><td>禁止使用EPRT或LPRT</td></tr><tr><td>–disable-epsv</td><td>禁止使用EPSV</td></tr><tr><td><code>--egd-file &lt;file&gt;</code></td><td>为随机数据(SSL)设置EGD socket路径</td></tr><tr><td><code>--tcp-nodelay</code></td><td>使用TCP_NODELAY选项</td></tr><tr><td><code>-E/--cert &lt;cert[:passwd]</code>&gt;</td><td>客户端证书文件和密码 (SSL)</td></tr><tr><td><code>--cert-type &lt;type&gt;</code></td><td>证书文件类型 (DER/PEM/ENG) (SSL)</td></tr><tr><td><code>--key &lt;key&gt;</code></td><td>私钥文件名 (SSL)</td></tr><tr><td><code>--key-type &lt;type&gt;</code></td><td>私钥文件类型 (DER/PEM/ENG) (SSL)</td></tr><tr><td><code>--pass &lt;pass&gt;</code></td><td>私钥密码 (SSL)</td></tr><tr><td><code>--engine &lt;eng&gt;</code></td><td>加密引擎使用 (SSL). “–engine list” for list</td></tr><tr><td><code>--cacert &lt;file&gt;</code></td><td>CA证书 (SSL)</td></tr><tr><td><code>--capath &lt;directory&gt;</code></td><td>CA目 (made using c_rehash) to verify peer against (SSL)</td></tr><tr><td><code>--ciphers &lt;list&gt;</code></td><td>SSL密码</td></tr><tr><td>–compressed</td><td>要求返回是压缩的形势 (using deflate or gzip)</td></tr><tr><td><code>--connect-timeout &lt;seconds&gt;</code></td><td>设置最大请求时间</td></tr><tr><td>–create-dirs</td><td>建立本地目录的目录层次结构</td></tr><tr><td>–crlf</td><td>上传是把LF转变成CRLF</td></tr><tr><td>–ftp-create-dirs</td><td>如果远程目录不存在，创建远程目录</td></tr><tr><td><code>--ftp-method [multicwd/nocwd/singlecwd]</code></td><td>控制CWD的使用</td></tr><tr><td>–ftp-pasv</td><td>使用 PASV/EPSV 代替端口</td></tr><tr><td>–ftp-skip-pasv-ip</td><td>使用PASV的时候,忽略该IP地址</td></tr><tr><td>–ftp-ssl</td><td>尝试用 SSL/TLS 来进行ftp数据传输</td></tr><tr><td>–ftp-ssl-reqd</td><td>要求用 SSL/TLS 来进行ftp数据传输</td></tr><tr><td><code>-F/--form &lt;name=content&gt;</code></td><td>模拟http表单提交数据</td></tr><tr><td><code>-form-string &lt;name=string&gt;</code></td><td>模拟http表单提交数据</td></tr><tr><td>-g/–globoff</td><td>禁用网址序列和范围使用{}和[]</td></tr><tr><td>-G/–get</td><td>以get的方式来发送数据</td></tr><tr><td>-h/–help</td><td>帮助</td></tr><tr><td><code>-H/--header &lt;line&gt;</code></td><td>自定义头信息传递给服务器</td></tr><tr><td>–ignore-content-length</td><td>忽略的HTTP头信息的长度</td></tr><tr><td>-i/–include</td><td>输出时包括protocol头信息</td></tr><tr><td>-I/–head</td><td>只显示文档信息</td></tr><tr><td>-j/–junk-session-cookies</td><td>读取文件时忽略session cookie</td></tr><tr><td><code>--interface &lt;interface&gt;</code></td><td>使用指定网络接口/地址</td></tr><tr><td><code>--krb4 &lt;level&gt;</code></td><td>使用指定安全级别的krb4</td></tr><tr><td>-k/–insecure</td><td>允许不使用证书到SSL站点</td></tr><tr><td>-K/–config</td><td>指定的配置文件读取</td></tr><tr><td>-l/–list-only</td><td>列出ftp目录下的文件名称</td></tr><tr><td><code>--limit-rate &lt;rate&gt;</code></td><td>设置传输速度</td></tr><tr><td>–local-port<num></num></td><td>强制使用本地端口号</td></tr><tr><td><code>-m/--max-time &lt;seconds&gt;</code></td><td>设置最大传输时间</td></tr><tr><td><code>--max-redirs &lt;num&gt;</code></td><td>设置最大读取的目录数</td></tr><tr><td><code>--max-filesize &lt;bytes&gt;</code></td><td>设置最大下载的文件总量</td></tr><tr><td>-M/–manual</td><td>显示全手动</td></tr><tr><td>-n/–netrc</td><td>从netrc文件中读取用户名和密码</td></tr><tr><td>–netrc-optional</td><td>使用 .netrc 或者 URL来覆盖-n</td></tr><tr><td>–ntlm</td><td>使用 HTTP NTLM 身份验证</td></tr><tr><td>-N/–no-buffer</td><td>禁用缓冲输出</td></tr><tr><td>-p/–proxytunnel</td><td>使用HTTP代理</td></tr><tr><td>–proxy-anyauth</td><td>选择任一代理身份验证方法</td></tr><tr><td>–proxy-basic</td><td>在代理上使用基本身份验证</td></tr><tr><td>–proxy-digest</td><td>在代理上使用数字身份验证</td></tr><tr><td>–proxy-ntlm</td><td>在代理上使用ntlm身份验证</td></tr><tr><td><code>-P/--ftp-port &lt;address&gt;</code></td><td>使用端口地址，而不是使用PASV</td></tr><tr><td><code>-Q/--quote &lt;cmd&gt;</code></td><td>文件传输前，发送命令到服务器</td></tr><tr><td>–range-file</td><td>读取（SSL）的随机文件</td></tr><tr><td>-R/–remote-time</td><td>在本地生成文件时，保留远程文件时间</td></tr><tr><td><code>--retry &lt;num&gt;</code></td><td>传输出现问题时，重试的次数</td></tr><tr><td><code>--retry-delay &lt;seconds&gt;</code></td><td>传输出现问题时，设置重试间隔时间</td></tr><tr><td><code>--retry-max-time &lt;seconds&gt;</code></td><td>传输出现问题时，设置最大重试时间</td></tr><tr><td>-S/–show-error</td><td>显示错误</td></tr><tr><td><code>--socks4 &lt;host[:port]&gt;</code></td><td>用socks4代理给定主机和端口</td></tr><tr><td><code>--socks5 &lt;host[:port]&gt;</code></td><td>用socks5代理给定主机和端口</td></tr><tr><td><code>-t/--telnet-option &lt;OPT=val&gt;</code></td><td>Telnet选项设置</td></tr><tr><td><code>--trace &lt;file&gt;</code></td><td>对指定文件进行debug</td></tr><tr><td><code>--trace-ascii &lt;file&gt;</code></td><td>Like --跟踪但没有hex输出</td></tr><tr><td><code>--trace-time</code></td><td>跟踪/详细输出时，添加时间戳</td></tr><tr><td><code>--url &lt;URL&gt;</code></td><td>Spet URL to work with</td></tr><tr><td><code>-U/--proxy-user &lt;user[:password]&gt;</code></td><td>设置代理用户名和密码</td></tr><tr><td>-V/–version</td><td>显示版本信息</td></tr><tr><td><code>-X/--request &lt;command&gt;</code></td><td>指定什么命令</td></tr><tr><td>-y/–speed-time</td><td>放弃限速所要的时间。默认为30</td></tr><tr><td>-Y/–speed-limit</td><td>停止传输速度的限制，速度时间’秒</td></tr><tr><td>-z/–time-cond</td><td>传送时间设置</td></tr><tr><td>-0/–http1.0</td><td>使用HTTP 1.0</td></tr><tr><td>-1/–tlsv1</td><td>使用TLSv1（SSL）</td></tr><tr><td>-2/–sslv2</td><td>使用SSLv2的（SSL）</td></tr><tr><td>-3/–sslv3</td><td>使用的SSLv3（SSL）</td></tr><tr><td>–3p-quote</td><td>like -Q for the source URL for 3rd party transfer</td></tr><tr><td>–3p-url</td><td>使用url，进行第三方传送</td></tr><tr><td>–3p-user</td><td>使用用户名和密码，进行第三方传送</td></tr><tr><td>-4/–ipv4</td><td>使用IP4</td></tr><tr><td>-6/–ipv6</td><td>使用IP6</td></tr></tbody></table><p>三、curl命令退出码</p><p>下面是linux curl命令的错误代码和她们的相应的错误消息，可能会出现在恶劣的环境。</p><table><thead><tr><th style="text-align:left">退出码</th><th style="text-align:left">错误描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">Unsupported protocol. This build of curl has no support for this protocol.</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Failed to initialize.</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">URL malformed. The syntax was not correct.</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">Couldn’t resolve proxy. The given proxy host could not be resolved.</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">Couldn’t resolve host. The given remote host was not resolved.</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">Failed to connect to host.</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">FTP weird server reply. The server sent data curl couldn’t parse.</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">FTP access denied. The server denied login or denied access to the particular resource or directory you wanted to reach. Most often you tried to change to a directory that doesn’t exist on the server.</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">FTP weird PASS reply. Curl couldn’t parse the reply sent to the PASS request.</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">FTP weird PASV reply, Curl couldn’t parse the reply sent to the PASV request.</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">FTP weird 227 format. Curl couldn’t parse the 227-line the server sent.</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">FTP can’t get host. Couldn’t resolve the host IP we got in the 227-line.</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">FTP couldn’t set binary. Couldn’t change transfer method to binary.</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">Partial file. Only a part of the file was transferred.</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left">FTP couldn’t download/access the given file, the RETR (or similar) command failed.</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left">FTP quote error. A quote command returned error from the server.</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left">HTTP page not retrieved. The requested url was not found or returned another error with the HTTP error code being 400 or above. This return code only appears if -f/–fail is used.</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left">Write error. Curl couldn’t write data to a local filesystem or similar.</td></tr><tr><td style="text-align:left">25</td><td style="text-align:left">FTP couldn’t STOR file. The server denied the STOR operation, used for FTP uploading.</td></tr><tr><td style="text-align:left">26</td><td style="text-align:left">Read error. Various reading problems.</td></tr><tr><td style="text-align:left">27</td><td style="text-align:left">Out of memory. A memory allocation request failed.</td></tr><tr><td style="text-align:left">28</td><td style="text-align:left">Operation timeout. The specified time-out period was reached according to the conditions.</td></tr><tr><td style="text-align:left">30</td><td style="text-align:left">FTP PORT failed. The PORT command failed. Not all FTP servers support the PORT command, try doing a transfer using PASV instead!</td></tr><tr><td style="text-align:left">31</td><td style="text-align:left">FTP couldn’t use REST. The REST command failed. This command is used for resumed FTP transfers.</td></tr><tr><td style="text-align:left">33</td><td style="text-align:left">HTTP range error. The range “command” didn’t work.</td></tr><tr><td style="text-align:left">34</td><td style="text-align:left">HTTP post error. Internal post-request generation error.</td></tr><tr><td style="text-align:left">35</td><td style="text-align:left">SSL connect error. The SSL handshaking failed.</td></tr><tr><td style="text-align:left">36</td><td style="text-align:left">FTP bad download resume. Couldn’t continue an earlier aborted download.</td></tr><tr><td style="text-align:left">37</td><td style="text-align:left">FILE couldn’t read file. Failed to open the file. Permissions?</td></tr><tr><td style="text-align:left">38</td><td style="text-align:left">LDAP cannot bind. LDAP bind operation failed.</td></tr><tr><td style="text-align:left">39</td><td style="text-align:left">LDAP search failed.</td></tr><tr><td style="text-align:left">41</td><td style="text-align:left">Function not found. A required LDAP function was not found.</td></tr><tr><td style="text-align:left">42</td><td style="text-align:left">Aborted by callback. An application told curl to abort the operation.</td></tr><tr><td style="text-align:left">43</td><td style="text-align:left">Internal error. A function was called with a bad parameter.</td></tr><tr><td style="text-align:left">45</td><td style="text-align:left">Interface error. A specified outgoing interface could not be used.</td></tr><tr><td style="text-align:left">47</td><td style="text-align:left">Too many redirects. When following redirects, curl hit the maximum amount.</td></tr><tr><td style="text-align:left">48</td><td style="text-align:left">Unknown TELNET option specified.</td></tr><tr><td style="text-align:left">49</td><td style="text-align:left">Malformed telnet option.</td></tr><tr><td style="text-align:left">51</td><td style="text-align:left">The peer’s SSL certificate or SSH MD5 fingerprint was not ok.</td></tr><tr><td style="text-align:left">52</td><td style="text-align:left">The server didn’t reply anything, which here is considered an error.</td></tr><tr><td style="text-align:left">53</td><td style="text-align:left">SSL crypto engine not found.</td></tr><tr><td style="text-align:left">54</td><td style="text-align:left">Cannot set SSL crypto engine as default.</td></tr><tr><td style="text-align:left">55</td><td style="text-align:left">Failed sending network data.</td></tr><tr><td style="text-align:left">56</td><td style="text-align:left">Failure in receiving network data.</td></tr><tr><td style="text-align:left">58</td><td style="text-align:left">Problem with the local certificate.</td></tr><tr><td style="text-align:left">59</td><td style="text-align:left">Couldn’t use specified SSL cipher.</td></tr><tr><td style="text-align:left">60</td><td style="text-align:left">Peer certificate cannot be authenticated with known CA certificates.</td></tr><tr><td style="text-align:left">61</td><td style="text-align:left">Unrecognized transfer encoding.</td></tr><tr><td style="text-align:left">62</td><td style="text-align:left">Invalid LDAP URL.</td></tr><tr><td style="text-align:left">63</td><td style="text-align:left">Maximum file size exceeded.</td></tr><tr><td style="text-align:left">64</td><td style="text-align:left">Requested FTP SSL level failed.</td></tr><tr><td style="text-align:left">65</td><td style="text-align:left">Sending the data requires a rewind that failed.</td></tr><tr><td style="text-align:left">66</td><td style="text-align:left">Failed to initialize SSL Engine.</td></tr><tr><td style="text-align:left">67</td><td style="text-align:left">The user name, password, or similar was not accepted and curl failed to log in.</td></tr><tr><td style="text-align:left">68</td><td style="text-align:left">File not found on TFTP server.</td></tr><tr><td style="text-align:left">69</td><td style="text-align:left">Permission problem on TFTP server.</td></tr><tr><td style="text-align:left">70</td><td style="text-align:left">Out of disk space on TFTP server.</td></tr><tr><td style="text-align:left">71</td><td style="text-align:left">Illegal TFTP operation.</td></tr><tr><td style="text-align:left">72</td><td style="text-align:left">Unknown TFTP transfer ID.</td></tr><tr><td style="text-align:left">73</td><td style="text-align:left">File already exists (TFTP).</td></tr><tr><td style="text-align:left">74</td><td style="text-align:left">No such user (TFTP).</td></tr><tr><td style="text-align:left">75</td><td style="text-align:left">Character conversion failed.</td></tr><tr><td style="text-align:left">76</td><td style="text-align:left">Character conversion functions required.</td></tr><tr><td style="text-align:left">77</td><td style="text-align:left">Problem with reading the SSL CA cert (path? access rights?).</td></tr><tr><td style="text-align:left">78</td><td style="text-align:left">The resource referenced in the URL does not exist.</td></tr><tr><td style="text-align:left">79</td><td style="text-align:left">An unspecified error occurred during the SSH session.</td></tr><tr><td style="text-align:left">80</td><td style="text-align:left">Failed to shut down the SSL connection.</td></tr><tr><td style="text-align:left">82</td><td style="text-align:left">Could not load CRL file, missing or wrong format (added in 7.19.0).</td></tr><tr><td style="text-align:left">83</td><td style="text-align:left">Issuer check failed (added in 7.19.0).</td></tr><tr><td style="text-align:left">XX</td><td style="text-align:left">More error codes will appear here in future releases. The existing ones are meant to never change.</td></tr></tbody></table><p><strong>四、常见用法</strong></p><p><strong>4.1 下载(option:-o或者option:-O)</strong></p><p>①下载页面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -o dodo1.jpg http:www.linux.com/dodo1.JPG</span><br><span class="line">\#要注意-O这里后面的url要具体到某个文件，不然抓不下来</span><br><span class="line">curl -O http://www.linux.com/dodo1.JPG</span><br></pre></td></tr></table></figure><p>②循环下载有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://www.linux.com/dodo[1-5].JPG</span><br></pre></td></tr></table></figure><p>③下载重命名在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</span><br></pre></td></tr></table></figure><p>由于下载的hello与bb中的文件名都是dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG</span><br></pre></td></tr></table></figure><p>④分块下载(option：-r)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG</span><br><span class="line">curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG</span><br><span class="line">curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG</span><br><span class="line">cat dodo1_part* &gt; dodo1.JPG  #这样就可以查看dodo1.JPG的内容了</span><br></pre></td></tr></table></figure><p>⑤通过ftp下载文件(option：-u)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法</span><br><span class="line">curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG</span><br><span class="line">curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG</span><br></pre></td></tr></table></figure><p>⑥下载，显示进度条(option：-#)或不显示进度条(option：-s)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -# -O http://www.linux.com/dodo1.JPG  </span><br><span class="line">curl -s -O http://www.linux.com/dodo1.JPG</span><br></pre></td></tr></table></figure><p>⑦下载，断点续传(-C<offset>)<br>断点续转，从文件头的指定位置开始继续下载/上传；offset续传开始的位置，如果offset值为“-”，curl会自动从文件中识别起始位置开始传输；</offset></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -# -o centos6.8.iso -C - http://mirrors.aliyun.com/centos/6.8/isos/x86_64/CentOS-6.8-x86_64-minimal.iso</span><br><span class="line">curl -C -O http://www.linux.com/dodo1.JPG</span><br></pre></td></tr></table></figure><p><strong>4.2 上传文件(option:-T)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/</span><br></pre></td></tr></table></figure><p><strong>4.3 伪造来源页面|伪造referer|盗链 (option：-e)</strong></p><p>很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这样就会让服务器其以为你是从www.linux.com点击某个链接过来的</span></span><br><span class="line">curl -e &quot;www.linux.com&quot; http://mail.linux.com</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">告诉爱E族，我是从百度来的</span></span><br><span class="line">curl -e http://baidu.com http://aiezu.com</span><br></pre></td></tr></table></figure><p>4.4 <strong>伪造代理设备(模仿浏览器)</strong></p><p>有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">告诉爱E族，我是GOOGLE爬虫蜘蛛（其实我是curl命令）</span></span><br><span class="line">curl -A &quot; Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot; http://aiezu.com</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">告诉爱E族，我用的是微信内置浏览器</span></span><br><span class="line">curl -A &quot;Mozilla/5.0 AppleWebKit/600 Mobile MicroMessenger/6.0&quot; http://aiezu.com</span><br></pre></td></tr></table></figure><p><strong>5. 设置http请求</strong></p><p><strong>5.1 设置http请求头(或option:-H或option:–head)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Cache-Control:no-cache&quot;  http://aiezu.com</span><br></pre></td></tr></table></figure><p><strong>5.2 指定proxy服务器以及其端口(option::-x)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理</span></span><br><span class="line">curl -x 192.168.100.100:1080 http://www.linux.com</span><br></pre></td></tr></table></figure><p><strong>6. http响应头</strong></p><p><strong>6.1 查看http响应头(option:-I)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看看本站的http头是怎么样的</span></span><br><span class="line">curl -I  http://aiezu.com</span><br><span class="line">输出：</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 25 Nov 2016 16:45:49 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Set-Cookie: rox__Session=abdrt8vesprhnpc3f63p1df7j4; path=/</span><br><span class="line">Expires: Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p><strong>6.2 保存http的response里面的header信息(option:-D)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -D cookied.txt http://www.linux.com</span><br></pre></td></tr></table></figure><p>执行后cookie信息就被存到了cookied.txt里面了注意：-c(小写)产生的cookie和-D里面的cookie是不一样的。</p><p><strong>7. 发送表单数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &quot;pic=@logo.png&quot; -F &quot;site=aiezu&quot;  http://aiezu.com/</span><br></pre></td></tr></table></figure><p><strong>8. cookie</strong></p><p><strong>8.1 发送cookie(option:-b）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\#有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookie</span><br><span class="line">curl -b &quot;domain=aiezu.com&quot;  http://aiezu.com</span><br><span class="line">\#很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b</span><br><span class="line">curl -b cookiec.txt http://www.linux.com</span><br></pre></td></tr></table></figure><p><strong>8.2 保存http的response里面的cookie信息(option:-c）</strong><br>执行后http的response里面的cookie信息就被存到了cookiec.txt里面了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -c cookiec.txt  http://www.linux.com</span><br></pre></td></tr></table></figure><p><strong>9. 测试一个网址</strong></p><p><strong>9.1 测试一个网址是否可达</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v http://www.linux.com</span><br></pre></td></tr></table></figure><p><strong>9.2 测试网页返回值(option:-w [format])</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com</span><br></pre></td></tr></table></figure><p><strong>10. 保存访问的网页(&gt;&gt;)</strong></p><p>使用linux的重定向功能保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.linux.com &gt;&gt; linux.html</span><br></pre></td></tr></table></figure><p><strong>11. 请求方式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -v -H &#x27;&#x27; -X POST -d &#x27;&#x27; http:www.test.com/a/b</span><br></pre></td></tr></table></figure><p>其中，-X POST -d, -X GET -d, -X PUT -d 分别等价于-F, -G -d, -P</p><p>以post请求为例：<br><strong>11.1 -X POST -d</strong><br>11.1.1 <code>POST application/x-www-form-urlencoded</code>是默认的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &quot;param1=value1¶m2=value2&quot; http://localhost:3000/data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">等价于</span></span><br><span class="line">curl -H &quot;Content-Type:application/x-www-form-urlencoded&quot; -X POST -d &quot;param1=value1¶m2=value2&quot; http://localhost:3000/data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用数据文件</span></span><br><span class="line">curl -X POST -d &quot;@data.txt&quot; http://localhost:3000/data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中data.txt内容如下：param1=value1¶m2=value2</span></span><br></pre></td></tr></table></figure><p>11.1.2 <code>POST application/json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;&#x27; http://localhost:3000/data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用数据文件的话：</span></span><br><span class="line">curl -X POST -d &quot;@data.json&quot; http://localhost:3000/data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">其中data.json内容如下：&#123;<span class="string">&quot;key1&quot;</span>:<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>:<span class="string">&quot;value2&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure><p>再举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-type:application/json&quot; -X POST -d &quot;&#123;\&quot;app_key\&quot;:\&quot;$appKey\&quot;,\&quot;time_stamp\&quot;:\&quot;$time\&quot;&#125;&quot; http://www.test.com.cn/a/b</span><br></pre></td></tr></table></figure><p><strong>11.2 <code>-F</code></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl  -v -H &quot;token: 222&quot; -F &quot;file=@/Users/fungleo/Downloads/401.png&quot; localhost:8000/api/v1/upimg </span><br><span class="line">curl -f http://www.linux.com/error</span><br></pre></td></tr></table></figure><p><strong>11.3、其它举例</strong></p><p>11.3.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl  -X POST &quot;http://www.test.com/e/f&quot; -H &quot;Content-Type:application/x-www-form-urlencoded;charset=UTF-8&quot; \</span><br><span class="line">-d &quot;a=b&quot; \</span><br><span class="line">-d &quot;c=d&quot; \</span><br><span class="line">-d &quot;e=f&quot; \</span><br><span class="line">-d &quot;g=h&quot;</span><br></pre></td></tr></table></figure><p>11.3.2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">错误：curl -i -G -d <span class="string">&quot;a=b#1&amp;c=d&quot;</span> http://www.test.com/e/f</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">正确：要把参数值是特殊符号的用urlencode转换过来</span></span><br><span class="line">curl -i -G -d &quot;a=b%231&amp;c=d&quot; http://www.test.com/e/f</span><br></pre></td></tr></table></figure><p><strong>12. 调试</strong></p><p>curl -v可以显示一次http通信的整个过程，包括端口连接和http request头信息。如果觉得还不够，那么下面的命令可以查看更详细的通信过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --trace output.txt www.baidu.com 或者 curl --trace-ascii output.txt www.baidu.com </span><br></pre></td></tr></table></figure><p>运行后，请打开output.txt文件查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl --trace output.txt  http://www.baidu.com</span><br><span class="line">curl --trace-ascii output2.txt  http://www.baidu.com</span><br><span class="line">curl --trace output3.txt --trace-time http://www.baidu.com</span><br><span class="line">curl --trace-ascii output4.txt --trace-time http://www.baidu.com </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/20190605132404348-3.png" alt="20190605132404348-3"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/20190605132434969.png" alt="img"></p><p>举例:有需求每5分钟请求一次<a target="_blank" rel="noopener" href="http://www.test.com/a/b%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E3%80%82%E5%B8%8C%E6%9C%9B%E4%B8%80%E6%9C%88%E7%9A%84%E6%97%A5%E5%BF%97(%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%92%8C%E9%94%99%E8%AF%AF%E7%9A%84)%E8%83%BD%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AA%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">http://www.test.com/a/b生成一个日志文件。希望一月的日志(正确的和错误的)能写入一个日志文件</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">day=`date +%F`</span><br><span class="line">logfile=&#x27;/var/logs/www.test.com_&#x27;`date +%Y%m`&#x27;.log&#x27;</span><br><span class="line">/usr/bin/echo -e &quot;\n\n[$&#123;day&#125;] Start request \n &quot; &gt;&gt; $&#123;logfile&#125;</span><br><span class="line">/bin/curl -v &quot;http://www.test.com/a/b&quot; -d &quot;ccccc&quot; 1&gt;&gt; $&#123;logfile&#125; 2&gt;&gt; $&#123;logfile&#125; --trace-time</span><br><span class="line">/usr/bin/echo -e &quot;\n\n[$&#123;day&#125;] End request\n&quot; &gt;&gt; $&#123;logfile&#125;</span><br></pre></td></tr></table></figure><p><strong>13. 显示抓取错误</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -f http://www.linux.com/error</span><br></pre></td></tr></table></figure><h3 id="4-rsync-数据镜像备份工具">.4 rsync 数据镜像备份工具</h3><ol><li><p>介绍</p><p>rsync（remote synchronize）是Liunx/Unix下的一个远程数据同步工具。它可通过LAN/WAN快速同步多台主机间的文件和目录，并适当利用rsync算法（差分编码）以减少数据的传输。rsync算法并不是每一次都整份传输，而是只传输两个文件的不同部分，因此其传输速度相当快。除此之外，rsync可拷贝、显示目录属性，以及拷贝文件，并可选择性的压缩以及递归拷贝。</p></li><li><p>工作原理</p><p>a、客户端构造FileList，FileList包含了需要与服务器同步的所有文件信息对name-&gt;id<br>（id用来唯一表示文件例如MD5）</p><p>b、客户端将FileList发送到服务器。</p><p>c、服务器上rsync处理客户端发过来的FileList，构建新的NewFileList。其中根据MD5值比较，删除服务器上已经存在的文件信息对，只保留服务器上不存在或变化的文件。</p><p>d、客户端得到服务器发送过来的NewFileList，然后把NewFileList中的文件重新传输到服务器。</p></li><li><p>优点</p><p>1）可以镜像保存整个目录树和文件系统。</p><p>2）可以很容易做到保持原来文件的权限、时间、软硬连接等。</p><p>3）无需特殊权限即可安装。</p><p>4）快速：第一次同步时rsync复制全部内容，但在下一次值传输修改过的内容</p><p>5）压缩传输：rysnc在传输的过程中可以实行压缩及解压缩操作，可以使用更少的带宽</p><p>6）安全：可以使用scp、ssh等方式来进行文件传输</p><p>7）支持匿名传输，以方便进行网站镜像</p><p>8）rsync不仅可以远程同步数据（类似于scp），而且可以本地同步数据（类似于cp），做差异同步</p><p>9）openssh 8.0已经把scp标记为过时不建议使用了。建议用sftp或者rsync替代scp</p><p>==需要在Liunx/Unix服务器之间互传海量数据时，建议选择rsync进行传输==</p></li><li><p>rsync认证方式</p><p>rsync有两种常用的认证方式，一种是rsync-daemon方式，另外一种是ssh方式。在平时使用过程，我们使用最多的是rsync-daemon方式。</p><p><strong>注意：在使用rsync时，服务器和客户端都必须安装rsync程序</strong>。</p><p>1）<strong>rsync-daemon 认证</strong></p><p>rsync在rsync-daemon认证方式下，默认监听TCP的873端口。</p><p>rsync-daemon认证方式是rsync的主要认证方式，这个也是我们经常使用的认证方式。并且也只有在此种模式下，rsync才可以把密码写入到一个文件中。</p><p>注意：<br>rsync-daemon认证方式，需要服务器和客户端都安装rsync服务并且只需要rsync服务器端启动rsync，同时配置rsync配置文件。客户端启动不启动rsync服务，都不影响同步的正常进行。</p><p>2）<strong>ssh认证</strong></p><p>rsync在ssh认证方式下，可通过系统用户进行认证，即在rsync上通过ssh隧道进行传输，类似于scp工具。此时同步操作不在局限于rsync中定义的同步文件夹。</p><p>注意：<br>ssh认证方式，不需要服务器和客户端配置rsync配置文件只需要双方都安装rsync服务，并且也不需要双方启动rsync。</p><p>若rsync服务端SSH为标准端口，此时rsync使用方式如下：</p><p>rsync -avz /root/test <a href="mailto:root@10.10.10.10">root@10.10.10.10</a>:/root/</p><p>若rsync服务端SSH为非标准端口，可通过rsync的-e参数进行端口指定。使用方式如下：</p><p>rsync -avz /root/test -e ‘ssh -p1234’ <a href="mailto:root@10.10.10.10">root@10.10.10.10</a>:/root/</p></li><li><p>安装rsync</p><p>1）源码安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码方式安装rsync，需要到其官网下载对应的安装包。rsync官网：rsync.samba.org </span></span><br><span class="line"></span><br><span class="line">1)、下载</span><br><span class="line">wget https://download.samba.org/pub/rsync/src/rsync-3.2.3.tar.gz</span><br><span class="line"></span><br><span class="line">2)、解压并安装</span><br><span class="line">tar -xvf rsync-3.2.3.tar.gz</span><br><span class="line"></span><br><span class="line">3)、编译安装</span><br><span class="line"><span class="comment"># 源码安装rsync时，其编译时所需要的gcc库文件尽量提前安装完毕</span></span><br><span class="line"><span class="comment"># 默认安装到/usr/local/目录下</span></span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp;make install</span><br><span class="line"></span><br><span class="line">4)、设置开机启动</span><br><span class="line"><span class="built_in">echo</span> “/usr/local/bin/rsync --daemon -config=/etc/rsyncd.conf” &gt;&gt;/etc/profile</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）yum安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install  rsync</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line"><span class="built_in">echo</span> “/usr/local/bin/rsync --daemon -config=/etc/rsyncd.conf” &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure></li><li><p>配置rsync daemon</p><p>rsync的配置分为服务器端和客户端,使用rsync协议，需要服务端启动守护进程。</p><p>1）<strong>服务端配置</strong> <code>vim /etc/rsyncd.conf</code></p><ul><li><p><strong>准备rsync配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 rsync 用户启动进程</span></span><br><span class="line">uid = rsync</span><br><span class="line">gid = rsync</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 无需让rsync以root身份运行，允许接收文件的完整属性</span></span><br><span class="line">fake super = <span class="built_in">yes</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁锢推送的数据至某个目录, 不允许跳出该目录</span></span><br><span class="line">use <span class="built_in">chroot</span> = no                </span><br><span class="line"></span><br><span class="line">max connections = 200          <span class="comment"># 最大连接数</span></span><br><span class="line"><span class="built_in">timeout</span> = 600                  <span class="comment"># 超时时间</span></span><br><span class="line">ignore errors                  <span class="comment"># 忽略错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> only = <span class="literal">false</span>              <span class="comment"># 对备份数据可读写</span></span><br><span class="line"></span><br><span class="line">list = <span class="literal">false</span>                   <span class="comment"># 不允许查看模块信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义虚拟用户，作为连接认证用户</span></span><br><span class="line">auth <span class="built_in">users</span> = myuser </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义rsync服务用户连接认证密码文件路径</span></span><br><span class="line">secrets file = /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 定义模块信息</span></span><br><span class="line">[backup]                </span><br><span class="line">comment = commit        <span class="comment"># 模块注释信息</span></span><br><span class="line">path = /backup          <span class="comment"># 定义接收备份数据目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只允许10.10.10段ip连接</span></span><br><span class="line">hosts allow = 10.10.10.0/24</span><br></pre></td></tr></table></figure></li><li><p><strong>配置并启动守护进程</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要一个rsync进程运行时使用的普通用户 rsync</span></span><br><span class="line">useradd rsync -M -s /sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端需要定义一个客户端连接    虚拟用户名和密码</span></span><br><span class="line"><span class="comment"># 密码文件形式  user:passwd</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;rsync_backup:Qweasz123456.&quot;</span> &gt; /etc/rsync.passwd</span><br><span class="line"><span class="built_in">chmod</span> 600 /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备模块定义好的目录,客户端的数据都存放在该目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> /backup</span><br><span class="line"><span class="built_in">chown</span> -R rsync.rsync /backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">rsync --daemon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务</span></span><br><span class="line">ps aux | grep rsync</span><br><span class="line">netstat -lntp|grep 873</span><br></pre></td></tr></table></figure></li></ul><p>2）<strong>客户端使用</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在客户端安装完毕rsync服务后，是不需要启动rsync服务的。</span></span><br><span class="line"><span class="comment"># 我们只需要在客户端创建连接rsync服务器时，验证码用户所需要的密码文件即可。</span></span><br><span class="line"><span class="comment"># 该密码文件中的密码要与rsync服务器上的密码文件中的密码对应</span></span><br><span class="line"><span class="comment"># 并且也要与rsync服务器rsyncd.conf配置文件中的认证模块中的用户匹配。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> “password”&gt;&gt;/etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 600 /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 rsync 守护程序分配的所有 module 列表，可以执行下面命令。</span></span><br><span class="line">rsync rsync://10.10.10.10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体写法是服务器与目标目录之间使用双冒号分隔`::`</span></span><br><span class="line"><span class="comment"># 地址中的module并不是实际路径名，而是 rsync 守护程序指定的模块名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地的文件同步到远程服务器</span></span><br><span class="line"><span class="comment"># rsync [OPTION]… [SRC]… [USER@]HOST::DEST</span></span><br><span class="line"><span class="comment"># rsync [选项] [--port=]  [--password-file=] [/local/path] [用户名]@服务端IP::[模块名]</span></span><br><span class="line"></span><br><span class="line">rsync -av --password-file=/etc/rsync.passwd <span class="built_in">local</span>/ myuser@10.10.10.10::backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程机器的文件同步到本地</span></span><br><span class="line"><span class="comment"># rsync [OPTION]… [USER@]HOST::SRC [DEST]</span></span><br><span class="line"><span class="comment"># rsync [选项] [--port=] [--password-file=] [用户名@]服务端IP::[模块名]  [/local/path]</span></span><br><span class="line"></span><br><span class="line">rsync -av --password-file=/etc/rsync.passwd myuser@10.10.10.10::backup <span class="built_in">local</span>/</span><br></pre></td></tr></table></figure></li><li><p>使用rsync</p><p>1）同步模式模式</p><ul><li><p>本地同步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##本地  rsync   选项       源      目标</span></span><br><span class="line">Local:  rsync [OPTION...] SRC... [DEST]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将/etc目录备份到/opt目录下，和cp的区别在于会自动增量备份</span></span><br><span class="line">rsync -avz /etc /opt</span><br></pre></td></tr></table></figure></li><li><p>远程同步</p><p><strong>ssh协议</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认使用 SSH 进行远程登录和数据传输</span></span><br><span class="line"><span class="comment"># 不需要做任何配置，需要都安装rsync，操作上类似scp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将远端文件拉（下载）到本地</span></span><br><span class="line">Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">         </span><br><span class="line"><span class="comment">#将本地文件推送（上传）到远端</span></span><br><span class="line">Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br><span class="line"> </span><br><span class="line"><span class="comment">#将etc推送到10.10.10.10下的自定义文件夹下</span></span><br><span class="line">rsync -az /etc/ 10.10.10.10:/opt/etc-$(hostname)-$(<span class="built_in">date</span> +%F)</span><br></pre></td></tr></table></figure><p><strong>rsync协议</strong></p><p>使用rsync协议，需要服务端启动守护进程</p></li></ul><p>2）命令参数</p><blockquote><p>常用参数</p><p>-v, –verbose详细模式输出。</p><p>-a, –archive归档模式，表示以递归方式传输文件，并保持所有文件属性不变。</p><p>-z, –compress对备份的文件在传输时进行压缩处理。</p><p>–delete：删除那些DST中存在而在SRC中没有的文件。</p><p>所有参数</p><p>-a：–archive archive mode 权限保存模式，相当于 -rlptgoD 参数，存档，递归，保持属性等。<br>-r：–recursive 复制所有下面的资料，递归处理。<br>-p：–perms 保留档案权限，文件原有属性。<br>-t：–times 保留时间点，文件原有时间。<br>-g：–group 保留原有属组。<br>-o：–owner 保留档案所有者(root only)。<br>-D：–devices 保留device资讯(root only)。<br>-l：–links 复制所有的连接，拷贝连接文件。<br>-z：–compress 压缩模式，当资料在传送到目的端进行档案压缩。<br>-H：–hard-links 保留硬链接文件。<br>-A：–acls 保留ACL属性文件，需要配合–perms。<br>-P：-P参数和 --partial --progress 相同，只是为了把参数简单化，表示传进度。<br>–version：输出rsync版本。<br>-v：–verbose 复杂的输出信息。<br>-u：–update 仅仅进行更新，也就是跳过已经存在的目标位置，并且文件时间要晚于要备份的文件，不覆盖新的文件。<br>–port=PORT：定义rsyncd(daemon)要运行的port(预设为tcp 873)。</p><p>–delete：删除那些目标位置有的文件而备份源没有的文件。</p><p>–delete-before: 接收者在传输之前进行删除操作</p><p>–password-file=FILE ：从 指定密码文件中获取密码。<br>–bwlimit=KBPS：限制 I/O 带宽。<br>–filter “-filename”：需要过滤的文件。<br>–exclude=filname：需要过滤的文件。<br>–progress：显示备份过程。</p></blockquote></li><li><p>rsyncd.conf 详解</p><p>1）全局参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在独立运行时，用于指定的服务器运行的 IP 地址</span></span><br><span class="line">address = IP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听端口</span></span><br><span class="line">port = 873 </span><br><span class="line"></span><br><span class="line"><span class="comment"># rsync 的守护进程将其 PID 写入指定的文件</span></span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定支持 max connections 参数的锁文件</span></span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 rsync 守护进程的日志文件，而不将日志发送给 syslog</span></span><br><span class="line"><span class="built_in">log</span> file = /var/log/rsyncd.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#========== 控制参数 =============#</span></span><br><span class="line"> <span class="comment"># 以指定的 UID 传输文件</span></span><br><span class="line">uid = rsync        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定该模块以指定的 GID 传输文件。</span></span><br><span class="line">gid = rsync                     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁锢推送的数据至某个目录, 不允许跳出该目录,</span></span><br><span class="line"><span class="comment"># 默认为 yes，则 rsync 在传输文件之前首先 chroot 到 path 参数所指定的目录下</span></span><br><span class="line"><span class="comment"># 这样做的原因是实现额外的安全防护，但是缺点是需要 root 权限</span></span><br><span class="line"><span class="comment"># 并且不能备份指向 path 外部的符号连接所指向的目录文件</span></span><br><span class="line">use <span class="built_in">chroot</span> = no                </span><br><span class="line"></span><br><span class="line"><span class="comment"># 无需让rsync以root身份运行，允许接收文件的完整属性</span></span><br><span class="line">fake super = <span class="built_in">yes</span>                </span><br><span class="line"></span><br><span class="line"><span class="comment"># 大并发连接数量以保护服务器，超过限制的连接请求将被告知随后再试</span></span><br><span class="line"><span class="comment"># 默认为0 （没有限制）</span></span><br><span class="line">max connections = 200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时时间</span></span><br><span class="line"><span class="built_in">timeout</span> = 600                  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定在 rsync 服务器上运行 delete 操作时是否忽略 I/O 错误。</span></span><br><span class="line"><span class="comment"># 一般来说 rsync 在出现 I/O 错误时将将跳过 –delete 操作</span></span><br><span class="line"><span class="comment"># 以防止因为暂时的资源不足或其它 I/O 错误导致的严重问题。</span></span><br><span class="line">ignore errors </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定是否允许客户上传文件。</span></span><br><span class="line"><span class="comment"># 默认为true，不允许用户上传文件，</span></span><br><span class="line"><span class="comment"># 若为 false 并且服务器目录也具有读写权限则允许上传。</span></span><br><span class="line"><span class="built_in">read</span> only = <span class="literal">false</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定当客户请求列出可以使用的模块列表时，该模块是否应该被列出。</span></span><br><span class="line"><span class="comment"># 默认为 true，如果设置该选项为 false，可以创建隐藏的模块</span></span><br><span class="line">list = <span class="literal">false</span>                  </span><br></pre></td></tr></table></figure><p>2）局部参数</p><p>模块参数主要用于定义 rsync 服务器哪个目录要被同步。</p><p>模块声明的格式必须为 [module] 形式，这个名字就是在 rsync 客户端看到的名字，类似于 Samba 服务器提供的共享名。</p><p>而服务器真正同步的数据是通过 path 来指定的。可以根据自己的需要，来指定多个模块，模块中可以定义以下参数：</p><ul><li><p>基本模块参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定模块名</span></span><br><span class="line">[backup]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定当前模块在 rsync 服务器上的同步路径，该参数是必须指定的</span></span><br><span class="line">path = /backup  	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给模块指定一个描述，该描述连同模块名在客户连接得到模块列表时显示给客户</span></span><br><span class="line">comment = commit	</span><br></pre></td></tr></table></figure></li><li><p>模块文件筛选参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定多个由空格隔开的多个文件或目录(相对路径)</span></span><br><span class="line"><span class="comment"># 并将其添加到 exclude 列表中。这等同于在客户端命令中使用 –exclude 来指定模式。</span></span><br><span class="line">exclude = exclude_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个包含 exclude 规则定义的文件名，服务器从该文件中读取 exclude 列表定义</span></span><br><span class="line">exclude from = exclude-file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多个由空格隔开的多个文件或目录(相对路径)，并将其添加到 include 列表中。</span></span><br><span class="line"><span class="comment"># 这等同于在客户端命令中使用 –include 来指定模式 。</span></span><br><span class="line">include = include-file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个包含 include 规则定义的文件名，服务器从该文件中读取 include 列表定义</span></span><br><span class="line">include from = exclude-file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个模块只能指定一个exclude 参数、一个include 参数</span></span><br><span class="line"><span class="comment"># 结合 include 和 exclude 可以定义复杂的exclude/include 规则</span></span><br><span class="line"><span class="comment"># 这几个参数分别与相应的rsync 客户命令选项等价，唯一不同的是它们作用在服务器端</span></span><br></pre></td></tr></table></figure></li><li><p>模块用户认证参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rsync 默认匿名方式传输</span></span><br><span class="line"><span class="comment"># 若只配置匿名访问的 rsync 服务器，则无需设置下述参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定由空格或逗号分隔的用户名列表，只有这些用户才允许连接该模块。</span></span><br><span class="line"><span class="comment"># 这里的用户和系统用户没有任何关系。用户名和口令以明文方式存放在 secrets file 参数指定的文件中</span></span><br><span class="line">auth <span class="built_in">users</span> = user_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一个 rsync 认证口令文件。只有在 auth users 被定义时，该文件才起作用</span></span><br><span class="line">secrets file = /etc/rsync.passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># rsync 认证口令文件的权限一定是 600，否则客户端将不能连接服务器。</span></span><br><span class="line"><span class="comment"># rsync 认证口令文件中每一行指定一个 用户名:口令 对，格式为：</span></span><br><span class="line"><span class="comment"># username:passwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来说口令最好不要超过8个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个rsync配置文件中可以包含多个认证模块，同时一个密码文件中也可以存放多个用户和其对应的密码。</span></span><br><span class="line"><span class="comment"># 其中每一个认证模块可以对应不同的客户端。</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>abc <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>^abc <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.halfsummer.xyz">aceniu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.halfsummer.xyz/posts/52702296.html">https://blog.halfsummer.xyz/posts/52702296.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.halfsummer.xyz" target="_blank">艾斯牛 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://img01.anzhiy.cn/useruploads/0/2023/02/13/63e915ae124a2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/3c3cdb74.html" title="Git 学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/12/63e8a8f5d92df.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git 学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c1031b26.html" title="Zabbix 6.0 学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/12/63e8a6408cf8b.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">Zabbix 6.0 学习笔记</div></div></a></div><div><a href="/posts/1763fb9d.html" title="WMware 虚拟机安装 Linux"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/13/63e915ae124a2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-13</div><div class="title">WMware 虚拟机安装 Linux</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/12/63e7dea41c063.gif" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">aceniu</div><div class="author-info__description">Love 33 & Yilia</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aceniu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/aceniu" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-icon_github-circle"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=123354319@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-Rss"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/289493392" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=123354319&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-icon_qq-circle"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#swig%EF%BF%BC440"><span class="toc-text">Linux 概述(1)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#swig%EF%BF%BC441"><span class="toc-text">安装 Linux(2)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#swig%EF%BF%BC444"><span class="toc-text">登入 Linux(3)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#swig%EF%BF%BC447"><span class="toc-text">文件系统(4)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#swig%EF%BF%BC448"><span class="toc-text">基础配置(5)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#swig%EF%BF%BC449"><span class="toc-text">网络配置(5.1)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swig%EF%BF%BC450"><span class="toc-text">配置主机名(5.2)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swig%EF%BF%BC451"><span class="toc-text">防火墙(5.2)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Seliunx"><span class="toc-text">5.3 Seliunx</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPM%E5%8C%85%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD%E5%92%8C%E5%8D%87%E7%BA%A7-sup-6-1-2-sup"><span class="toc-text">RPM包安装、卸载和升级(6.1.2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPM%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%BD%AF%E4%BB%B6%E5%8C%85-sup-6-1-2-sup"><span class="toc-text">RPM命令查询软件包(6.1.2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-yum%E6%BA%90"><span class="toc-text">6.3 yum源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-yum-%E9%85%8D%E7%BD%AE"><span class="toc-text">6.1 yum 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85-yum-%E6%BA%90"><span class="toc-text">6.2 更换国内 yum 源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-yum-%E5%91%BD%E4%BB%A4"><span class="toc-text">6.3 yum 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%EF%BC%89%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">7）系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-service-OS6"><span class="toc-text">6.1 service (OS6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-systemctl-OS7"><span class="toc-text">6.2 systemctl (OS7)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB"><span class="toc-text">6.3 服务运行级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-chkconfig-OS6"><span class="toc-text">6.4 chkconfig (OS6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4"><span class="toc-text">6.5 关机重启命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-iptables%EF%BC%88OS6%EF%BC%89"><span class="toc-text">6.6 iptables（OS6）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-span-id-firewall-firewall-span-%EF%BC%880S7%EF%BC%89"><span class="toc-text">6.7 firewall（0S7）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%BC%89%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">8）快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%BC%89%E5%91%BD%E4%BB%A4"><span class="toc-text">8）命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%B8%AE%E5%8A%A9"><span class="toc-text">8.1 帮助</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-man-%E8%8E%B7%E5%BE%97%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="toc-text">8.1.1 man 获得帮助信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-help-%E8%8E%B7%E5%BE%97shell%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="toc-text">8.1.2 help 获得shell内置命令的帮助信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-text">8.2 文件和目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-pwd-%E6%98%BE%E7%A4%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">8.2.1 pwd 显示绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-ls-%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">8.2.2 ls 列出目录的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-cd-%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95"><span class="toc-text">8.2.3 cd 切换目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-mkdir-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-text">8.2.4 mkdir 创建一个新的目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-5-rmdir-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-text">8.2.5 rmdir 删除一个空的目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-6-touch-%E5%88%9B%E5%BB%BA%E7%A9%BA%E6%96%87%E4%BB%B6"><span class="toc-text">8.2.6 touch 创建空文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-7-cp-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">8.2.7 cp 复制文件或目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-8-rm-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">8.2.8 rm 删除文件或目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-9-mv-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%88%96%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-text">8.2.9 mv 移动文件与目录或重命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-13-ln-%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-text">8.2.13 ln 建立一个同步的链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-14-scp-%E5%AE%89%E5%85%A8%E6%8B%B7%E8%B4%9D"><span class="toc-text">8.2.14 scp 安全拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-text">8.3 文本处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-cat-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">8.3.1 cat 查看文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-more-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%88%86%E5%B1%8F%E6%9F%A5%E7%9C%8B%E5%99%A8"><span class="toc-text">8.3.2 more 文件内容分屏查看器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-head-%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E5%86%85%E5%AE%B9"><span class="toc-text">8.3.3 head 显示文件头部内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-4-less-%E5%88%86%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">8.3.4 less 分屏显示文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-5-tail-%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8%E5%86%85%E5%AE%B9"><span class="toc-text">8.3.5 tail 输出文件尾部内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-6-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">8.3.6 &gt; &gt;&gt; 输出重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-7-cut-%E9%80%89%E5%8F%96%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9"><span class="toc-text">8.3.7 cut 选取部分内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-8-tr-%E5%AF%B9%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E5%81%9A%E6%9B%BF%E6%8D%A2"><span class="toc-text">8.3.8 tr 对标准输入内容做替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-11-%E7%94%A8%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E6%8C%87%E5%AE%9A%E8%A1%8C%E5%8C%BA%E9%97%B4%E7%AE%A1%E9%81%93%E7%AC%A6"><span class="toc-text">8.3.11 | 用文本模式指定行区间管道符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-12-xargs-%E7%BB%99%E5%91%BD%E4%BB%A4%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-text">8.3.12 xargs 给命令传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-13-echo-%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">8.3.13 echo 输出内容到控制台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-14-printf-%E8%BE%93%E5%87%BA"><span class="toc-text">8.3.14 printf 输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-15-grep-%E8%BF%87%E6%BB%A4%E6%9F%A5%E6%89%BE"><span class="toc-text">8.3.15 grep 过滤查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-16-sed-%E5%AD%97%E7%AC%A6%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8-Stream-EDitor"><span class="toc-text">8.3.16 sed 字符流编辑器(Stream EDitor)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-17-awk"><span class="toc-text">8.3.17 awk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-18-history-%E6%9F%A5%E7%9C%8B%E5%B7%B2%E7%BB%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%9A%84%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-text">8.3.18 history 查看已经执行过的历史命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4"><span class="toc-text">8.4 日期、时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-date-%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="toc-text">8.4.1 date 日期与时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-cal-%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%8E%86"><span class="toc-text">8.4.2 cal 查看日历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E7%94%A8%E6%88%B7%E3%80%81%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86"><span class="toc-text">8.5 用户、用户组管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-etc-passwd-%E7%B3%BB%E7%BB%9F-%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">8.5.3 &#x2F;etc&#x2F;passwd 系统-用户配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-5-etc-group-%E7%B3%BB%E7%BB%9F-%E7%94%A8%E6%88%B7%E7%BB%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">8.5.5 &#x2F;etc&#x2F;group 系统-用户组配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-9-useradd-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7"><span class="toc-text">8.5.9 useradd 添加新用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-10-passwd-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-text">8.5.10 passwd 设置用户密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-11-usermod-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">8.5.11 usermod 修改用户信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-13-userdel-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-text">8.4.13 userdel 删除用户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-14-id-%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E7%9A%84UID%E5%92%8CGID"><span class="toc-text">8.4.14 id 查看用户的UID和GID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-15-su-%E7%94%A8%E6%88%B7%E9%97%B4%E5%88%87%E6%8D%A2"><span class="toc-text">8.4.15 su 用户间切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-16-who-%E6%9F%A5%E7%9C%8B%E7%99%BB%E5%BD%95%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">8.4.16 who 查看登录用户信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-17-groupadd-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-text">8.4.17 groupadd 添加用户组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-18-groupmod-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-text">8.4.18 groupmod 修改用户组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-19-groupdel-%E5%88%AA%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-text">8.4.19 groupdel 刪除用户组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-20-gpasswd-%E6%8A%8A%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E8%BF%9B%E7%BB%84%E6%88%96%E4%BB%8E%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4"><span class="toc-text">8.4.20 gpasswd 把用户添加进组或从组中删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-21-newgrp-%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E7%9A%84%E6%9C%89%E6%95%88%E7%BB%84"><span class="toc-text">8.4.21 newgrp 切换用户的有效组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">8.6 权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2-chgrp-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E5%B1%9E%E7%BB%84"><span class="toc-text">8.6.2 chgrp 修改文件和目录的所属组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-3-chown-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85%E5%92%8C%E6%89%80%E5%B1%9E%E7%BB%84"><span class="toc-text">8.6.3 chown 修改文件和目录的所有者和所属组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-5-r%E3%80%81-w%E3%80%81-x-%E8%AF%BB%E5%86%99%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90"><span class="toc-text">8.6.5 (-r、-w、-x) 读写执行权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-6-chmod-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-text">8.6.6 chmod 修改文件或目录的权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-16-chattr-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%83%E9%99%90%E5%B1%9E%E6%80%A7"><span class="toc-text">8.6.16 chattr 修改文件系统的权限属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-18-sudo-%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">8.6.18 sudo 系统权限管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E6%9F%A5%E8%AF%A2"><span class="toc-text">8.7 查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-1-find-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%9B%AE%E5%BD%95"><span class="toc-text">8.7.1 find 查找文件或者目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-2-locate-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-text">8.7.2 locate 快速定位文件路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E5%8E%8B%E7%BC%A9%E5%92%8C%E6%89%93%E5%8C%85"><span class="toc-text">8.8 压缩和打包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-1-gzip-gunzip-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="toc-text">8.8.1 gzip&#x2F;gunzip 压缩&#x2F;解压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-2-zip-unzip-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="toc-text">8.8.2 zip&#x2F;unzip 压缩&#x2F;解压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8-3-tar-%E6%89%93%E5%8C%85"><span class="toc-text">8.8.3 tar 打包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">8.9 文件系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-1-df-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A1%AC%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">8.9.1 df 查看文件系统硬盘使用情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-2-du-%E7%BB%9F%E8%AE%A1%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E6%89%80%E5%8D%A0%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-text">8.9.2 du 统计目录或文件所占磁盘空间大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-3-lsblk-%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E6%8C%82%E8%BD%BD%E6%83%85%E5%86%B5"><span class="toc-text">8.9.3 lsblk 查看设备挂载情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-4-mount-umount-%E6%8C%82%E8%BD%BD-%E5%8D%B8%E8%BD%BD"><span class="toc-text">8.9.4 mount&#x2F;umount 挂载&#x2F;卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-5-%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98"><span class="toc-text">8.9.5 挂载光盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-6-%E6%8C%82%E8%BD%BDu%E7%9B%98"><span class="toc-text">8.9.6 挂载u盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-7-etc-fatab-%E9%85%8D%E7%BD%AE-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="toc-text">8.9.7 &#x2F;etc&#x2F;fatab 配置-开机自动挂载硬件设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-8-fdisk-%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-text">8.9.8 fdisk 硬盘分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-9-parted-%E5%88%9B%E5%BB%BA%E5%88%86%E5%8C%BA"><span class="toc-text">8.9.9 parted 创建分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-10-mkfs-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%88%86%E5%8C%BA%EF%BC%88%E4%B8%BA%E5%88%86%E5%8C%BA%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-text">8.9.10 mkfs 格式化分区（为分区写入文件系统）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-11-mkfs2-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%A1%AC%E7%9B%98-%EF%BC%88%E4%B8%BA%E7%A1%AC%E7%9B%98%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-text">8.9.11 mkfs2 格式化硬盘 （为硬盘写入文件系统）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-12-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-text">8.9.12 虚拟内存和物理内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-12-swap%E5%88%86%E5%8C%BA"><span class="toc-text">8.9.12 swap分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9-25-%E6%B7%BB%E5%8A%A0%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA%E6%8C%82%E8%BD%BD"><span class="toc-text">8.9.25 添加磁盘及分区挂载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">8.10 系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">8.10.1 进程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-2-ps-%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">8.10.2 ps 查看正在运行的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-3-top-%E6%8C%81%E7%BB%AD%E7%9B%91%E5%90%AC%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-text">8.10.3 top 持续监听进程运行状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-5-lsof"><span class="toc-text">8.10.5 lsof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-4-pstree-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%A0%91"><span class="toc-text">8.10.4 pstree 查看进程树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-6-kill-%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-text">8.10.6 kill 终止进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-7-killall-%E7%BB%88%E6%AD%A2%E7%89%B9%E5%AE%9A%E7%9A%84%E4%B8%80%E7%B1%BB%E8%BF%9B%E7%A8%8B"><span class="toc-text">8.10.7 killall 终止特定的一类进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-8-crontab-%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">8.10.8 crontab 循环执行定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-9-free-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81"><span class="toc-text">8.10.9 free 查看内存使用状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-10-10-w-who-%E6%9F%A5%E7%9C%8B%E7%99%BB%E9%99%86%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">8.10.10 w who 查看登陆用户信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-%E7%AB%AF%E5%8F%A3%E7%AE%A1%E7%90%86"><span class="toc-text">8.11 端口管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-11-1-netstat-%E6%98%BE%E7%A4%BA%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81"><span class="toc-text">8.11.1 netstat 显示网络状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%EF%BC%89%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD"><span class="toc-text">9）系统备份</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%87%E4%BB%BD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text">1.备份的重要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5"><span class="toc-text">2.备份策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tar%E5%91%BD%E4%BB%A4%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="toc-text">3.tar命令备份数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%EF%BC%89%E5%B7%A5%E5%85%B7"><span class="toc-text">20）工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-VI-VIM-%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-text">.1 VI&#x2F;VIM 文档编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-wget-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7"><span class="toc-text">.2 wget 下载文件工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-curl-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%B7%A5%E5%85%B7"><span class="toc-text">.3 curl 文件传输工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-rsync-%E6%95%B0%E6%8D%AE%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%B7%A5%E5%85%B7"><span class="toc-text">.4 rsync 数据镜像备份工具</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/9fc1e5d1.html" title="Hexo 中使用 emoji 表情"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/16/63ed11050fa2b.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Hexo 中使用 emoji 表情"></a><div class="content"><a class="title" href="/posts/9fc1e5d1.html" title="Hexo 中使用 emoji 表情">Hexo 中使用 emoji 表情</a><time datetime="2023-02-15T00:05:54.000Z" title="发表于 2023-02-15 00:05:54">2023-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1763fb9d.html" title="WMware 虚拟机安装 Linux"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/13/63e915ae124a2.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WMware 虚拟机安装 Linux"></a><div class="content"><a class="title" href="/posts/1763fb9d.html" title="WMware 虚拟机安装 Linux">WMware 虚拟机安装 Linux</a><time datetime="2023-02-13T17:55:37.000Z" title="发表于 2023-02-13 17:55:37">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ba31607c.html" title="VMware网络配置，只此一篇就够了！"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/13/63e9d01c05b00.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="VMware网络配置，只此一篇就够了！"></a><div class="content"><a class="title" href="/posts/ba31607c.html" title="VMware网络配置，只此一篇就够了！">VMware网络配置，只此一篇就够了！</a><time datetime="2023-02-13T12:23:06.000Z" title="发表于 2023-02-13 12:23:06">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1031b26.html" title="Zabbix 6.0 学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/12/63e8a6408cf8b.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Zabbix 6.0 学习笔记"></a><div class="content"><a class="title" href="/posts/c1031b26.html" title="Zabbix 6.0 学习笔记">Zabbix 6.0 学习笔记</a><time datetime="2023-02-12T00:44:21.000Z" title="发表于 2023-02-12 00:44:21">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3c3cdb74.html" title="Git 学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img01.anzhiy.cn/useruploads/0/2023/02/12/63e8a8f5d92df.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Git 学习笔记"></a><div class="content"><a class="title" href="/posts/3c3cdb74.html" title="Git 学习笔记">Git 学习笔记</a><time datetime="2023-02-10T16:35:00.000Z" title="发表于 2023-02-10 16:35:00">2023-02-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By aceniu</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>