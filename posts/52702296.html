<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>Linux 学习手册 | 艾斯牛 Blog</title><meta name="author" content="aceniu,123354319@qq.com"><meta name="copyright" content="aceniu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux 全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。"><meta property="og:type" content="article"><meta property="og:title" content="Linux 学习手册"><meta property="og:url" content="https://blog.halfsummer.xyz/posts/52702296.html"><meta property="og:site_name" content="艾斯牛 Blog"><meta property="og:description" content="Linux 全称GNU&#x2F;Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img01.anzhiy.cn/useruploads/0/2023/02/19/63f10532e1556.png"><meta property="article:published_time" content="2023-01-10T20:52:00.000Z"><meta property="article:modified_time" content="2023-02-12T22:48:00.000Z"><meta property="article:author" content="aceniu"><meta property="article:tag" content="编程"><meta property="article:tag" content="运维"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img01.anzhiy.cn/useruploads/0/2023/02/19/63f10532e1556.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.halfsummer.xyz/posts/52702296.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Linux 学习手册",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-02-12 22:48:00"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="艾斯牛 Blog" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/47ef438e7fff6.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i> <span>List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/"><i class="fa-fw fa fa-images faa-tada"></i> <span>图床</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://img01.anzhiy.cn/useruploads/0/2023/02/19/63f10532e1556.png)"><nav id="nav"><span id="blog-info"><a href="/" title="艾斯牛 Blog"><span class="site-name">艾斯牛 Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i> <span>List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/"><i class="fa-fw fa fa-images faa-tada"></i> <span>图床</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux 学习手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-10T20:52:00.000Z" title="发表于 2023-01-10 20:52:00">2023-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-12T22:48:00.000Z" title="更新于 2023-02-12 22:48:00">2023-02-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Program/">Program</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Linux 学习手册"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"><h1 id="操作系统的发展史">操作系统的发展史</h1><h2 id="Unix">Unix</h2><p>1965年之前，电脑只有军事或者学院的研究机构碰的起，当时大型主机至多能提供30台终端（30个键盘、显示器)的连接。<br>1965年左后由贝尔实验室、麻省理工学院 以及 通用电气共同发起了Multics项目，想让大型主机支持300台终端。<br>1969年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究。<br>1969年从这个项目中退出的Ken Thompson当时在实验室无聊时，为了让一台空闲的电脑上能够运行“星际旅行”游行，在8月份左右趁着其妻子探亲的时间，用了1个月的时间编写出了 Unix操作系统的原型。<br>1970年，美国贝尔实验室的 Ken Thompson，以 BCPL语言 为基础，设计出很简单且很接近硬件的 B语言（取BCPL的首字母），并且他用B语言写了第一个UNIX操作系统。因为B语言的跨平台性较差，为了能够在其他的电脑上也能够运行这个非常棒的Unix操作系统，Dennis Ritchie和Ken Thompson 从B语言的基础上准备研究一个更好的语言。<br>1972年，美国贝尔实验室的 Dennis Ritchie在B语言的基础上最终设计出了一种新的语言，他取了BCPL的第二个字母作为这种语言的名字，这就是C语言。<br>1973年初，C语言的主体完成。Thompson和Ritchie迫不及待地开始用它完全重写了现在大名鼎鼎的Unix操作系统。</p><h2 id="Minix">Minix</h2><p>因为AT&amp;T(通用电气)的政策改变，在Version 7 Unix推出之后，发布新的使用条款，将UNIX源代码私有化，在大学中不再能使用UNIX源代码。Andrew S. Tanenbaum(塔能鲍姆)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-UNIX）之意，将它称为MINIX。</p><h2 id="Linux">Linux</h2><p>因为Minix只是教学使用，因此功能并不强，因此Torvalds利用GNU的bash当做开发环境，gcc当做编译工具，编写了Linux内核-v0.02，但是一开始Linux并不能兼容Unix，即Unix上跑的应用程序不能在Linux上跑，即应用程序与内核之间的接口不一致，因为Unix是遵循POSIX规范的，因此Torvalds修改了Linux，并遵循POSIX（Portable Operating System Interface，他规范了应用程序与内核的接口规范）； 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件。</p><h2 id="操作系统的发展">操作系统的发展</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/linux_history01.jpg" alt="linux_history01"></p><h2 id="Minix没有火起来的原因">Minix没有火起来的原因</h2><p>Minix的创始人说，MINIX 3没有统治世界是源于他在1992年犯下的一个错误，当时他认为BSD必然会一统天下，因为它是一个更稳定和更成熟的系统，其它操作系统难以与之竞争。因此他的MINIX的重心集中在教育上。四名BSD开发者已经成立了一家公司销售BSD系统，他们甚至还有一个有趣的电话号码1-800-ITS-UNIX。然而他们正因为这个电话号码而惹火上身。美国电话电报公司因电话号码而提起诉讼。官司打了三年才解决。在此期间，BSD陷于停滞，而Linux则借此一飞冲天。他的错误在于没有意识官司竟然持续了如此长的时间，以及BSD会因此受到削弱。如果美国电话电报公司没有起诉，Linux永远不会流行起来，BSD将统治世界。</p><hr><h1 id="Linux介绍">Linux介绍</h1><h2 id="Linux内核-发行版">Linux内核&amp;发行版</h2><h3 id="Linux内核版本">Linux内核版本</h3><p>内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。</p><p>Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环：</p><p>稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。</p><p>开发版：由于要试验各种解决方案，所以变化很快。</p><p>所有来自全世界的对<strong>Linux源码</strong>的修改最终都会汇总到 <a target="_blank" rel="noopener" href="http://www.kernel.org">kernel.org</a> 这个网站，由Linus领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中。</p><h3 id="Linux发行版本">Linux发行版本</h3><p>Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。</p><p>目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/94fda88f37da710407059bf585dfccf4.png" alt="linuxOS-all"></p><h2 id="类Unix系统目录结构">类Unix系统目录结构</h2><p>Unix没有盘符这个概念，只有一个根目录/，所有文件都在它下面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">A[&quot;/&quot;] --&gt; B1[&quot;bin&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B2[&quot;sbin&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B3[&quot;usr&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B4[&quot;lib&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B5[&quot;...&quot;];</span><br><span class="line">B3 --&gt; C1[&quot;bin&quot;];</span><br><span class="line">B3 --&gt; C2[&quot;local&quot;];</span><br><span class="line">B3 --&gt; C3[&quot;lib&quot;];</span><br><span class="line">C2 --&gt; D1[&quot;include&quot;];</span><br></pre></td></tr></table></figure><h2 id="Linux目录结构">Linux目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">A[&quot;/&quot;] --&gt; B1[&quot;/bin&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B2[&quot;/sbin&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B3[&quot;/lib&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B4[&quot;/lib64&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B5[&quot;/usr&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B6[&quot;/boot&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B7[&quot;/dev&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B8[&quot;/etc&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B9[&quot;/home&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B10[&quot;/root&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B11[&quot;/opt&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B12[&quot;/media&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B13[&quot;/mnt&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B14[&quot;/proc&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B15[&quot;/run&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B16[&quot;/srv&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B17[&quot;/sys&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B18[&quot;/tmp&quot;];</span><br><span class="line">A[&quot;/&quot;] --&gt; B19[&quot;/var&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B1 -.- |实际位置| C1;</span><br><span class="line">B2 -.- |实际位置| C2;</span><br><span class="line">B3 -.- |实际位置| C3;</span><br><span class="line">B5 --&gt; C1[&quot;/usr/bin&quot;]</span><br><span class="line">B5 --&gt; C2[&quot;/usr/sbin&quot;]</span><br><span class="line">B5 --&gt; C3[&quot;/usr/lib&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>文件夹</th><th>作用</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“<code>/home</code>”，你其实是在告诉电脑，先从<code>/</code>（根目录）开始，再进入到<code>home</code>目录。</td></tr><tr><td><code>/bin</code>：<code>/usr/bin</code></td><td>常用命令集合（实际位置在<code>usr/bin</code>）。可执行二进制文件的目录，如常用的命令<code>ls</code>、<code>tar</code>、<code>mv</code>、<code>cat</code>等。</td></tr><tr><td><code>/sbin</code>：<code>/usr/sbin</code></td><td>管理员命令集（实际位置在<code>usr/sbin</code>）。放置系统管理员使用的可执行命令，如<code>fdisk</code>、<code>shutdown</code>、<code>mount</code> 等。与 <code>/bin</code> 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能&quot;查看&quot;而不能设置和使用。</td></tr><tr><td><code>/lib</code>： <code>/usr/lib</code>：<code>/usr/local/lib</code></td><td>库目录（相当于<code>System32</code>）（实际位置在<code>usr/lib</code>）。系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</td></tr><tr><td><code>/lib64</code></td><td>64位库目录。</td></tr><tr><td><code>/usr</code></td><td>包含用户的所有应用程序、文件和数据 （<code>usr/local/</code> 相当于 <code>Progrom Files</code> 应用一般安装于此）。应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。</td></tr><tr><td><code>/boot</code></td><td>挂载引导。放置linux系统启动时用到的一些文件，如Linux的内核文件：<code>/boot/vmlinuz</code>，系统引导管理器：<code>/boot/grub</code>。</td></tr><tr><td><code>/dev</code></td><td>管理所有设备。存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 <code>mount /dev/cdrom /mnt</code>。</td></tr><tr><td><code>/etc</code></td><td>系统管理的配置文件。不建议在此目录下存放可执行文件，重要的配置文件有<code>/etc/inittab</code>、<code>/etc/fstab</code>、<code>/etc/init.d</code>、<code>/etc/X11</code>、<code>/etc/sysconfig</code>、<code>/etc/xinetd.d</code>。</td></tr><tr><td><code>/home</code></td><td>用户的个性化主目录。系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，表示当前用户的家目录，edu 表示用户 edu 的家目录。</td></tr><tr><td><code>/root</code></td><td>管理员个性化主目录。</td></tr><tr><td><code>/opt</code></td><td>第三方软件包的目录。给主机额外安装软件所摆放的目录。</td></tr><tr><td><code>/mnt</code>：<code>/media</code></td><td>移动设备挂载点。光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。</td></tr><tr><td><code>/proc</code></td><td>进程目录。此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 <code>/proc/cpuinfo</code>、<code>/proc/interrupts</code>、<code>/proc/dma</code>、<code>/proc/ioports</code>、<code>/proc/net/*</code> 等。</td></tr><tr><td><code>/run</code></td><td>当前系统运行的所有信息。</td></tr><tr><td><code>/srv</code></td><td>系统服务。服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 <code>/srv/www</code> 内。</td></tr><tr><td><code>/sys</code></td><td>系统硬件信息的相关信息。</td></tr><tr><td><code>/tmp</code></td><td>临时目录。一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</td></tr><tr><td><code>/var</code></td><td>可变目录。放置系统执行过程中经常变化的文件，如随时更改的日志文件 <code>/var/log</code>，<code>/var/log/message</code>：所有的登录文件存放目录，<code>/var/spool/mail</code>：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。</td></tr><tr><td><code>/lost+fount</code></td><td>系统异常产生错误时，会将一些遗失的片段放置于此目录下。</td></tr></tbody></table><h2 id="用户目录">用户目录</h2><p>位于<code>/home/user</code>，称之为用户工作目录或家目录,表示方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/user</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p>从/目录开始描述的路径为绝对路径，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="built_in">ls</span> /usr</span><br></pre></td></tr></table></figure><p>从当前位置开始描述的路径为相对路径，如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../../</span><br><span class="line"><span class="built_in">ls</span> abc/def</span><br></pre></td></tr></table></figure><p>每个目录下都有<code>.</code>和<code>..</code></p><p><code>.</code> 表示当前目录</p><p><code>..</code> 表示上一级目录，即父目录</p><p>根目录下的<code>.</code>和<code>...</code>都表示当前目录</p><table><thead><tr><th>文件的颜色</th><th>含义</th></tr></thead><tbody><tr><td>蓝色</td><td>目录</td></tr><tr><td>绿色</td><td>可执行文件</td></tr><tr><td>红色</td><td>压缩文件</td></tr><tr><td>浅蓝色</td><td>链接文件</td></tr><tr><td>灰色</td><td>其他文件</td></tr></tbody></table><hr><h1 id="命令行基本操作">命令行基本操作</h1><h2 id="命令使用方法">命令使用方法</h2><p>📌<strong>Linux命令格式</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [-options] [parameter1] …</span><br></pre></td></tr></table></figure><blockquote><p>command: 命令名；</p><p>-options：选项,可用来对命令进行控制，也可以省略；</p><p>parameter1 …：传给命令的参数：可以是零个一个或多个。</p></blockquote><h2 id="查看帮助文档">查看帮助文档</h2><h3 id="help-内置命令的帮助信息">help 内置命令的帮助信息</h3><p>一般是linux命令自带的帮助信息。一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）”命令；响应的其他命令被称为“外部命令”。</p><p>📌<strong>help命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> [-options] [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>✨ <strong>主要用法</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[外部命令] --<span class="built_in">help</span>  </span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>输出每个命令的简短描述</td></tr><tr><td><code>-m</code></td><td>以类似于 man 手册的格式描述命令</td></tr><tr><td><code>-m</code></td><td>只显示命令使用格式</td></tr></tbody></table><h3 id="man-manual-获得帮助信息">man(manual) 获得帮助信息</h3><p>💾<u><code>/usr/share/man</code></u></p><p>man是linux提供的一个手册， 其内容包括绝大部分的命令语法、各选项的意义及相关命令、函数使用说明 。更为强大的是，不仅可以查看Linux中命令的使用帮助，还可以查看软件服务配置文件、系统调用、库函数等帮助信息。</p><p>📌<strong>man命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [-options] [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>在所有的man帮助手册中搜索</td></tr><tr><td>-d</td><td>主要用于检查，如果用户加入了一个新的文件，就可以用这个参数检查是否出错</td></tr><tr><td>-f</td><td>显示给定关键字的简短描述信息</td></tr><tr><td>-p</td><td>指定内容时使用分页程序</td></tr><tr><td>-M</td><td>指定man手册搜索的路径</td></tr><tr><td>-w</td><td>显示文件所在位置</td></tr></tbody></table><p>📌<strong>man中各个section意义如下</strong>：</p><p>该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。例：<code>man ls</code> ; <code>man 2 printf</code>。</p><ol><li>Standard commands（标准命令）</li><li>System calls（系统调用，如open,write）</li><li>Library functions（库函数，如printf,fopen）</li><li>Special devices（设备文件的说明，/dev下各种设备）</li><li>File formats（文件格式，如passwd）</li><li>Games and toys（游戏和娱乐）</li><li>Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</li><li>Administrative Commands（管理员命令，如ifconfig）</li></ol><p>man是按照手册的章节号的顺序进行搜索的。</p><p>📌<strong>man设置了如下的功能键</strong>：</p><table><thead><tr><th>功能键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter键</td><td>一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出man命令</td></tr><tr><td>h</td><td>列出所有功能键</td></tr><tr><td>/word</td><td>搜索word字符串</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/eaa669cc38073241cb90af97af43bc92.png" alt="man"></p><p>⚠️ <strong>注意</strong>：实际上，我们不用指定第几个章节也用查看，如，<code>man ls</code></p><h2 id="tab键-自动补全">tab键 自动补全</h2><p>在敲出命令的前几个字母的同时，按下<kbd>tab</kbd>，系统会自动帮我们补全命令。</p><h2 id="clear-清屏">clear 清屏</h2><p>clear作用为清除终端上的显示(类似于DOS的cls清屏功能)，<kbd>Ctrl</kbd> + <kbd>I</kbd>。</p><p>📌<strong>clear命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h2 id="history-命令行历史">history 命令行历史</h2><p>💾<u><code>/root/.bashrc</code></u></p><p>当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来。</p><p>实际上history的历史命令是写入.bash_history 中的。 ~/.bash_history 记录的是前一次登陆所运行过的命令，而本次登陆所运行的命令都被缓存在内存中，当退出系统后，本次的命令记忆才会记录到 .bash_history 中。</p><p>📌<strong>history命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histroy [-options]</span><br></pre></td></tr></table></figure><p>通常都是直接 <code>history</code> 然后通过管道配合 <code>more</code>，<code>less</code>，<code>tail</code>，<code>head</code> 来使用。</p><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>将目前的shell中的所有 history 内容全部清除</td></tr><tr><td>-a</td><td>将目前新增的history指令新增入 histfiles中，若没有 histfiles，则预设写入 ~/.bash_history</td></tr><tr><td>-r</td><td>将histfiles的内容读到目前这个shell的history记忆中</td></tr><tr><td>-w</td><td>将目前的history记忆内容写入histfiles</td></tr></tbody></table><p>📌<strong>常见用法</strong>：</p><p>history保留了最近执行的命令记录，默认可以保留1000。历史清单从0开始编号到最大值。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> N		<span class="comment"># 显示最近N条命令</span></span><br><span class="line"><span class="built_in">history</span> -c		<span class="comment"># 清除所有的历史记录</span></span><br><span class="line"><span class="built_in">history</span> -w  xxx.txt	<span class="comment"># 保存历史记录到文本xxx.txt</span></span><br></pre></td></tr></table></figure><h3 id="📕history生产环境优化">📕history生产环境优化</h3><p>在工作中，在不同终端下执行了一系列的命令后，翻不到历史记录、也没有汇总、也不知道每条命令的执行时间，所以需要对该命令进行优化。</p><p>📌<strong>配置文件位置</strong>:</p><ol><li>centos：<code>/root/.bashrc</code>；</li><li>ubuntu： <code>/etc/bash.bashrc</code>；</li><li>macos： <code>/etc/bashrc</code>。</li></ol><p>📌<strong>修改方法</strong>：</p><p>1️⃣打开配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.bashrc</span><br></pre></td></tr></table></figure><p>2️⃣添加配置内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 添加日期和时间</span><br><span class="line">HISTTIMEFORMAT=&quot;%F %T &quot;</span><br><span class="line">export HISTTIMEFORMAT</span><br><span class="line"></span><br><span class="line"># 不同终端命令汇总</span><br><span class="line"># Avoid duplicates</span><br><span class="line">export HISTCONTROL=ignoredups:erasedups</span><br><span class="line"># When the shell exits, append to the history file instead of overwriting it</span><br><span class="line">shopt -s histappend</span><br><span class="line"></span><br><span class="line"># 在每个命令之后，追加到历史文件并重新读取它</span><br><span class="line"># After each command, append to the history file and reread it</span><br><span class="line">export PROMPT_COMMAND=&quot;$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND$&#x27;\n&#x27;&#125;history -a; history -c; history -r&quot;</span><br><span class="line"></span><br><span class="line"># 调整记录命令长度</span><br><span class="line">export HISTSIZE=3000</span><br><span class="line"></span><br><span class="line"># 剔除连续重复的条目</span><br><span class="line"># Avoid duplicates</span><br><span class="line">export HISTCONTROL=ignoredups:erasedups</span><br></pre></td></tr></table></figure><p>3️⃣使配置生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="命令行中的快捷键">命令行中的快捷键</h2><p>📌<strong>linux常用的快捷键</strong>：</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>补全命令或显示所有可选项</td></tr><tr><td>Ctrl + Alt + T</td><td>打开当前页面的终端。</td></tr><tr><td>Ctrl + Shift + [+]</td><td>放大终端</td></tr><tr><td>Ctrl + [-]</td><td>缩小终端</td></tr><tr><td>Ctrl + a</td><td>使光标快速到行首</td></tr><tr><td>Ctrl + e</td><td>光标快速移到行尾</td></tr><tr><td>Ctrl + r</td><td>在历史命令中搜索</td></tr><tr><td>Ctrl + c</td><td>强制终止当前命令</td></tr><tr><td>Ctrl + z</td><td>暂停在终端运行的任务</td></tr><tr><td>Ctrl + l 或者 clear</td><td>清屏</td></tr><tr><td>Ctrl + Shift + f</td><td>查找</td></tr><tr><td>Ctrl + Shift + g</td><td>查找上一个，按回车下一个</td></tr><tr><td>Ctrl + Shift + c</td><td>复制</td></tr><tr><td>Ctrl + Shift + v</td><td>粘贴</td></tr><tr><td>Ctrl + K</td><td>光标所处位置到行末的所有内容 和 ctrl + u对立</td></tr><tr><td>Ctrl + U</td><td>光标所处位置到行首的所有内容 和 ctrl + k对立</td></tr><tr><td>Ctrl + W</td><td>光标所处位置之前的一个词，以空格、标点为界</td></tr><tr><td>Alt + F4</td><td>关闭当前窗口</td></tr><tr><td>Shift + PgUp</td><td>向上翻页</td></tr><tr><td>Shift + PgUp</td><td>向下翻页</td></tr><tr><td>Alt]+ Tab</td><td>切换不同的程序窗口</td></tr><tr><td>Alt + Shift + Tab</td><td>往回切换</td></tr><tr><td>F11</td><td>使终端全屏，再次按下退出全屏</td></tr><tr><td>[PrtSc]</td><td>获取整个屏幕的截图并保存到Pictures目录</td></tr></tbody></table><p>📌<strong>linux其它快捷键</strong>：</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl + t</td><td>交换光标位置前的两个字符</td></tr><tr><td>Ctrl + y</td><td>粘贴最后一次被删除的单词</td></tr><tr><td>Ctrl + z</td><td>把命令放入后台</td></tr><tr><td>Alt + b</td><td>光标往回移动到前一个单词</td></tr><tr><td>Alt + d</td><td>删除从光标位置到当前所处单词的末尾</td></tr><tr><td>Alt + F1</td><td>访问菜单</td></tr><tr><td>Alt + F2</td><td>运行</td></tr><tr><td>Alt + F10</td><td>最大化当前窗口，再次缩小</td></tr><tr><td>Ctrl + Alt + F2</td><td>切换到文本终端，也可以通过命令chvt n 来实现。如果你希望知道终端的名字，可以使用命令fgconsole</td></tr><tr><td>Ctrl + Alt + F1</td><td>从文本终端切换到图形用户界面</td></tr><tr><td>Ctrl + Alt + Delete</td><td>在文本终端下使用时强制重启</td></tr><tr><td>Shift + PrtSc</td><td>获取屏幕的某个区域截图并保存到Pictures目录</td></tr><tr><td>Alt + PrtS]</td><td>获取 当前窗口的截图并保存到Pictures目录</td></tr><tr><td>Ctrl + PrtSc</td><td>获取整个屏幕的截图并存放到剪贴板</td></tr><tr><td>Shift + Ctrl + PrtSc</td><td>获取屏幕的某个区域截图并存放到剪贴板</td></tr><tr><td>Ctrl + Alt + PrtSc</td><td>获取当前窗口的截图并存放到剪贴板</td></tr><tr><td>ctrl +f</td><td>光标向右移动一个 等价于小键盘的 &lt;-- 键</td></tr><tr><td>ctrl +b</td><td>光标向左移动一个 等价于小键盘的 --&gt; 键</td></tr><tr><td>ctrl +d</td><td>退出当前登录，等同于exit logout；如果在当前使用了ssh远程其他机器，改指令会退回当前奇迹</td></tr><tr><td>ctrl + h</td><td>向前退格，等价于backspace</td></tr><tr><td>ctrl + p</td><td>显示上一条指令 等价于小键盘 ↑</td></tr><tr><td>ctrl + n</td><td>显示下一条指令 等价于小键盘 ↓</td></tr><tr><td>ctrl + s</td><td>锁定终端，使任何人不允许输入，但是输入操作会记录</td></tr><tr><td>ctrl + q</td><td>解除ctrl +s的锁定，同时会展示或执行ctrl +s锁定时输入的指令</td></tr></tbody></table><hr><h1 id="Linux命令">Linux命令</h1><h2 id="权限管理">权限管理</h2><h3 id="r、-w、-x-文件访问权限">(-r、-w、-x) 文件访问权限</h3><p>用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限：</p><ul><li>读权限（r） ：对于文件，具有读取文件内容的权限；对于目录，具有浏览目录的权限。</li><li>写权限（w） ：对于文件，具有修改文件内容的权限；对于目录，具有删除、移动目录内文件的权限。</li><li>可执行权限（x）： 对于文件，具有执行文件的权限；对于目录，该用户具有进入目录的权限。</li></ul><p>通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/rwx2.png" alt="rwx2"></p><p><code>-rwxrwxrwx</code>从左至右用0-9这些数字来表示。第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>📌<strong>第一个字符的意义</strong>:</p><p>第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为[ <em>d</em> ]则是目录</li><li>当为[ <em>-</em> ]则是文件；</li><li>若是[ <em>l</em> ]则表示为链接文档(link file)；</li><li>若是[ <em>b</em> ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是[ <em>c</em> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p><strong>📌权限对文件的作用</strong>：</p><p>对于文件来说，执行权限是最高权限。给用户或群组设定权限时，是否赋予执行权限需要慎重考虑，否则会对系统安装造成严重影响。</p><table><thead><tr><th>rwx 权限</th><th>对文件的作用</th></tr></thead><tbody><tr><td>读权限（r）</td><td>表示可读取此文件中的实际内容，例如，可以对文件执行 cat、more、less、head、tail 等文件查看命令。</td></tr><tr><td>写权限（w）</td><td>表示可以编辑、新增或者修改文件中的内容，例如，可以对文件执行 vim、echo 等修改文件数据的命令。<br>注意，无权限不赋予用户删除文件的权利，除非用户对文件的上级目录拥有写权限才可以。</td></tr><tr><td>执行权限（x）</td><td>表示该文件具有被系统执行的权限。Window系统中查看一个文件是否为可执行文件，是通过扩展名（.exe、.bat 等），<br>但在 Linux 系统中，文件是否能被执行，是通过看此文件是否具有 x 权限来决定的。也就是说，只要文件拥有 x 权限，<br>则此文件就是可执行文件。但是，文件到底能够正确运行，还要看文件中的代码是否正确。</td></tr></tbody></table><p>📌<strong>权限对目录的作用</strong>：</p><p>对目录来说，如果只赋予 r 权限，则此目录是无法使用的。很简单，只有 r 权限的目录，用户只能查看目录结构，根本无法进入目录（需要用 x 权限），更不用说使用了。因此，对于目录来说，常用来设定目录的权限其实只有 0（—）、5（r-x）、7（rwx）这 3 种。</p><table><thead><tr><th>rwx 权限</th><th>对目录的作用</th></tr></thead><tbody><tr><td>读权限（r）</td><td>表示具有读取目录结构列表的权限，也就是说，可以看到目录中有哪些文件和子目录。一旦对目录拥有 r 权限，就可以在此目录下执行 ls 命令，查看目录中的内容。</td></tr><tr><td>写权限（w）</td><td>对于目录来说，w 权限是最高权限。对目录拥有 w 权限，表示可以对目录做以下操作：<br>·在此目录中建立新的文件或子目录；<br>·删除已存在的文件和目录（无论子文件或子目录的权限是怎样的）；<br>·对已存在的文件或目录做更名操作；<br>·移动此目录下的文件和目录的位置。<br>一旦对目录拥有 w 权限，就可以在目录下执行 touch、rm、cp、mv 等命令。</td></tr><tr><td>执行权限（x）</td><td>目录是不能直接运行的，对目录赋予 x 权限，代表用户可以进入目录，也就是说，赋予 x 权限的用户或群组可以使用 cd 命令。</td></tr></tbody></table><h3 id="chmod-修改文件或目录的权限">chmod 修改文件或目录的权限</h3><p>Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令。</p><p><strong><font style="color:red">只有<u>文件所有者</u>和<u>超级用户</u>可以修改文件或目录的权限</font></strong>。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/Untitled.png" alt="chmod"></p><p>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。</p><p>📌<strong>chmod命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [<span class="built_in">who</span>] [-options] [operator] permission name</span><br></pre></td></tr></table></figure><p>📌<strong>chmod修改文件权限有两种使用格式</strong>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/rwxNum.png" alt="rwxNum"></p><ul><li><p><strong>字母法</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [u/g/o/a] [+/-/=][rwx] 文件</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">[who] 用户类型</th><th>含义</th></tr></thead><tbody><tr><td align="left">u</td><td>user 表示该文件的所有者</td></tr><tr><td align="left">g</td><td>group 表示与该文件的所有者属于同一组( group )者，即用户组</td></tr><tr><td align="left">o</td><td>other 表示其他以外的人</td></tr><tr><td align="left">a</td><td>all 表示这三者皆是</td></tr></tbody></table><table><thead><tr><th>[operator] 操作符</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>增加权限</td></tr><tr><td>-</td><td>撤销权限</td></tr><tr><td>=</td><td>设定权限</td></tr></tbody></table><table><thead><tr><th>permission 权限</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>read 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。</td></tr><tr><td>w</td><td>write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。</td></tr><tr><td>x</td><td>excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。</td></tr></tbody></table></li><li><p><strong>数字法</strong>：“rwx” 这些权限也可以用数字来代替</p><table><thead><tr><th>八进制语法</th><th>权限</th><th>rwx</th><th>二进制</th></tr></thead><tbody><tr><td>7</td><td>读 + 写 + 执行</td><td>rwx</td><td>111</td></tr><tr><td>6</td><td>读 + 写</td><td>rw-</td><td>110</td></tr><tr><td>5</td><td>读 + 执行</td><td>r-x</td><td>101</td></tr><tr><td>4</td><td>只读</td><td>r–</td><td>100</td></tr><tr><td>3</td><td>写 + 执行</td><td>-wx</td><td>011</td></tr><tr><td>2</td><td>只写</td><td>-w-</td><td>010</td></tr><tr><td>1</td><td>只执行</td><td>–x</td><td>001</td></tr><tr><td>0</td><td>无</td><td>—</td><td>000</td></tr></tbody></table></li></ul><p>📌<strong>示例说明</strong>：</p><ol><li><p>设定 .bashrc 文件的权限为 rwxr-xr-x，则可执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chmod u=rwx,go=rx .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure></li><li><p>增加 .bashrc 文件的每种用户都可做写操作的权限，可以使用如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod a+w .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure></li></ol><h3 id="chown-修改文件和目录的所有者和所属组">chown 修改文件和目录的所有者和所属组</h3><p>Linux chown（英文全拼：<strong>change owner</strong>）命令用于设置文件所有者和文件关联组的命令。</p><p><strong><font style="color:red">只有<u>超级用户</u>和<u>属于组的文件所有者</u>才能变更文件关联组</font></strong>。非超级用户如需要设置关联组可能需要使用 <code>chgrp</code> 命令。</p><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 <code>chown</code> 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。</p><p>📌<strong>chown命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> [-options] user[:group] file</span><br></pre></td></tr></table></figure><blockquote><ul><li>user : 新的文件拥有者的使用者 ID</li><li>group : 新的文件拥有者的使用者组(group)</li></ul></blockquote><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><font style="color:red">-R</font></td><td>表示连同子目录中的所有文件，都更改所有者</td></tr><tr><td>-c</td><td>显示更改的部分的信息</td></tr><tr><td>-f</td><td>忽略错误信息</td></tr><tr><td>-v</td><td>显示详细的处理信息</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>修改文件的所有者，更多时候是为了得到更高的权限，举一个实例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#由root用户创建file文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># touch file</span></span><br><span class="line"><span class="comment">#文件的所有者是root，普通用户user对这个文件拥有只读权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:12 file</span><br><span class="line"><span class="comment">#修改文件的所有者</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chown user file</span></span><br><span class="line"><span class="comment">#所有者变成了user用户，这时user用户对这个文件就拥有了读、写权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 user root 0 Apr 17 05:12 file</span><br></pre></td></tr></table></figure><p>可以看到，通过修改 file 文件的所有者，user 用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。</p></li><li><p>Linux 系统中，用户等级权限的划分是非常清楚的，root 用户拥有最高权限，可以修改任何文件的权限，而普通用户只能修改自己文件的权限（所有者是自己的文件），例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入user用户的家目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd /home/user</span></span><br><span class="line"><span class="comment">#由root用户新建文件test</span></span><br><span class="line">[root@localhost user]<span class="comment"># touch test</span></span><br><span class="line"><span class="comment">#文件所有者和所属组都是root用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># ll test</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:37 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#切换为user用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># su - user</span></span><br><span class="line"><span class="comment">#user用户不能修改test文件的权限</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">chmod</span> 755 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">chmod</span>:更改<span class="string">&quot;test&quot;</span>的权限：不允许的操作</span><br><span class="line"><span class="comment">#退回到root身份</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment">#由root用户把test文件的所有者改为user用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># chown user test</span></span><br><span class="line"><span class="comment">#切换为user用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># su - user</span></span><br><span class="line"><span class="comment">#user用户由于是test文件的所有者，所以可以修改文件的权限</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">chmod</span> 755 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#查看权限</span></span><br><span class="line">[user@localhost ~]$ ll <span class="built_in">test</span></span><br><span class="line">-rwxr-xr-x. 1 user root 0 Apr 17 05:37 <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="chgrp-修改文件和目录的所属组">chgrp 修改文件和目录的所属组</h3><p>Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。</p><p>与 <code>chown</code> 命令不同，<code>chgrp</code> 允许普通用户改变文件所属的组，只要该用户是该组的一员。</p><p>在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 <code>chgrp</code> 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><p>📌<strong>chgrp命令格式</strong>：使用此命令需要注意的一点是，要被改变的群组名必须是真实存在的，否则命令无法正确执行，会提示 “invaild group name”。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [-options] group file</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-c</code>：<code>--changes</code></td><td>效果类似&quot;-v&quot;参数，但仅回报更改的部分</td></tr><tr><td><code>-f</code>：<code>--quiet</code>：<code>--silent</code></td><td>不显示错误信息</td></tr><tr><td><code>-h</code>：<code>--no-dereference</code></td><td>只对符号连接的文件作修改，而不改动其他任何相关文件</td></tr><tr><td><code>-R</code>：<code>--recursive</code></td><td>用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过</td></tr><tr><td><code>-reference=&lt;参考文件或目录&gt;</code></td><td>指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>当以 root 身份登录 Linux 系统时，主目录中会存在一个名为 install.log 的文件，我们可以使用如下方法修改此文件的所属组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd group1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建用于测试的群组 group1</span></span><br><span class="line">[root@localhost ~]# chgrp group1 install.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改install.log文件的所属组为group1</span></span><br><span class="line">[root@localhost ~]# ll install.log</span><br><span class="line">-rw-r--r--. 1 root group1 78495 Nov 17 05:54 install.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改生效</span></span><br><span class="line">[root@localhost ~]# chgrp testgroup install.log</span><br><span class="line">chgrp: invaild group name &#x27;testgroup&#x27;</span><br></pre></td></tr></table></figure><p>可以看到，在具有 group1 群组的前提下，我们成功修改了 install.log 文件的所属组，但我们再次试图将所属组修改为 testgroup 时，命令执行失败，就是因为系统的 /etc/group 文件中，没有 testgroup 群组。</p><h3 id="chattr-修改文件系统的权限属性">chattr 修改文件系统的权限属性</h3><p>管理 Linux 系统中的文件和目录，除了可以设定普通权限和特殊权限外，还可以利用文件和目录具有的一些隐藏属性。</p><p>chattr 命令，专门用来修改文件或目录的隐藏属性，<font style="color:red">只有 root 用户可以使用</font>。</p><p>📌<strong>chattr命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [-options] group file</span><br></pre></td></tr></table></figure><blockquote><p>+ 表示给文件或目录添加属性，- 表示移除文件或目录拥有的某些属性，= 表示给文件或目录设定一些属性。</p></blockquote><p>📌<strong>选项</strong>：</p><table><caption>chattr 命令常用的属性选项及功能</caption><tbody><tr><th>属性选项</th><th>功能</th></tr><tr><td>-i</td><td>如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；<br>如果对目录设置 i 属性，那么只能修改目录下文件中的数据，但不允许建立和删除文件；</td></tr><tr><td>-a</td><td>如果对文件设置 a 属性，那么只能在文件中増加数据，但是不能删除和修改数据；<br>如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除文件；</td></tr><tr><td>-u</td><td>设置此属性的文件或目录，在删除时，其内容会被保存，以保证后期能够恢复，常用来防止意外删除文件或目录。</td></tr><tr><td>-s</td><td>和 u 相反，删除文件或目录时，会被彻底删除（直接从硬盘上删除，然后用 0 填充所占用的区域），不可恢复。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>给文件赋予 i 属性</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch ftest</span></span><br><span class="line"><span class="comment">#建立测试文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chattr +i ftest</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf ftest</span></span><br><span class="line"><span class="built_in">rm</span>:cannot remove <span class="string">&#x27;ftest&#x27;</span>:Operation not permitted</span><br><span class="line"><span class="comment">#无法删除&quot;ftesr&quot;，操作不允许</span></span><br><span class="line"><span class="comment">#被赋予i属性后，root不能删除</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo 111&gt;&gt;ftest</span></span><br><span class="line">bash:ftest:Permission denied</span><br><span class="line"><span class="comment">#权限不够，不能修改文件中的数据</span></span><br></pre></td></tr></table></figure><p>可以看到，设置有 i 属性的文件，即便是 root 用户，也无法删除和修改数据。</p></li><li><p>为目录赋予 i 属性</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir dtest</span></span><br><span class="line"><span class="comment">#建立测试目录</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># touch dtest/abc</span></span><br><span class="line"><span class="comment">#再建立一个测试文件abc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chattr +i dtest</span></span><br><span class="line"><span class="comment">#给目录赋予i属性</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd dtest</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># touch bed</span></span><br><span class="line"><span class="built_in">touch</span>: cannot <span class="built_in">touch</span> <span class="string">&#x27;bed&#x27;</span>:Permission denied</span><br><span class="line"><span class="comment">#无法创建&quot;bcd&quot;，权限不够，dtest目录不能新建文件</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># echo 11&gt;&gt;abc</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># cat abc</span></span><br><span class="line">11</span><br><span class="line"><span class="comment">#可以修改文件内容</span></span><br><span class="line">[root@localhost dtest]<span class="comment"># rm -rf abc</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;abc&#x27;</span>: Permission denied</span><br><span class="line"><span class="comment">#无法删除&quot;abc&quot;，权限不够</span></span><br></pre></td></tr></table></figure><p>一旦给目录设置 i 属性，即使是 root 用户，也无法在目录内部新建或删除文件，但可以修改文件内容。</p><p>给设置有 i 属性的文件删除此属性也很简单，只需将 chattr 命令中 + 改为 - 即可。</p></li><li><p>演示 a 属性的作用。假设有这样一种应用，我们每天自动实现把服务器的日志备份到指定目录，备份目录可设置 a 属性，变为只可创建文件而不可删除。命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /back/log</span></span><br><span class="line"><span class="comment">#建立备份目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chattr +a /back/log</span></span><br><span class="line"><span class="comment">#赋予a属性</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /var/log/messages /back/log</span></span><br><span class="line"><span class="comment">#可以复制文件和新建文件到指定目录中</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf /back/log/messages</span></span><br><span class="line"><span class="built_in">rm</span>: cannot remove <span class="string">&#x27;/back/log/messages&#x27;</span>: Permission denied</span><br><span class="line"><span class="comment">#无法删除 /back/log/messages，操作不允许</span></span><br></pre></td></tr></table></figure><p>注意，通常情况下，不要使用 chattr 命令修改 <code>/</code>、<code>/dev/</code>、<code>/tmp/</code>、<code>/var/</code> 等目录的隐藏属性，很容易导致系统无法启动。另外，chatrr 命令常与 lsattr 命令合用，前者修改文件或目录的隐藏属性，后者用于查看是否修改成功。</p></li></ol><h3 id="lsattr-查看特殊权限">lsattr 查看特殊权限</h3><p>lsattr 命令，用于显示文件或目录的隐藏属性。使用 chattr 命令配置文件或目录的隐藏属性后，可以使用 lsattr 命令查看。</p><p>📌<strong>lsattr命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr [-options] filename</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>后面不带文件或目录名，表示显示所有文件和目录（包括隐藏文件和目录）</td></tr><tr><td>-d</td><td>如果目标是目录，只会列出目录本身的隐藏属性，而不会列出所含文件或子目录的隐藏属性信息；</td></tr><tr><td>-R</td><td>和 -d 恰好相反，作用于目录时，会连同子目录的隐藏信息数据也一并显示出来。</td></tr></tbody></table><h3 id="sudo-以其他用户身份执行命令">sudo 以其他用户身份执行命令</h3><p>💾<u><code>/etc/sudoers</code></u></p><p>Linux sudo（execute a command as another user）命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p><p>⚠️注意：对于ubuntu平台，只能通过sudo su进入root账号。</p><p>su 命令可以让普通用户切换到 root 身份去执行某些特权命令，但存在一些问题，比如说：</p><ul><li>仅仅为了一个特权操作就直接赋予普通用户控制系统的完整权限；</li><li>当多人使用同一台主机时，如果大家都要使用 su 命令切换到 root 身份，那势必就需要 root 的密码，这就导致很多人都知道 root 的密码；</li></ul><p>考虑到使用 su 命令可能对系统安装造成的隐患，最常见的解决方法是使用 sudo 命令，此命令也可以让你切换至其他用户的身份去执行命令。</p><p>📌<strong>sudo命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo [-options] <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>将后续的命令放到背景中让系统自行运行，不对当前的 shell 环境产生影响</td></tr><tr><td>-u UserName</td><td>后面可以接欲切换的用户名，若无此项则代表切换身份为 root</td></tr><tr><td>-l</td><td>此选项的用法为 sudo -l，用于显示当前用户可以用 sudo 执行那些命令</td></tr></tbody></table><p>📌<strong>sudo命令的配置文件</strong>：</p><p>修改 <code>/etc/sudoers</code>，不建议直接使用 vim，而是使用 visudo。因为修改 <code>/etc/sudoers</code> 文件需遵循一定的语法规则，使用 visudo 的好处就在于，当修改完毕 <code>/etc/sudoers</code> 文件，离开修改页面时，系统会自行检验 <code>/etc/sudoers</code> 文件的语法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># visudo</span></span><br><span class="line">…省略部分输出…</span><br><span class="line">root ALL=(ALL) ALL  &lt;--大约 76 行的位置</span><br><span class="line"><span class="comment">#用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span></span><br><span class="line"><span class="comment"># %wheel ALL=(ALL) ALL   &lt;--大约84行的位置</span></span><br><span class="line"><span class="comment"># %组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span></span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><table><thead><tr><th>模块</th><th>含义</th></tr></thead><tbody><tr><td>用户名或群组名</td><td>表示系统中的那个用户或群组，可以使用 sudo 这个命令。</td></tr><tr><td>被管理主机的地址</td><td>用户可以管理指定 IP 地址的服务器。这里如果写 ALL，<br>则代表用户可以管理任何主机；如果写固定 IP，则代表用户可以管理指定的服务器。<br>如果我们在这里写本机的 IP 地址，不代表只允许本机的用户使用指定命令，<br>而是代表指定的用户可以从任何 IP 地址来管理当前服务器。</td></tr><tr><td>可使用的身份</td><td>就是把来源用户切换成什么身份使用，（ALL）代表可以切换成任意身份。这个字段可以省略。</td></tr><tr><td>授权命令</td><td>表示 root 把什么命令命令授权给用户，换句话说，可以用切换的身份执行什么命令。需要注<br>意的是，此命令必须使用绝对路径写。默认值是 ALL，表示可以执行任何命令。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>本例中，无法使用sshd登入。 su - sshd 的方式成功切换到 sshd 账户中，因为此用户的默认 Shell 是 /sbin/nologin。这时就显现出 sudo 的优势，我们可以使用 sudo 以 sshd 的身份在 /tmp 目录下创建 mysshd 文件，可以看到，新创建的 mysshd 文件的所有者确实是 sshd。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  grep sshd /etc/passwd</span></span><br><span class="line">sshd:x:74:74:privilege-separated SSH:/var/empty/sshd:/sbin.nologin</span><br><span class="line">[root@localhost ~]<span class="comment">#  sudo -u sshd touch /tmp/mysshd</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  ll /tmp/mysshd</span></span><br><span class="line">-rw-r--r-- 1 sshd sshd 0 Feb 28 17:42 /tmp/mysshd</span><br></pre></td></tr></table></figure><h2 id="文件和目录管理">文件和目录管理</h2><h3 id="cd-切换工作目录">cd 切换工作目录</h3><p>Linux cd（英文全拼：change directory）命令用于切换当前工作目录。</p><p>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。另外，<strong>~</strong> 也表示为 home 目录 的意思， <strong>.</strong> 则是表示目前所在的目录， <strong>…</strong> 则表示目前目录位置的上一层目录。</p><p>📌<strong>cd命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dirName</span><br></pre></td></tr></table></figure><p>📌<strong>cd的常用命令</strong>：</p><p>cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。Linux所有的目录和文件名大小写敏感。</p><table><thead><tr><th align="left">命令</th><th>含义</th></tr></thead><tbody><tr><td align="left">cd</td><td>相当于cd ~</td></tr><tr><td align="left">cd ~</td><td>切换到当前用户的主目录(/home/用户目录)</td></tr><tr><td align="left">cd .</td><td>切换到当前目录</td></tr><tr><td align="left">cd ..</td><td>切换到上级目录</td></tr><tr><td align="left">cd -</td><td>进入上次所在的目录</td></tr></tbody></table><h3 id="pwd-显示绝对路径">pwd 显示绝对路径</h3><p>📌<strong>pwd命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>pwd参数</strong>：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-L</code>：<code>–logical</code></td><td>显示当前的路径，有连接文件时，直接显示连接文件的路径(不加参数时默认此方式)。</td></tr><tr><td><font style="color:red"><code>-p</code>：<code>–physical</code></font></td><td>显示当前的路径，有连接文件时，不使用连接路径，直接显示连接文件所指向的文件。<br>当包含多层连接文件时，显示连接文件最终指向的文件</td></tr></tbody></table><h3 id="ls-列出目录的内容">ls 列出目录的内容</h3><p>Linux ls（英文全拼： list directory contents）命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</p><p>Linux文件或者目录名称最长可以有265个字符，<code>.</code>代表当前目录，<code>…</code>代表上一级目录，以<code>.</code>开头的文件为隐藏文件，需要用 <code>-a</code> 参数才能显示。</p><p>📌<strong>ls命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> [-options] [file|path]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><span style="color:red">-a</span></td><td>显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)</td></tr><tr><td><span style="color:red">-l</span></td><td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出（等同于<code>ll</code>）</td></tr><tr><td>-r</td><td>将文件以相反次序显示(原定依英文字母次序)</td></tr><tr><td>-t</td><td>将文件依建立时间之先后次序列出</td></tr><tr><td><span style="color:red">-h</span></td><td>配合 -l 以人性化的方式显示文件大小</td></tr><tr><td>-A</td><td>同 -a ，但不列出 “.” (目前目录) 及 “…” (父目录)</td></tr><tr><td>-F</td><td>在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/”</td></tr><tr><td>-R</td><td>若目录下有文件，则以下之文件亦皆依序列出</td></tr></tbody></table><p>📌<strong>ls支持通配符</strong>：</p><table><thead><tr><th align="left">通配符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">文件代表文件名中所有字符</td></tr><tr><td align="left">ls te*</td><td align="left">查找以te开头的文件</td></tr><tr><td align="left">ls *html</td><td align="left">查找结尾为html的文件</td></tr><tr><td align="left">？</td><td align="left">代表文件名中任意一个字符</td></tr><tr><td align="left">ls ?.c</td><td align="left">只找第一个字符任意，后缀为.c的文件</td></tr><tr><td align="left">ls a.?</td><td align="left">只找只有3个字符，前2字符为a.，最后一个字符任意的文件</td></tr><tr><td align="left">[]</td><td align="left">[”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。</td></tr><tr><td align="left">[abc]</td><td align="left">匹配a、b、c中的任意一个</td></tr><tr><td align="left">[a-f]</td><td align="left">匹配从a到f范围内的的任意一个字符</td></tr><tr><td align="left">ls [a-f]*</td><td align="left">找到从a到f范围内的的任意一个字符开头的文件</td></tr><tr><td align="left">ls a-f</td><td align="left">查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用</td></tr><tr><td align="left">\</td><td align="left">如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?”和“*”处于方括号内时不用使用转义字符就失去通配符的作用。</td></tr><tr><td align="left">ls \*a</td><td align="left">查找文件名为*a的文件</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ll -h</span></span><br><span class="line">total 24K</span><br><span class="line">-rw-r--r-- 1 root root 1.6K Dec  1  2016 CentOS7-Base-163.repo.1</span><br><span class="line">-rw-r--r-- 1 root root 6.0K Nov 12  2015 mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">-rw-r--r-- 1 root root   90 Nov 23 10:26 passwd</span><br><span class="line">drwxr-xr-t 2 root root 4.0K Nov 22 21:15 <span class="built_in">test</span></span><br><span class="line">-rw-r--r-- 1 root root  276 Nov 24 10:01 user</span><br><span class="line">lrwxrwxrwx 1 root root   14 Nov  6 19:18 web -&gt; /var/www/html/</span><br></pre></td></tr></table></figure><p>列出的信息的含义：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/ccff78bd3a3c92ac11636923216ce3ed.png" alt="ls"></p><h3 id="stat-显示inode的内容">stat 显示inode的内容</h3><p>stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。</p><p>📌<strong>stat命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> [-options] file</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-L</td><td align="left">支持符号连接；</td></tr><tr><td align="left">-f</td><td align="left">显示文件系统状态而非文件状态；</td></tr><tr><td align="left">-c</td><td align="left">按照指定格式输出；</td></tr><tr><td align="left">-t</td><td align="left">以简洁方式输出信息；</td></tr><tr><td align="left">–help</td><td align="left">显示指令的帮助信息；</td></tr><tr><td align="left">–version</td><td align="left">显示指令的版本信息。</td></tr></tbody></table><p>📌<strong>查看的信息包括</strong>：</p><ol><li>File：显示文件名</li><li>Size：显示文件大小</li><li>Blocks：文件使用的数据块总数</li><li>IO Block：IO块大小</li><li>regular file：文件类型（常规文件）</li><li>Device：设备编号</li><li>Inode：Inode号</li><li>Links：链接数</li><li>Access：文件的权限</li><li>Gid、Uid：文件所有权的Gid和Uid</li><li>access time：表示我们最后一次访问（仅仅是访问，没有改动）文件的时间</li><li>modify time：表示我们最后一次修改文件的时间</li><li>change time：表示我们最后一次对文件属性改变的时间，包括权限，大小，属性等等</li><li>Birth time : 文件创建时间，crtime，不过据查此属性linux已废弃，目前状态显示结果均为-</li></ol><p>📌<strong>文件的有效格式序列</strong>：</p><table><thead><tr><th align="left">格式符</th><th align="left">格式符说明</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">八进制中的访问权限</td></tr><tr><td align="left">%A</td><td align="left">人类可读形式的访问权</td></tr><tr><td align="left">%b</td><td align="left">分配的块数（请参阅%B）</td></tr><tr><td align="left">%B</td><td align="left">%b报告的每个块的大小（字节）</td></tr><tr><td align="left">%C</td><td align="left">SELinux安全上下文字符串</td></tr><tr><td align="left">%d</td><td align="left">十进制设备编号</td></tr><tr><td align="left">%D</td><td align="left">十六进制的设备编号</td></tr><tr><td align="left">%f</td><td align="left">十六进制原始模式</td></tr><tr><td align="left">%F</td><td align="left">文件类型</td></tr><tr><td align="left">%g</td><td align="left">所有者的组ID</td></tr><tr><td align="left">%G</td><td align="left">所有者的组名称</td></tr><tr><td align="left">%h</td><td align="left">硬链接数</td></tr><tr><td align="left">%i</td><td align="left">inode数</td></tr><tr><td align="left">%m</td><td align="left">挂载点</td></tr><tr><td align="left">%n</td><td align="left">文件名</td></tr><tr><td align="left">%N</td><td align="left">带取消引用（如果是符号链接）的带引号的文件名</td></tr><tr><td align="left">%o</td><td align="left">最佳I/O传输大小提示</td></tr><tr><td align="left">%s</td><td align="left">总大小，以字节为单位</td></tr><tr><td align="left">%t</td><td align="left">主要设备类型（十六进制），用于字符/块设备特殊文件</td></tr><tr><td align="left">%T</td><td align="left">次要设备类型（十六进制），用于字符/块设备特殊文件</td></tr><tr><td align="left">%u</td><td align="left">所有者的用户ID</td></tr><tr><td align="left">%U</td><td align="left">所有者的用户名</td></tr><tr><td align="left">%w</td><td align="left">文件出生时间，人类可读；-如果未知</td></tr><tr><td align="left">%W</td><td align="left">文件生成时间，自纪元起的秒数；如果未知，则为0</td></tr><tr><td align="left">%x</td><td align="left">最后一次访问的时间，人类可读</td></tr><tr><td align="left">%X</td><td align="left">上次访问的时间，自纪元起的秒数</td></tr><tr><td align="left">%y</td><td align="left">上次修改的时间，人类可读</td></tr><tr><td align="left">%Y</td><td align="left">上次修改的时间，自纪元起的秒数</td></tr><tr><td align="left">%z</td><td align="left">最后更改的时间，人类可读</td></tr><tr><td align="left">%Z</td><td align="left">上次更改的时间，自新纪元起的秒数</td></tr></tbody></table><p>📌<strong>文件系统的有效格式序列</strong>：</p><table><thead><tr><th align="left">格式符</th><th align="left">格式符说明</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">非超级用户可用的空闲块</td></tr><tr><td align="left">%b</td><td align="left">文件系统中的数据块总数</td></tr><tr><td align="left">%c</td><td align="left">文件系统中的文件节点总数</td></tr><tr><td align="left">%d</td><td align="left">文件系统中的空闲文件节点</td></tr><tr><td align="left">%f</td><td align="left">文件系统中的空闲块</td></tr><tr><td align="left">%i</td><td align="left">十六进制文件系统ID</td></tr><tr><td align="left">%l</td><td align="left">文件名的最大长度</td></tr><tr><td align="left">%n</td><td align="left">文件名</td></tr><tr><td align="left">%s</td><td align="left">块大小（用于更快的传输）</td></tr><tr><td align="left">%S</td><td align="left">基本块大小（用于块计数）</td></tr><tr><td align="left">%t</td><td align="left">十六进制文件系统类型</td></tr><tr><td align="left">%T</td><td align="left">人类可读形式的文件系统类型</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># stat mysql-community-release-el7-5.noarch.rpm </span></span><br><span class="line">  File: ‘mysql-community-release-el7-5.noarch.rpm’</span><br><span class="line">  Size: 6140            Blocks: 16         IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 394398      Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2019-11-23 13:30:42.000000000 +0800</span><br><span class="line">Modify: 2015-11-12 15:58:42.000000000 +0800</span><br><span class="line">Change: 2019-11-23 13:30:42.400300171 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line">python@ubuntu:~/txt$ <span class="built_in">stat</span> find我的Mr.Right.txt </span><br><span class="line">  文件：<span class="string">&#x27;find我的Mr.Right.txt&#x27;</span></span><br><span class="line">  大小：64768           块：128        IO 块：4096   普通文件</span><br><span class="line">设备：801h/2049d        Inode：655501      硬链接：1</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid：( 1000/  python)   Gid：( 1000/  python)</span><br><span class="line">最近访问：2019-11-22 22:43:17.565105155 +0800</span><br><span class="line">最近更改：2019-11-22 22:42:42.000000000 +0800</span><br><span class="line">最近改动：2019-11-22 22:43:08.797116491 +0800</span><br><span class="line">创建时间：-</span><br></pre></td></tr></table></figure><h3 id="mkdir-创建一个新的目录">mkdir 创建一个新的目录</h3><p>Linux mkdir（英文全拼：make directory）命令用于创建目录。</p><p>📌<strong>mkdir命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [-options] dirName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><span style="color:red"><code>-p</code>：<code>--parents</code></span></td><td>如果目录不存在，根据需要创建父级目录</td></tr><tr><td><span style="color:red"><code>-m</code>：<code>--mode=MODE</code></span></td><td>设置文件模式(chmod)</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过程</td></tr><tr><td><code>-Z</code></td><td>创建目录的SELinux安全设置为默认类型</td></tr></tbody></table><h3 id="rmdir-删除一个空的目录">rmdir 删除一个空的目录</h3><p>Linux rmdir（英文全拼：remove directory）。rmdir 命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意：rm - r dir 命令可代替rmdir，但是有很大危险性）删除某目录时也必须具有对父目录的写权限。</p><p>📌<strong>rkdir命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmkdir [-options] dirName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><span style="color:red"><code>-p</code>：<code>--parents</code></span></td><td>删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除</td></tr><tr><td><code>--ignore-fail-on-non-empty</code></td><td>忽略非空目录的错误信息</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过程</td></tr></tbody></table><h3 id="rm-删除文件或目录">rm 删除文件或目录</h3><p>可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。</p><p>📌<strong>rm命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> [-options] name</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><span style="color:red"><code>-f</code></span></td><td>忽略不存在的文件和参数，不要提示</td></tr><tr><td><code>-i</code></td><td>每次删除前都会提示</td></tr><tr><td><span style="color:red"><code>-r</code></span></td><td>递归地删除目录及其内容</td></tr><tr><td><code>-d</code></td><td>删除空目录</td></tr><tr><td><code>-v</code></td><td>列出详细信息</td></tr></tbody></table><h3 id="touch-创建空文件">touch 创建空文件</h3><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>📌<strong>touch命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> [-options] name</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>只更改访问时间</td></tr><tr><td><code>-c</code>：<code>--no-create</code></td><td>不创建任何文件</td></tr><tr><td><code>-d</code>：<code>--date=字符串</code></td><td>使用指定字符串表示时间而非当前时间</td></tr><tr><td><code>-h</code>：<code>--no-dereference</code></td><td>会影响符号链接本身，而非符号链接所指示的目的地<br>(当系统支持更改符号链接的所有者时，此选项才有用)</td></tr><tr><td><code>-m</code></td><td>只更改修改时间</td></tr><tr><td><code>-r</code>：<code>--reference=FILE</code></td><td>使用file文件的时间戳（access、modify）更新文件的时间戳</td></tr><tr><td><code>-t</code></td><td>设定档案的时间记录，格式与 date 指令相同</td></tr></tbody></table><h3 id="mv-移动文件、目录或重命名">mv 移动文件、目录或重命名</h3><p>📌<strong>mv命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> [-options] <span class="built_in">source</span> directory</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-b</code></td><td>目标文件或目录存在时，在执行覆盖前，会为其创建一个备份</td></tr><tr><td><code>-i</code></td><td>如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作</td></tr><tr><td><code>-f</code></td><td>如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件</td></tr><tr><td><code>-n</code></td><td>不要覆盖任何已存在的文件或目录</td></tr><tr><td><code>-u</code></td><td>当源文件比目标文件新或者目标文件不存在时，才执行移动操作</td></tr></tbody></table><h3 id="cp-复制文件或目录">cp 复制文件或目录</h3><p>Linux cp（英文全拼：copy file）命令主要用于复制文件或目录。</p><p>📌<strong>cp命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [-options] <span class="built_in">source</span> directory</span><br></pre></td></tr></table></figure><blockquote><ul><li>source ：拷贝的文件</li><li>directory：拷贝到的路径</li></ul></blockquote><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>相当于 <code>-pdr</code> ，此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容</td></tr><tr><td><code>-d</code></td><td>复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式</td></tr><tr><td><code>-f</code></td><td>覆盖已经存在的目标文件而不给出提示</td></tr><tr><td><code>-i</code></td><td>与 <strong>f</strong> 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 <strong>y</strong> 时目标文件将被覆盖</td></tr><tr><td><code>-p</code></td><td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td><font style="color:red"><code>-r</code></font></td><td>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</td></tr><tr><td><code>-l</code></td><td>不复制文件，只是生成链接文件</td></tr></tbody></table><h3 id="ln-建立一个同步的链接">ln 建立一个同步的链接</h3><p>Linux ln（英文全拼：link files）命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p><p>📌<strong>ln命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> [optians] 源目录或目录 目标文件或目录</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-b</code>：<code>--backup</code></td><td>删除，覆盖目标文件之前的备份。</td></tr><tr><td><code>-d</code>：<code>-F</code>或<code>--directory</code></td><td>建立目录的硬连接。</td></tr><tr><td><code>-f</code>：<code>--force</code></td><td>强行建立文件或目录的连接，不论文件或目录是否存在。</td></tr><tr><td><code>-i</code>：<code>--interactive</code></td><td>覆盖既有文件之前先询问用户。</td></tr><tr><td><code>-n</code>：<code>--no-dereference</code></td><td>把符号连接的目的目录视为一般文件。</td></tr><tr><td><font style="color:red"><code>-s</code>：<code>--symbolic</code></font></td><td>对源文件建立软链接(符号连接)，而非硬连接。</td></tr><tr><td><code>-S&lt;字尾备份字符串&gt;</code>：<code>--suffix=&lt;字尾备份字符串&gt;</code></td><td>用&quot;-b&quot;参数备份目标文件后，<br>备份文件的字尾会被加上一个备份字符串，<br>预设的字尾备份字符串是符号&quot;~“，可通过”-S&quot;参数来改变它。</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示指令执行过程。</td></tr><tr><td><code>-V&lt;备份方式&gt;</code>：<code>--version-control=&lt;备份方式&gt;</code></td><td>用&quot;-b&quot;参数备份目标文件后，<br>备份文件的字尾会被加上一个备份字符串，<br>这个字符串不仅可用&quot;-S&quot;参数</td></tr></tbody></table><h3 id="find-查找文件或者目录">find 查找文件或者目录</h3><p>💾<u><code>/bin/find</code></u> 🔗<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/779.html">Linux find命令：在目录中查找文件（超详解）</a></p><p>find 是 Linux 中强大的搜索命令，不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode 号等来搜索文件。但是 find 命令是直接在硬盘中进行搜索的，如果指定的搜索范围过大，find命令就会消耗较大的系统资源，导致服务器压力过大。所以，在使用 find 命令搜索时，不要指定过大的搜索范围。</p><p>📌<strong>find命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [path] [expression] [[搜索内容][处理动作]]</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>path：查找开始的位置，为空字符串则为当前路径 <code>./</code> 。</p></li><li><p>expression：查找条件，如果为空字符串则使用 <code>-print</code> 为预设 。</p></li></ul></blockquote><p>📌<strong>选项</strong>：</p><table><thead><tr><th>查找条件</th><th>说明</th></tr></thead><tbody><tr><td><code>-amin n</code></td><td>在过去 n 分钟内被读取过</td></tr><tr><td><code>-anewer file</code></td><td>比文件 file 更晚被读取过的文件</td></tr><tr><td><code>-atime [[][+][-]]time</code></td><td>空字符：表示在前 n~n+1 天内读取过的文件;<br>+n：代表 n 天前读取的文件<br>-n：代表 n 天内读取的文件</td></tr><tr><td><code>-cmin n</code></td><td>在过去 n 分钟内被修改过</td></tr><tr><td><code>-cnewer file</code></td><td>比文件 file 更新的文件</td></tr><tr><td><code>-ctime [[][+][-]]time</code></td><td>空字符：表示在前 n~n+1 天内创建过的文件;<br>+n：代表 n 天前创建的文件<br>-n：代表 n 天内创建的文件</td></tr><tr><td><code>-empty</code></td><td>空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</td></tr><tr><td><code>-inum</code></td><td>按照 inode 号搜索</td></tr><tr><td><code>-ipath p</code>，<code>-path p</code></td><td>路径名称符合 p 的文件，ipath 会忽略大小写</td></tr><tr><td><code>-mtime [[][+][-]]time</code></td><td>空字符：表示在前 n~n+1 天内修改过的文件;<br>+n：代表 n 天前修改的文件<br>-n：代表 n 天内修改的文件</td></tr><tr><td><code>-mount, -xdev</code></td><td>只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</td></tr><tr><td><font style="color:red"><code>-name name</code>，<code>-iname name</code></font></td><td>文件名称符合 name 的文件。<strong>iname 会忽略大小写</strong></td></tr><tr><td><code>-size [[+][-]]&lt;size&gt;&lt;units&gt;</code></td><td><code>+-</code>：加号表大于（省），减号表小于；<br>size：大小；<br>units：单位 <code>c</code>-Byte,<code>k</code>-kb，<code>M</code>-mb;</td></tr><tr><td><code>-type 类型</code></td><td>b: 区块装置文件<br>c: 字型装置文件<br>d: 查找目录<br>f: 一般文件<br>l: 符号连结<br>p: 具名贮列<br>s: socket</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>将当前目录及其子目录下所有文件后缀为 <strong>.c</strong> 的文件列出来:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># find . -name &quot;*.c&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>将当前目录及其子目录中的所有文件列出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># find . -type f</span></span><br></pre></td></tr></table></figure></li><li><p>将当前目录及其子目录下所有最近 20 天内更新过的文件列出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># find . -ctime  20</span></span><br></pre></td></tr></table></figure></li><li><p>查找 /var/log 目录中更改时间在 7 日以前的普通文件，并在删除之前询问它们：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># find /var/log -type f -mtime +7 -ok rm &#123;&#125; \\;</span></span><br></pre></td></tr></table></figure></li><li><p>查找当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># find . -type f -perm 644 -exec ls -l &#123;&#125; \\;</span></span><br></pre></td></tr></table></figure></li><li><p>查找系统中所有文件长度为 0 的普通文件，并列出它们的完整路径：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># find / -type f -size 0 -exec ls -l &#123;&#125; \\;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="locate-快速定位文件路径">locate 快速定位文件路径</h3><p>Linux locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。<code>locate</code>命令要比<code>find -name</code>快得多，原因在于它不搜索具体目录，而是搜索一个数据库<code>/var/lib/mlocate/mlocate.db</code> 。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，因此，我们在用<code>whereis</code>和<code>locate</code> 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。为了避免这种情况，可以在使用<code>locate</code>之前，先使用<code>updatedb</code>命令，手动更新数据库。整个<code>locate</code>工作其实是由四部分组成的:</p><ol><li><code>/usr/bin/updatedb</code> 主要用来更新数据库，通过crontab自动完成的</li><li><code>/usr/bin/locate</code> 查询文件位置</li><li><code>/etc/updatedb.conf</code> updatedb的配置文件</li><li><code>/var/lib/mlocate/mlocate.db</code> 存放文件信息的文件</li></ol><p>📌<strong>locate安装</strong>：</p><p>CentOS7 默认没有安装该命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mlocate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化文件库</span></span><br><span class="line">updatedb</span><br></pre></td></tr></table></figure><p>📌<strong>locate命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate [-options] [样式]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-f</td><td>将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</td></tr><tr><td>-q</td><td>安静模式，不会显示任何错误讯息。</td></tr><tr><td>-n</td><td>至多显示 n个输出。</td></tr><tr><td>-r</td><td>使用正规运算式 做寻找的条件。</td></tr><tr><td>-o</td><td>指定资料库存的名称。</td></tr><tr><td>-d</td><td>指定资料库的路径</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>搜索etc目录下所有以sh开头的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# locate /etc/sh       </span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/shadow-</span><br><span class="line">/etc/shells</span><br><span class="line">[root@localhost ~]# locate -r &quot;/etc/\sh &quot;  # 正则，锚定词首</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/shadow-</span><br><span class="line">/etc/shells</span><br></pre></td></tr></table></figure></li><li><p>忽略大小写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# locate -i ~/d</span><br><span class="line">/root/Desktop/root/Documents/root/Downloads</span><br><span class="line">/root/d1</span><br><span class="line">/root/dd</span><br><span class="line">/var/lib/pcp/pmdas/root/domain.h</span><br></pre></td></tr></table></figure></li><li><p>更新数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# locate ~/a</span><br><span class="line">/root/anaconda-ks.cfg</span><br><span class="line">[root@localhost ~]# updatedb</span><br><span class="line">[root@localhost ~]# locate ~/a</span><br><span class="line">/root/a.sh</span><br><span class="line">/root/anaconda-ks.cfg</span><br></pre></td></tr></table></figure></li></ol><h3 id="which-查看命令位置">which 查看命令位置</h3><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p><p>📌<strong>which命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> [-options] programname</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n&lt;文件名长度&gt;</td><td>指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；</td></tr><tr><td>-p&lt;文件名长度&gt;</td><td>与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径；</td></tr><tr><td>-w</td><td>指定输出时栏位的宽度</td></tr></tbody></table><h3 id="scp-安全拷贝">scp 安全拷贝</h3><p>secure copy (remote file copy program)，意思安全拷贝，安全复制的意思，是一个远程文件复制程序。准确来说就是不同服务器之间进行文件（包括目录）进行安全复制的命令。scp基于加州大学Regents的BSD源代码中的rcp程序。</p><p>📌<strong>scp命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [option] /path/to/source/file user@server-ip:/path/to/destination/directory</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">-C</td><td style="text-align:center">这会在复制过程中压缩文件或目录;</td></tr><tr><td style="text-align:center">-P</td><td style="text-align:center">如果默认 SSH 端口不是 22，则使用此选项指定 SSH 端口;</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:center">此选项递归复制目录及其内容;</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">保留文件的访问和修改时间。</td></tr></tbody></table><h3 id="source-执行脚本">source 执行脚本</h3><p>source命令也称为“点命令”，也就是一个点符号（.），是bash的内部命令。</p><p>本章节主要说明的是用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。因为linux所有的操作都会变成文件的格式存储。</p><p>关于“source filename”与“sh filename”、“./filename”这三个命令的区别，请戳 shell 编程篇。</p><p>📌<strong>source命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> filename		<span class="comment"># filename必须是可执行的脚本文件</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">. filename 			<span class="comment"># 注意“.”号后面还有一个空格</span></span><br></pre></td></tr></table></figure><hr><h2 id="文本处理">文本处理</h2><h3 id="echo-输出内容到控制台">echo 输出内容到控制台</h3><p>Linux中 echo命令主要用于打印字符或者回显，一般起到一个提示的作用。</p><p>📌<strong>echo命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> [options] <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>不在最后自动换行</td></tr><tr><td>-e</td><td>使用-e扩展参数选项时，与如下参数一起使用，有不同含义，支持反斜线控制的字符转换</td></tr></tbody></table><p>📌<strong>-e的参数</strong>：</p><table><tr><td>-e的参数</td><td>说明</td></tr><tr><td>\a</td><td>发出警告声</td></tr><tr><td>\c</td><td>最后不加上换行符号</td></tr><tr><td>\f</td><td>换行但光标仍旧停留在原来的位置</td></tr><tr><td>\n</td><td>换行且光标移至行首</td></tr><tr><td>\r</td><td>光标移至行首，但不换行</td></tr><tr><td>\t</td><td>制表符，也就是Tab键</td></tr><tr><td>\v</td><td>与\f相同</td></tr><tr><td>\\</td><td>插入\字符</td></tr><tr><td colspan="2">\033[30m 黑色字 \033[0m</td></tr><tr><td colspan="2">\033[31m 红色字 \033[0m</td></tr><tr><td colspan="2">\033[32m 绿色字 \033[0m</td></tr><tr><td colspan="2">\033[33m 黄色字 \033[0m</td></tr><tr><td colspan="2">\033[34m 蓝色字 \033[0m</td></tr><tr><td colspan="2">\033[35m 紫色字 \033[0m</td></tr><tr><td colspan="2">\033[36m 天蓝字 \033[0m</td></tr><tr><td colspan="2">\033[37m 白色字 \033[0m</td></tr><tr><td colspan="2">\033[40;37m 黑底白字 \033[0m</td></tr><tr><td colspan="2">\033[41;37m 红底白字 \033[0m</td></tr><tr><td colspan="2">\033[42;37m 绿底白字 \033[0m</td></tr><tr><td colspan="2">\033[43;37m 黄底白字 \033[0m</td></tr><tr><td colspan="2">\033[44;37m 蓝底白字 \033[0m</td></tr><tr><td colspan="2">\033[45;37m 紫底白字 \033[0m</td></tr><tr><td colspan="2">\033[46;37m 天蓝底白字 \033[0m</td></tr><tr><td colspan="2">\033[47;30m 白底黑字 \033[0m</td></tr></table><h3 id="printf-格式化输出">printf 格式化输出</h3><p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p><p>标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p><p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。<strong>默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n</strong>。</p><p>📌<strong>printf命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>  format-string  [arguments...]</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>format-string:</strong> 为格式控制字符串</li><li><strong>arguments:</strong> 为参数列表。</li></ul></blockquote><p>📌<strong>printf的转义序列</strong>：</p><table class="reference"><tbody><tr><th>序列</th><th>说明</th></tr><tr><td>\a</td><td>警告字符，通常为 ASCII 的 BEL 字符</td></tr><tr><td>\b</td><td>后退</td></tr><tr><td>\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在 %b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td>\f</td><td>换页（formfeed）</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车（Carriage return）</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\\</td><td>一个字面上的反斜杠字符</td></tr><tr><td>\ddd</td><td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td>\0ddd</td><td>表示 1 到 3 位的八进制值字符</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>我来用一个脚本来体现 printf 的强大功能：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4s\n&quot;</span> 姓名 性别 体重kg  </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 杨过 男 48.6543 </span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭芙 女 47.9876 </span><br><span class="line"></span><br><span class="line"><span class="comment">#结果:</span></span><br><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br></pre></td></tr></table></figure><blockquote><p>%s %c %d %f都是格式替代符</p><p>%-10s 指一个宽度为 10 个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p><p>%-4.2f 指格式化为小数，其中 .2 指保留 2 位小数。</p></blockquote><h3 id="cat-查看文件内容">cat 查看文件内容</h3><p>cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。<strong>由第一行开始显示文件内容</strong>。</p><p>📌<strong>cat命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [-options] fileName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-A</code>：<code>--show-all</code>：<code>-vET</code></td><td>相当于 -vET 选项的整合，用于列出所有隐藏符号；</td></tr><tr><td><code>-E</code>：<code>--show-ends</code></td><td>列出每行结尾的回车符 $；</td></tr><tr><td><font style="color:red"><code>-n</code></font>：<code>--number</code></td><td>对输出的所有行进行编号；</td></tr><tr><td><code>-b</code>：<code>--number-nonblank</code></td><td>同 -n 不同，此选项表示只对非空行进行编号。</td></tr><tr><td><code>-T</code>：<code>--show-tabs</code></td><td>把 Tab 键 ^I 显示出来；</td></tr><tr><td><code>-V</code></td><td>列出特殊字符；</td></tr><tr><td><code>-s</code>：<code>--squeeze-blank</code></td><td>当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat -n textfile1 &gt; textfile2</span><br></pre></td></tr></table></figure></li><li><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat -b textfile1 textfile2 &gt;&gt; textfile3</span><br></pre></td></tr></table></figure></li><li><p>清空 /etc/test.txt 文档内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /dev/null &gt; /etc/test.txt</span><br></pre></td></tr></table></figure></li><li><p>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /dev/fd0 &gt; OUTFILE</span><br></pre></td></tr></table></figure><p>相反的，如果想把 image file 写到软盘，输入：(通常用制作开机磁片)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat IMG_FILE &gt; /dev/fd0</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>OUTFILE 指输出的镜像文件名。</p></li><li><p>IMG_FILE 指镜像文件。</p></li><li><p>若从镜像文件写回 device 时，device 容量需与相当。</p></li></ul></blockquote></li></ol><h3 id="tac-倒序查看文件内容">tac 倒序查看文件内容</h3><p>tac 命令用于按相反顺序逐行连接和打印文件内容。和 cat 命令一样，将每个文件连接到标准输出，但顺序相反，逐行打印，首先打印最后一行。<strong>从最后一行开始显示</strong>。</p><p>📌<strong>tac命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tac</span> [-options] fileName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>在行前而非行尾添加分隔标志；</td></tr><tr><td>-r</td><td>将分隔标志视作正则表达式来解析；</td></tr><tr><td>-s</td><td>使用指定字符串代替换行作为分隔标志。</td></tr></tbody></table><h3 id="nl-计算文件的行号">nl 计算文件的行号</h3><p>nl（英文全拼：number of lines）<code>nl</code>可以将输出的文件自动加上行号。其默认的结果与<code>cat -n</code>有点不太一样,<code>nl</code>可以自定义行号显示效果,包括位数和自动补全0。</p><p>📌<strong>nl命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span> [-options] fileName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>指定行号指定的方式，主要有两种<br>-b a ：表示无论是否为空行，也同样列出行号(类似 cat -n)<br>-b t：表示有空行，空的那一行不要列出行号(默认值)；</td></tr><tr><td>-n</td><td>列出行号表示的方法，主要有三种<br>-n ln ：行号在萤幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</td></tr><tr><td>-w</td><td>行号栏位的占用的位数；</td></tr><tr><td>-p</td><td>在逻辑定界符处不重新开始计算。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>输出如下(文件中有空白行)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nl log2018.log</span></span><br><span class="line">     1	2018-01</span><br><span class="line">     2	2018-02</span><br><span class="line">     3	2018-03</span><br><span class="line">     4	2018-04</span><br><span class="line"> </span><br><span class="line">     5	2018-05</span><br><span class="line">     6	2018-06</span><br><span class="line">     7	2018-07</span><br><span class="line">     8	2018-08</span><br><span class="line">     9	2018-09</span><br><span class="line">    10	2018-10</span><br></pre></td></tr></table></figure><p>说明：文件中的空白行，nl 不会加上行号。</p></li><li><p>用 nl 列出 log2018.log 的内容，空白行也加上行号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nl -b a log2018.log</span></span><br><span class="line">     1	2018-01</span><br><span class="line">     2	2018-02</span><br><span class="line">     3	2018-03</span><br><span class="line">     4	2018-04</span><br><span class="line">     5</span><br><span class="line">     6</span><br><span class="line">     7	2018-05</span><br><span class="line">     8	2018-06</span><br><span class="line">     9	2018-07</span><br><span class="line">    10	2018-08</span><br><span class="line">    11	2018-09</span><br><span class="line">    12	2018-10</span><br></pre></td></tr></table></figure></li></ol><h3 id="more-文件内容分屏查看器">more 文件内容分屏查看器</h3><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p><p>📌<strong>more命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [-options] fileName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>+n</td><td>从笫n行开始显示</td></tr><tr><td>-n</td><td>定义屏幕显示n行为一屏</td></tr><tr><td>+/字符串</td><td>在每个档案显示前搜寻该字串，然后从该字串前两行之后开始显示</td></tr><tr><td>-c</td><td>先清屏，然后显示要查看的文件或日志内容</td></tr><tr><td>-d</td><td>在显示内空中添加提示 “Press space to continue，’q’ to quit(按空格键继续，按q键退出)”，禁用响铃功能</td></tr><tr><td>-p</td><td>通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</td></tr><tr><td>-s</td><td>把连续的多个空行显示为一行</td></tr><tr><td>-u</td><td>把文件内容中的下画线去掉</td></tr></tbody></table><p>📌<strong>操作命令</strong>：</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td>Enter</td><td>向下n行。默认为1行；</td></tr><tr><td>F键 [空格键]</td><td>向下滚动一屏；</td></tr><tr><td>Ctrl+b键</td><td>返回上一屏，不过这动作只对文件有用，对管线无用；</td></tr><tr><td>/字串</td><td>代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</td></tr><tr><td>=</td><td>输出当前行的行号；</td></tr><tr><td>V键</td><td>在使用more查看时，使用v调用vi编辑器；</td></tr><tr><td>!命令</td><td>调用Shell，并执行命令；</td></tr><tr><td>q</td><td>退出more。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># more /etc/man_db.config </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Generated automatically from man.conf.in by the</span></span><br><span class="line"><span class="comment"># configure script.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># man.conf from man-1.6d</span></span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%)  &lt;== 光标在这里等待命令</span><br></pre></td></tr></table></figure><h3 id="less-分屏显示文件内容">less 分屏显示文件内容</h3><p>Linux 中的 less 命令主要用来浏览文件内容，与 more 命令的用法相似，不同于 more 命令的是，less 命令可往回卷动浏览以看过的部分。less 的用法比起 more 更加的有弹性。在 more 的时候,我们并没有办法向前面翻,只能往后面看，但若使用了 less 时，就可以使用 <code>［pageup］</code> <code>［pagedown]</code>等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p><p>📌<strong>less命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [-options] fileName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-N</td><td>显示每行的行号。</td></tr><tr><td>-S</td><td>行过长时将超出部分舍弃。</td></tr><tr><td>-e</td><td>当文件显示结束后，自动离开。</td></tr><tr><td>-g</td><td>只标志最后搜索到的关键同。</td></tr><tr><td>-Q</td><td>不使用警告音。</td></tr><tr><td>-i</td><td>忽略搜索时的大小写。</td></tr><tr><td>-m</td><td>显示类似 more 命令的百分比。</td></tr><tr><td>-f</td><td>强迫打开特殊文件，比如外围设备代号、目录和二进制文件。</td></tr><tr><td>-s</td><td>显示连续空行为一行。</td></tr><tr><td>-b &lt;缓冲区大小&gt;</td><td>设置缓冲区的大小。</td></tr><tr><td>-o &lt;文件名&gt;</td><td>将 less 输出的内容保存到指定文件中。</td></tr><tr><td>-x &lt;数字&gt;</td><td>将【Tab】键显示为规定的数字空格。</td></tr></tbody></table><p>📌<strong>操作命令</strong>：</p><table><thead><tr><th>交互指令</th><th>功能</th></tr></thead><tbody><tr><td><font style="color:red">/字符串</font></td><td>向下搜索“字符串”的功能。</td></tr><tr><td><font style="color:red">?字符串</font></td><td>向上搜索“字符串”的功能。</td></tr><tr><td><font style="color:red">n</font></td><td>重复*前一个搜索（与 / 成 ? 有关）。</td></tr><tr><td><font style="color:red">N</font></td><td>反向重复前一个搜索（与 / 或 ? 有关）。</td></tr><tr><td>b</td><td>向上移动一页。</td></tr><tr><td>d</td><td>向下移动半页。</td></tr><tr><td>h 或 H</td><td>显示帮助界面。</td></tr><tr><td>q 或 Q</td><td>退出 less 命令。</td></tr><tr><td>y</td><td>向上移动一行。</td></tr><tr><td>回车键</td><td>向下移动一行。</td></tr><tr><td><font style="color:red"><code>[space]</code>或 [PgDn] 键</font></td><td>向下移动一页。</td></tr><tr><td><font style="color:red">[PgUp] 键</font></td><td>向上移动一页。</td></tr><tr><td>Ctrl+f</td><td>向下移动一页。</td></tr><tr><td>Ctrl+b</td><td>向上移动一页。</td></tr><tr><td>Ctrl+d</td><td>向下移动一页。</td></tr><tr><td>Ctrl+u</td><td>向上移动半页。</td></tr><tr><td>j</td><td>向下移动一行。</td></tr><tr><td>k</td><td>向上移动一行。</td></tr><tr><td>G</td><td>移动至最后一行。</td></tr><tr><td>g</td><td>移动到第一行。</td></tr><tr><td>v</td><td>使用配置的编辑器编辑当前文件。</td></tr><tr><td>[</td><td>移动到本文档的上一个节点。</td></tr><tr><td>]</td><td>移动到本文档的下一个节点。</td></tr><tr><td>p</td><td>移动到同级的上一个节点。</td></tr><tr><td><font style="color:red">q 或 ZZ</font></td><td>离开 less 这个程序。</td></tr><tr><td>u</td><td>向上移动半页。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>显示已有进程信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ps -ef | less</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 2月16 ?       00:00:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">root          2      0  0 2月16 ?       00:00:00 [kthreadd]</span><br><span class="line">root          4      2  0 2月16 ?       00:00:00 [kworker/0:0H]</span><br><span class="line">...忽略部分数据...</span><br><span class="line">root         15      2  0 2月16 ?       00:00:00 [khungtaskd]</span><br><span class="line">root         16      2  0 2月16 ?       00:00:00 [writeback]</span><br><span class="line">root         17      2  0 2月16 ?       00:00:00 [kintegrityd]</span><br><span class="line">root         18      2  0 2月16 ?       00:00:00 [bioset]</span><br><span class="line">:</span><br></pre></td></tr></table></figure><h3 id="head-输出文件头部内容">head 输出文件头部内容</h3><p>head 命令可用于查看文件的开头部分的内容。</p><p>📌<strong>head命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> [-options] fileName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-c 字节数</code></td><td>显示的字节数</td></tr><tr><td><font style="color:red"><code>-n 行数</code></font></td><td>显示前x行</td></tr><tr><td><code>-q</code></td><td>隐藏文件名</td></tr><tr><td><code>-v</code></td><td>显示文件名</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>默认为显示前10行文件内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># head /etc/yum.conf </span></span><br><span class="line">[main]</span><br><span class="line">cachedir=/var/cache/yum/<span class="variable">$basearch</span>/<span class="variable">$releasever</span></span><br><span class="line">keepcache=0</span><br><span class="line">debuglevel=2</span><br><span class="line">logfile=/var/log/yum.log</span><br><span class="line">exactarch=1</span><br><span class="line">obsoletes=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">plugins=1</span><br><span class="line">installonly_limit=5</span><br></pre></td></tr></table></figure><h3 id="tail-输出文件尾部内容">tail 输出文件尾部内容</h3><p>tail 命令可用于查看文件尾部的内容。</p><p>📌<strong>tail命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> [-options] fileName</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><font style="color:red"><code>-f</code></font></td><td>循环读取，持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</td></tr><tr><td><code>-q</code></td><td>不显示处理信息</td></tr><tr><td><code>-v</code></td><td>显示详细的处理信息</td></tr><tr><td><code>-c 数目</code></td><td>显示的字节数</td></tr><tr><td><font style="color:red"><code>-n 行数</code></font></td><td>显示文件的尾部 n 行内容</td></tr><tr><td><code>--pid=PID</code></td><td>与-f合用,表示在进程ID,PID死掉之后结束</td></tr><tr><td><code>-q</code>：<code>--quiet</code>：<code>--silent</code></td><td>从不输出给出文件名的首部</td></tr><tr><td><code>-s</code>：<code>--sleep-interval=S</code></td><td>与-f合用,表示在每次反复的间隔休眠S秒</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>用管道符号查看历史命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># tail -f | history</span></span><br><span class="line">  ...省略部分数据...</span><br><span class="line">  430  <span class="built_in">tail</span> <span class="built_in">test</span></span><br><span class="line">  431  ps -ef | less</span><br><span class="line">  432  <span class="built_in">head</span> /etc/yum.conf </span><br><span class="line">  433  <span class="built_in">tail</span> <span class="built_in">history</span></span><br><span class="line">  434   ~/.bash_history</span><br><span class="line">  435  <span class="built_in">tail</span>| <span class="built_in">history</span></span><br><span class="line"><span class="built_in">tail</span>: 警告：无限期跟随标准输入是无用的</span><br></pre></td></tr></table></figure></li><li><p>默认为显示后10行文件内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># tail /etc/yum.conf </span></span><br><span class="line"><span class="comment"># download the new metadata and &quot;pay&quot; for it by yum not having correct</span></span><br><span class="line"><span class="comment"># information.</span></span><br><span class="line"><span class="comment">#  It is esp. important, to have correct metadata, for distributions like</span></span><br><span class="line"><span class="comment"># Fedora which don&#x27;t keep old packages around. If you don&#x27;t like this checking</span></span><br><span class="line"><span class="comment"># interupting your command line usage, it&#x27;s much better to have something</span></span><br><span class="line"><span class="comment"># manually check the metadata once an hour (yum-updatesd will do this).</span></span><br><span class="line"><span class="comment"># metadata_expire=90m</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PUT YOUR REPOS HERE OR IN separate files named file.repo</span></span><br><span class="line"><span class="comment"># in /etc/yum.repos.d</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="wc-字数统计">wc 字数统计</h3><p>wc（word count）命令用于统计文件字节、字符、单词与行的数量。</p><p>📌<strong>wc命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> [-options] [file]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c, --bytes</td><td>仅显示字节数</td></tr><tr><td>-m, --chars</td><td>仅显示字符数</td></tr><tr><td>-l, --lines</td><td>仅显示行数</td></tr><tr><td>–files0-from=F</td><td>从文件 F 中获取以 NULL 字符结尾的文件名作为输入，如果 F 等于连字符 -，则从标准输入读取</td></tr><tr><td>-L, --max-line-length</td><td>显示文件中最长行的字符数</td></tr><tr><td>-w, --words</td><td>显示单词数，单词以空格分隔</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>使用 wc 统计 <code>/etc/passwd</code> 行数、单词数和字节数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># wc /etc/passwd</span></span><br><span class="line">40   45 1719 /etc/passwd</span><br><span class="line"><span class="comment"># 40 是行数，45 是单词数，1719 是字节数。</span></span><br></pre></td></tr></table></figure></li><li><p>从文件读取输入文件名。如果有多个文件名，并且希望 wc 从一个文件中读取它们，那么使用 -files0-from 选项。这里将文件名称必须以 NULL 字符结束写在文件fileNames.txt 中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> --files0-from=fileNames.txt</span><br></pre></td></tr></table></figure><p>在 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=vim&amp;spm=1001.2101.3001.7020">vim</a> 中输入 NULL 字符，可以通过 digraph 输入，具体操作步骤是：在输入模式按一下Ctrl+k，然后输入NU。</p></li></ol><h3 id="sort-排序">sort 排序</h3><p>sort命令将文件/文本的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p><p>📌<strong>sort命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> [-options] [file]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-b</td><td>忽略每行前面开始出的空格字符；</td></tr><tr><td>-c</td><td>检查文件是否已经按照顺序排序；</td></tr><tr><td>-d</td><td>排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</td></tr><tr><td>-f</td><td>排序时，将小写字母视为大写字母；</td></tr><tr><td>-i</td><td>排序时，除了040至176之间的ASCII字符外，忽略其他的字符；</td></tr><tr><td>-m</td><td>将几个排序号的文件进行合并；</td></tr><tr><td>-M</td><td>将前面3个字母依照月份的缩写进行排序；</td></tr><tr><td>-n</td><td>依照数值的大小排序；</td></tr><tr><td><code>-o&lt;输出文件&gt;</code></td><td>将排序后的结果存入制定的文件；</td></tr><tr><td>-r</td><td>以相反的顺序来排序；</td></tr><tr><td><code>-t&lt;分隔字符&gt;</code></td><td>指定排序时所用的栏位分隔字符；</td></tr><tr><td><code>+&lt;起始栏位&gt;-&lt;结束栏位&gt;</code></td><td>以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</td></tr></tbody></table><h3 id="uniq-去重">uniq 去重</h3><p>uniq命令用于报告或忽略文件中的重复行，一般与sort命令结合使用。</p><p>📌<strong>uniq命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uniq</span> [-options] [file]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c或–count</td><td>在每列旁边显示该行重复出现的次数；</td></tr><tr><td>-d或–repeated</td><td>仅显示重复出现的行列；</td></tr><tr><td><code>-f&lt;栏位&gt;</code>或<code>--skip-fields=&lt;栏位&gt;</code></td><td>忽略比较指定的栏位；</td></tr><tr><td><code>-s&lt;字符位置&gt;</code>或<code>--skip-chars=&lt;字符位置&gt;</code></td><td>忽略比较指定的字符；</td></tr><tr><td>-u或–unique：</td><td>仅显示出一次的行列；</td></tr><tr><td><code>-w&lt;字符位置&gt;</code>或<code>--check-chars=&lt;字符位置&gt;</code></td><td>指定要比较的字符。</td></tr></tbody></table><h3 id="tee-将数据重定向到文件">tee 将数据重定向到文件</h3><p>tee命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的 stdin 。简单的说就是把数据重定向到给定文件和屏幕上。</p><p>存在缓存机制，每1024个字节将输出一次。若从管道接收输入数据，应该是缓冲区满，才将数据转存到指定的文件中。若文件内容不到1024个字节，则接收完从标准输入设备读入的数据后，将刷新一次缓冲区，并转存数据到指定文件。</p><p>📌<strong>tee命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tee</span> [-options] [file]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>向文件中重定向时使用追加模式；</td></tr><tr><td>-i</td><td>忽略中断（interrupt）信号。</td></tr></tbody></table><h3 id="join-文件按行连接">join 文件按行连接</h3><p>join的连接操作简言之就是将两个具有相同域的纪录给挑选出来，再将这些纪录所有的域放到一行。</p><p>注意：join在对两个文件进行连接时，两个文件必须都是按照连接域排好序的，按其他域排序是无效的。</p><p>📌<strong>join命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span> [-options] file1 file2</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a1或-a2</td><td>除了显示共同域的纪录之外，-a1显示第一个文件没有共同域的纪录，-a2显示第二个文件中没有共同域的纪录</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-o</td><td>设置结果显示的格式</td></tr><tr><td>-t</td><td>改变域的分隔符</td></tr><tr><td>-v1或-v2</td><td>不显示共同域的纪录之外，-v1显示第一个文件没有共同域的纪录，-v2显示第二个文件中没有共同域的纪录</td></tr><tr><td>-1或-2</td><td>-1用来设置文件1连接的域，-2用来设置文件2连接的域</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>将两个文件的具有共同域的纪录连接在一起：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# cat file.db </span><br><span class="line"> A li:20:men:anhui</span><br><span class="line"> B wang:21:women:jiangsu</span><br><span class="line"> C zhang:22:men:anhui</span><br><span class="line"> D liu:23:women:Shanghai</span><br><span class="line"> E chen:23:women:Hefei</span><br><span class="line">[root@coonote ~]# cat file_hobby.db </span><br><span class="line"> A li:Song</span><br><span class="line"> B wang:shopping</span><br><span class="line"> C zhang:pingpong</span><br><span class="line"> D liu:chess</span><br><span class="line"> E Wang:reading</span><br><span class="line">[root@coonote ~]# join -t: file.db file_hobby.db </span><br><span class="line"> A li:20:men:anhui:Song</span><br><span class="line"> B wang:21:women:jiangsu:shopping</span><br><span class="line"> C zhang:22:men:anhui:pingpong</span><br><span class="line"> D liu:23:women:Shanghai:chess</span><br></pre></td></tr></table></figure><p>-a1还显示第一个文件中没有共同域的纪录，-a2则显示第二个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# join -t: -a1 file.db file_hobby.db</span><br><span class="line"> A li:20:men:anhui:Song</span><br><span class="line"> B wang:21:women:jiangsu:shopping</span><br><span class="line"> C zhang:22:men:anhui:pingpong</span><br><span class="line"> D liu:23:women:Shanghai:chess</span><br><span class="line"> E chen:23:women:Hefei</span><br><span class="line">[root@coonote ~]# join -t: -a2 file.db file_hobby.db</span><br><span class="line"> A li:20:men:anhui:Song</span><br><span class="line"> B wang:21:women:jiangsu:shopping</span><br><span class="line"> C zhang:22:men:anhui:pingpong</span><br><span class="line"> D liu:23:women:Shanghai:chess</span><br><span class="line"> E Wang:reading</span><br></pre></td></tr></table></figure><p>设置指定格式的域来显示出来（将具有共同纪录的域按照姓名+性别+爱好的格式显示出来）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# join -t: -o1.1 1.3 2.2 file.db file_hobby.db </span><br><span class="line"> A li:men:Song</span><br><span class="line"> B wang:women:shopping</span><br><span class="line"> C zhang:men:pingpong</span><br><span class="line"> D liu:women:chess</span><br></pre></td></tr></table></figure><h3 id="paste-将多个文件对应行链接在一起">paste 将多个文件对应行链接在一起</h3><p>paste命令会把每个文件以列对列的方式，一列列地加以合并 ，他就是相当于把两个不同的文件内容粘贴在一起，形成新的文件。</p><p>注意：paste默认粘贴方式以列的方式粘贴，但是并不是不能以行的方式粘贴，加上-s选项就可以行方式粘贴。</p><p>📌<strong>paste命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">paste</span> [-options] file1 file2</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>默认域的分隔符是空格或tab键，设置新的域分隔符</td></tr><tr><td>-s</td><td>将每个文件粘贴成一行</td></tr><tr><td>–</td><td>从标准输入中读取数据</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>将file_2和file_2粘贴成一个新的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# cat file_1</span><br><span class="line"> aaa </span><br><span class="line"> bbb</span><br><span class="line"> ccc</span><br><span class="line"> ddd</span><br><span class="line"> eee</span><br><span class="line">[root@coonote ~]# cat file_2</span><br><span class="line"> AAA</span><br><span class="line"> BBB</span><br><span class="line"> CCC</span><br><span class="line"> DDD</span><br><span class="line"> EEE</span><br><span class="line">[root@coonote ~]# paste file_1 file_2</span><br><span class="line"> aaa     AAA</span><br><span class="line"> bbb    BBB</span><br><span class="line"> ccc    CCC</span><br><span class="line"> ddd    DDD</span><br><span class="line"> eee    EEE</span><br></pre></td></tr></table></figure><p>设置域分隔符为：粘贴成新的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# paste -d: file_1 file_2</span><br><span class="line"> aaa:AAA</span><br><span class="line"> bbb:BBB</span><br><span class="line"> ccc:CCC</span><br><span class="line"> ddd:DDD</span><br><span class="line"> eee:EEE</span><br></pre></td></tr></table></figure><p>将每个文件粘贴成一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# cat file_1</span><br><span class="line"> aaa</span><br><span class="line"> bbb</span><br><span class="line"> ccc</span><br><span class="line"> ddd</span><br><span class="line"> eee</span><br><span class="line">[root@coonote ~]# cat file_2</span><br><span class="line"> AAA</span><br><span class="line"> BBB</span><br><span class="line"> CCC</span><br><span class="line"> DDD</span><br><span class="line"> EEE</span><br><span class="line">[root@coonote ~]# paste -d: -s file_1 file_2</span><br><span class="line"> aaa:bbb:ccc:ddd:eee</span><br><span class="line"> AAA:BBB:CCC:DDD:EEE</span><br></pre></td></tr></table></figure><p>从标准输入中读取数据，每行显示5个文件名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# ls | paste -d&quot; &quot; - - - - - </span><br><span class="line"> anaconda-ks.cfg dir_1 file1 file_1 file_1.db</span><br><span class="line"> file_2 file_3 file_4 file_5 file_6</span><br><span class="line"> file.db file_hobby_1 file_hobby.db file_hobby_sort.db file_sort.db</span><br><span class="line"> initial-setup-ks.cfg testfile</span><br></pre></td></tr></table></figure><h3 id="split-文件切割">split 文件切割</h3><p>📌<strong>split命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> [-options] 要切割的文件 [输出文件名前缀]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-b&lt;字节&gt;</code>：</td><td>指定按多少字节进行拆分，也可以指定 K、M、G、T 等单位。</td></tr><tr><td><code>-&lt;行数&gt;或-l&lt;行数&gt;</code>：</td><td>指定每多少行要拆分成一个文件。</td></tr><tr><td>输出文件名前缀：</td><td>设置拆分后的文件的名称前缀，split 会自动在前缀后加上编号，默认从 aa 开始。</td></tr><tr><td><code>-a&lt;后缀长度&gt;</code>：</td><td>默认的后缀长度是 2，也就是按 aa、ab、ac 这样的格式依次编号。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>生成一个 700MB 文件来作为我们的拆分对象：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roclinux ~]$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero bs=1024 count=700000 of=king_of_ring.avi</span><br><span class="line">700000+0 records <span class="keyword">in</span></span><br><span class="line">700000+0 records out</span><br><span class="line">716800000 bytes (717 MB) copied, 12.9189 s, 55.5 MB/s</span><br><span class="line"> </span><br><span class="line">[root@roclinux ~]$  <span class="built_in">ls</span> -l king_of_ring.avi</span><br><span class="line">-rw-r--r-- 1 root root 716800000 Apr 12 13:01 king_of_ring.avi</span><br></pre></td></tr></table></figure><p>把其中一份拆分成400M：（拆分时未指定文件名则随机生成文件名）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@roclinux ~]$ <span class="built_in">split</span> -b 400M king_of_ring.avi</span><br><span class="line"> </span><br><span class="line">[root@roclinux ~]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 1400008</span><br><span class="line">-rw-r--r-- 1 root root 716800000 Apr 12 13:01 king_of_ring.avi</span><br><span class="line">-rw-r--r-- 1 root root 419430400 Apr 12 13:04 xaa</span><br><span class="line">-rw-r--r-- 1 root root 297369600 Apr 12 13:04 xab</span><br></pre></td></tr></table></figure><p>在把文件合并起来</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@roclinux ~]$ <span class="built_in">cat</span> xaa xab &gt; king_of_ring_merge.avi</span><br><span class="line"> </span><br><span class="line">[root@roclinux ~]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 2100012</span><br><span class="line">-rw-r--r-- 1 root root 716800000 Apr 12 13:01 king_of_ring.avi</span><br><span class="line">-rw-r--r-- 1 root root 716800000 Apr 12 13:07 king_of_ring_merge.avi</span><br><span class="line">-rw-r--r-- 1 root root 419430400 Apr 12 13:04 xaa</span><br><span class="line">-rw-r--r-- 1 root root 297369600 Apr 12 13:04 xab</span><br></pre></td></tr></table></figure><h3 id="cut-选取部分内容">cut 选取部分内容</h3><p>cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><p>📌<strong>cut命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> [-options] filename</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-b</code></td><td>以字节为单位进行分割</td></tr><tr><td><code>-c</code></td><td>以字符 (characters) 的单位取出固定字符区间</td></tr><tr><td><font style="color:red"><code>-d</code></font></td><td>分隔符，按照指定分隔符分割列。与 -f 一起使用</td></tr><tr><td><font style="color:red"><code>-f</code></font></td><td>依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思（列号，提取第几列）</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ul><li><p><strong>准备数据</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim cut.txt</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line">le  le</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>切割cut.txt第一列</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -d &#x27; &#x27; -f 1 cut.txt </span></span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure></li><li><p>切割cut.txt第二、三列</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -d &#x27; &#x27; -f 2,3 cut.txt </span></span><br><span class="line">shen</span><br><span class="line">zhen</span><br><span class="line"> wo</span><br><span class="line"> lai</span><br><span class="line"> le</span><br></pre></td></tr></table></figure></li><li><p>切割cut.txt的第5-8个字符</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -c 5-8 cut.txt </span></span><br><span class="line"> she</span><br><span class="line"> zhe</span><br><span class="line">wo</span><br><span class="line"> lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure></li><li><p>切割cut.txt的第2,4,6个字节</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -b 2,4,6 cut.txt </span></span><br><span class="line">ogs</span><br><span class="line">unz</span><br><span class="line">o o</span><br><span class="line">a l</span><br><span class="line">e e</span><br></pre></td></tr></table></figure></li></ol><h3 id="tr-对标准输入内容做替换">tr 对标准输入内容做替换</h3><p>tr (translate的简写)，主要用于压缩重复字符，主要用于将从标准输入(<code>stdin</code>)读取的数据进行结果集映射、字符压缩和字符删除。它首先会将读取的标准输入进行排序然后按照某种方式换行，然后再根据给出的命令行参数做相关处理。</p><p>📌<strong>tr命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tr</span> [options] [SET1] [SET2]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-c</code></td><td>使用SET1的补集</td></tr><tr><td><code>-d</code></td><td>删除字符</td></tr><tr><td><code>-s</code></td><td>压缩字符</td></tr><tr><td><code>-t</code></td><td>截断SET1，使得SET1的长度和SET2的长度相同</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>将输入的字符由大写转换成小写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;HELLO&quot; | tr &#x27;A-Z&#x27; &#x27;a-z&#x27;</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li><li><p>ROT13 加解密 原理 就是两边都对称 所以加解密可以用一套相同的集合</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;hello&quot; | tr &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27; \</span></span><br><span class="line">&gt; <span class="string">&#x27;NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&#x27;</span></span><br><span class="line">uryyb</span><br></pre></td></tr></table></figure></li><li><p>删除指定字符</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;hello 123 world 234&quot; | tr -d &#x27;0-9&#x27;</span></span><br><span class="line">hello  world </span><br></pre></td></tr></table></figure></li><li><p>字符集补偿（删除补集）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo hello 1 char 2 next 4 | tr -d -c &#x27;0-9 \n&#x27;</span></span><br><span class="line"> 1  2  4</span><br></pre></td></tr></table></figure></li><li><p>压缩字符(压缩输入中重复的字符)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;tr    is    a   shell   order   &quot; | tr -s &#x27; &#x27;</span></span><br><span class="line"><span class="built_in">tr</span> is a shell order </span><br></pre></td></tr></table></figure></li><li><p>字符类</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo acniu | tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;</span></span><br><span class="line">ACENIU</span><br></pre></td></tr></table></figure><table><thead><tr><th>字符类</th><th>说明</th></tr></thead><tbody><tr><td><code>[:digit:]</code></td><td>所有数字</td></tr><tr><td><code>[:lower:]</code></td><td>所有小写字符</td></tr><tr><td><code>[:upper:]</code></td><td>所有大写字符</td></tr><tr><td><code>[:graph:]</code></td><td>所有可打印字符，不包括空格</td></tr><tr><td><code>[:print:]</code></td><td>所有可打印字符，包括空格</td></tr><tr><td><code>[:punct:]</code></td><td>所有的标点字符</td></tr><tr><td><code>[:space:]</code></td><td>所有横向或者纵向的空白</td></tr></tbody></table></li></ol><h3 id="输出重定向">&gt; 输出重定向</h3><p>可将本应显示在终端上的内容保存到指定文件中。</p><p><code>&gt;</code> 覆盖，会覆盖目标的原有内容，当文件存在时，会先删除原文件，再重新创建文件，然后把内容写入该文件，若文件不存在，则创建文件。</p><p><code>&gt;&gt;</code> 追加，会在目标原有内容后追加内容，当文件存在时直接在文件末尾进行内容追加，不会删除原文件，否则直接创建文件。</p><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表的内容写入文件 test.txt 中 （覆盖写）</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -l &gt; test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表的内容追加到文本 test.txt 的末尾</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al &gt;&gt; test.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;：就是标准输入重定向（等同0&lt;），意思将某某文件作为程序输入，也就是从某文件读取而不是键盘。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># command &lt; file</span></span><br></pre></td></tr></table></figure><h3 id="用文本模式指定行区间-管道符">| 用文本模式指定行区间 管道符</h3><p>管道是一种通信机制，通常用于进程间的通信。它表现出来的形式将<strong>前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/ad572909f7df4a43a732b1b8ccdf5d6a.png" alt="|"></p><p>📌<strong>示例说明</strong>：</p><p>过滤功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls / | grep &quot;y&quot;</span><br><span class="line">mydata</span><br><span class="line">sys</span><br></pre></td></tr></table></figure><p>针对上面这个命令说明：以管道作为分界线，前面的命令有个输出，后面需要先输入（缺少查找范围），然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入。</p><p>为了便于理解，上述的指令变相实现可以如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> / &gt; xxx.txt		<span class="comment"># 将ls /的结果保存到xxx.txt文件中</span></span><br><span class="line">grep <span class="string">&quot;y&quot;</span> xxx.txt	<span class="comment"># 使用grep指令搜索xxx.txt中的包含y的行</span></span><br></pre></td></tr></table></figure><h3 id="xargs-参数代换">xargs 参数代换</h3><p>管道实现的是将前面的输出<code>stdout</code>作为后面的输入<code>stdin</code>，但是有些命令不接受管道的传递方式。例如：<code>ls</code>，这是为什么呢？</p><p>因为有些命令希望管道传递过来的是参数，但是**直接使用管道有时无法传递到命令的参数位。**这时候就需要<code>xargs</code>，<code>xargs</code>实现的是将管道传递过来的<code>stdin</code>进行处理然后传递到命令的参数位置上。</p><p>📌<strong>xargs命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somecommand |xargs [-options]  <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>后跟文件名；</td></tr><tr><td>-n</td><td>指定要传递给命令的参数个数；</td></tr><tr><td>-t</td><td>在执行之前先打印；</td></tr><tr><td>-i或者-I</td><td>自定义一个传递参数符号；</td></tr><tr><td>-d或者–delimiter</td><td>设置自定义分隔符。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p><strong>xargs与find一起使用</strong></p><p>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有这个需要，所以就有了 xargs 命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name <span class="string">&quot;*.conf&quot;</span> | <span class="built_in">ls</span> -l	<span class="comment"># (错误)</span></span><br><span class="line">find /etc -name <span class="string">&quot;*.conf&quot;</span> | xargs <span class="built_in">ls</span> -l	<span class="comment"># (正确)</span></span><br></pre></td></tr></table></figure><blockquote><p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。<br>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。<br>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。<br>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</p></blockquote></li><li><p>我们用管道符传输到xargs，并为每个参数运行touch命令，-t表示在执行之前先打印，创建三个文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;file1 file2 file3&quot;|xargs -t touch</span></span><br><span class="line"><span class="built_in">touch</span> file1 file2 file3</span><br></pre></td></tr></table></figure></li><li><p>限制参数的数量</p><p>默认情况下，传递给命令的参数数量由系统限制决定。-n选项指定要传递给命令的参数个数。xargs根据需要多次运行指定的命令，直到所有参数都用完为止。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;file1 file2 file3&quot;|xargs -n1 -t touch</span></span><br><span class="line"><span class="built_in">touch</span> file1 </span><br><span class="line"><span class="built_in">touch</span> file2 </span><br><span class="line"><span class="built_in">touch</span> file3</span><br></pre></td></tr></table></figure></li><li><p>运行多个命令</p><p>要使用xargs运行多个命令，请使用-i或者-I选项。在-i或者-I后面自定义一个传递参数符号，所有匹配的项都会替换为传递给xargs的参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo &quot;file1 file2 file3&quot;|xargs -t -I % sh -c &#x27;touch %;ls -l %&#x27;</span></span><br><span class="line">sh -c <span class="built_in">touch</span> file1 file2 file3;<span class="built_in">ls</span> -l file1 file2 file3 </span><br><span class="line">-rw-r--r--. 1 root root 0 Jan 30 00:18 file1</span><br><span class="line">-rw-r--r--. 1 root root 0 Jan 30 00:18 file2</span><br><span class="line">-rw-r--r--. 1 root root 0 Jan 30 00:18 file3</span><br></pre></td></tr></table></figure></li><li><p>指定一个分隔符</p><p>使用-d或者–delimiter选项设置自定义分隔符，可以是单个字符，也可以是以\ 开头的转义字符。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo -n file1#file2#file3#file4|xargs -d \# -t touch</span></span><br><span class="line"><span class="built_in">touch</span> file1 file2 file3 file4</span><br></pre></td></tr></table></figure></li><li><p>从文件中读取条目</p><p>xargs命令还可以从文件读取条目，而不是从标准输入读取条目。使用-a选项，后跟文件名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat ip.txt </span></span><br><span class="line">114.114.114.114</span><br><span class="line">www.linuxprobe.com</span><br><span class="line">202.102.128.68</span><br><span class="line">[root@localhost ~]<span class="comment"># xargs -a ip.txt -t -L 1 ping -c 1</span></span><br><span class="line">ping -c 1 114.114.114.114 </span><br><span class="line">PING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=1 ttl=93 time=11.0 ms</span><br><span class="line"></span><br><span class="line">--- 114.114.114.114 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 11.026/11.026/11.026/0.000 ms</span><br><span class="line">ping -c 1 www.linuxprobe.com </span><br><span class="line">PING www.linuxprobe.com.w.kunlunno.com (221.15.65.202) 56(84) bytes of data.</span><br><span class="line">64 bytes from hn.kd.jz.adsl (221.15.65.202): icmp_seq=1 ttl=48 time=20.9 ms</span><br><span class="line"></span><br><span class="line">--- www.linuxprobe.com.w.kunlunno.com ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 20.934/20.934/20.934/0.000 ms</span><br><span class="line">ping -c 1 202.102.128.68 </span><br><span class="line">PING 202.102.128.68 (202.102.128.68) 56(84) bytes of data.</span><br><span class="line">64 bytes from 202.102.128.68: icmp_seq=1 ttl=83 time=8.71 ms</span><br><span class="line"></span><br><span class="line">--- 202.102.128.68 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 8.710/8.710/8.710/0.000 ms</span><br></pre></td></tr></table></figure></li></ol><h3 id="grep-行选取命令">grep 行选取命令</h3><p>Linux grep 命令用于查找文件里符合条件的字符串。</p><p>grep 命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式（patterns）被称为正则表达式（regular expressions），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀 global（全面的），一旦找到相匹配的内容，用户就像将其输出（print）到屏幕上，而将这一系列的操作整合到一起就是 global regular expressions print，而这也就是 grep 命令的全称。</p><p>📌<strong>grep命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [-options] [patterns] filename</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-c</code>：<code>--count</code></td><td>仅列出文件中包含模式的行数。</td></tr><tr><td><code>-i</code>：<code>--ignore-case</code></td><td>忽略模式中的字母大小写。</td></tr><tr><td><code>-l</code>：<code>--file-with-matches</code></td><td>列出带有匹配行的文件名。</td></tr><tr><td><code>-n</code>：<code>--line-number</code></td><td>在每一行的最前面列出行号。</td></tr><tr><td><font style="color:red"><code>-v</code>：<code>--invert-match</code></font></td><td>列出没有匹配模式的行。（反转）</td></tr><tr><td><code>-w</code>：<code>--word-regexp</code></td><td>把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。</td></tr><tr><td><font style="color:red"><code>-r 关键字 目录</code></font></td><td>在目录下搜索关键字</td></tr></tbody></table><p>📌<strong>patterns 正则表达式的通配符</strong>：</p><table><thead><tr><th>通配符</th><th>功能</th></tr></thead><tbody><tr><td>c*</td><td>将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。</td></tr><tr><td>.</td><td>将匹配任何一个字符，且只能是一个字符。</td></tr><tr><td>[xyz]</td><td>匹配方括号中的任意一个字符。</td></tr><tr><td>[^xyz]</td><td>匹配除方括号中字符外的所有字符。</td></tr><tr><td>^</td><td>锁定行的开头。</td></tr><tr><td>$</td><td>锁定行的结尾。</td></tr></tbody></table><p>⚠️ 需要注意的是，在基本正则表达式中，如通配符 *、+、{、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \，如 *、+、{、|、( 和 )。</p><h3 id="egrep-文件选取命令">egrep 文件选取命令</h3><p><strong>Linux egrep命令</strong>用于在文件内查找指定的字符串。egrep执行效果与<code>grep -E</code>相似，使用的语法及参数可参照grep指令，与grep的不同点在于解读字符串的方法。egrep是用extended regular expression语法来解读的，而grep则用basic regular expression 语法解读，extended regular expression比basic regular expression的表达更规范。</p><p>📌<strong>grep命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep [-options] [patterns] filename</span><br></pre></td></tr></table></figure><h3 id="sed">sed</h3><h3 id="awk">awk</h3><h3 id="gzip-gunzip-压缩-解压缩">gzip/gunzip 压缩/解压缩</h3><p>gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为<code>.gz</code>。</p><p>1️⃣<strong>gzip 压缩</strong></p><p><font style="color:red">gzip 命令<strong>只能用来压缩文件</strong>，<strong>不能压缩目录</strong>。即便指定了目录，也只能压缩目录内的所有文件。</font></p><p>📌<strong>gzip命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [-options] 源文件</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-c</code></td><td>将压缩数据输出到标准输出中，并保留源文件。</td></tr><tr><td><code>-d</code></td><td>对压缩文件进行解压缩。</td></tr><tr><td><code>-r</code></td><td>递归压缩指定目录下以及子目录下的所有文件。</td></tr><tr><td><code>-v</code></td><td>对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。</td></tr><tr><td><code>-l</code></td><td>对每一个压缩文件，显示以下字段：<br>压缩文件的大小；<br>未压缩文件的大小；<br>压缩比；<br>未压缩文件的名称。</td></tr><tr><td><code>-数字</code></td><td>用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>gzip 压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip install.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩instal.log 文件</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg install.log.gz install.log.syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成，但是源文件也消失了</span></span><br></pre></td></tr></table></figure></li><li><p>在使用 gzip 命令压缩文件时，源文件会消失，从而生成压缩文件。使用选项<code>-c</code>保留源文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip -c anaconda-ks.cfg &gt;anaconda-ks.cfg.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到压缩文件和源文件都存在</span></span><br></pre></td></tr></table></figure></li><li><p>试试用 gzip 命令可以压缩目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir test</span><br><span class="line">[root@localhost ~]# touch test/test1</span><br><span class="line">[root@localhost ~]# touch test/test2</span><br><span class="line">[root@localhost ~]# touch test/test3 #建立测试目录，并在里面建立几个测试文件</span><br><span class="line">[root@localhost ~]# gzip -r test/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩目录，并没有报错</span></span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog test</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">但是查看发现<span class="built_in">test</span>目录依然存在，并没有变为压缩文件</span></span><br><span class="line">[root@localhost ~]# ls test/</span><br><span class="line">testl .gz test2.gz test3.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩</span></span><br></pre></td></tr></table></figure><p>在 Linux 中，打包和压缩是分开处理的。而 gzip 命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。</p></li></ol><p>2️⃣<strong>gunzip 解压缩</strong></p><p>gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz）</p><p>📌<strong>gunzip命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunzip [-options] 文件</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code></td><td>递归处理，解压缩指定目录下以及子目录下的所有文件。</td></tr><tr><td><code>-c</code></td><td>把解压缩后的文件输出到标准输出设备。</td></tr><tr><td><code>-f</code></td><td>强制解压缩文件，不理会文件是否已存在等情况。</td></tr><tr><td><code>-l</code></td><td>列出压缩文件内容。</td></tr><tr><td><code>-v</code></td><td>显示命令执行过程。</td></tr><tr><td><code>-t</code></td><td>测试压缩文件是否正常，但不对其做解压缩操作。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>直接解压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip install.log.gz</span><br></pre></td></tr></table></figure></li><li><p>“gunzip -r&quot;依然只会解压缩目录下的文件，而不会解打包。要想解压缩”.gz&quot;格式，还可以使用 &quot;gzip -d&quot;命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip -r test/</span><br></pre></td></tr></table></figure></li><li><p>注意，如果我们压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下查看这个文本文件中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zcat anaconda-ks.cfg.gz</span><br></pre></td></tr></table></figure></li></ol><h3 id="zip-unzip-压缩-解压缩">zip/unzip 压缩/解压缩</h3><p>我们经常会在 Windows 系统上使用 “.zip”格式压缩文件，其实“.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式（zip、rar等）之一，是一种相当简单的分别压缩每个文件的存储格式。</p><p>1️⃣<strong>zip 压缩</strong></p><p>zip 命令，类似于 Windows 系统中的 winzip 压缩程序。</p><p>📌<strong>zip命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip [-options] 源文件</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-r</code></td><td>递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td></tr><tr><td><code>-m</code></td><td>将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td></tr><tr><td><code>-v</code></td><td>显示详细的压缩过程信息。</td></tr><tr><td><code>-q</code></td><td>在压缩的时候不显示命令的执行过程。</td></tr><tr><td><code>-压缩级别</code></td><td>压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。</td></tr><tr><td><code>-u</code></td><td>更新压缩文件，即往压缩文件中添加新文件。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>zip 命令的基本使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip ana.zip anaconda-ks.cfg</span><br><span class="line">adding: anaconda-ks.cfg (deflated 37%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩</span></span><br><span class="line">[root@localhost ~]# ll ana.zip</span><br><span class="line">-rw-r--r-- 1 root root 935 6月 1716:00 ana.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure><p>所有的压缩命令都可以同时压缩多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip test.zip install.log install.log.syslog</span><br><span class="line">adding: install.log (deflated 72%)</span><br><span class="line">adding: install.log.syslog (deflated 85%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">同时压缩多个文件到test.zip压缩包中</span></span><br><span class="line">[root@localhost ~]#ll test.zip</span><br><span class="line">-rw-r--r-- 1 root root 8368 6月 1716:03 test.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure></li><li><p>使用 zip 命令压缩目录，需要使用“-r”选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir dir1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建立测试目录</span></span><br><span class="line">[root@localhost ~]# zip -r dir1.zip dir1</span><br><span class="line">adding: dir1/(stored 0%)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩目录</span></span><br><span class="line">[root@localhost ~]# ls -dl dir1.zip</span><br><span class="line">-rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">压缩文件生成</span></span><br></pre></td></tr></table></figure></li></ol><p>2️⃣<strong>unzip 解压缩</strong></p><p>unzip 命令可以查看和解压缩 zip 文件。</p><p>📌<strong>unzip命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [-options] 文件</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-d 目录名</code></td><td>将压缩文件解压到指定目录下。</td></tr><tr><td><code>-n</code></td><td>解压时并不覆盖已经存在的文件。</td></tr><tr><td><code>-o</code></td><td>解压时覆盖已经存在的文件，并且无需用户确认。</td></tr><tr><td><code>-v</code></td><td>查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td></tr><tr><td><code>-t</code></td><td>测试压缩文件有无损坏，但并不解压。</td></tr><tr><td><code>-x 文件列表</code></td><td>解压文件，但不包含文件列表中指定的文件。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>不论是文件压缩包，还是目录压缩包，都可以直接解压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip dir1.zip</span><br><span class="line">Archive: dir1.zip</span><br><span class="line">creating: dirl/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压缩</span></span><br></pre></td></tr></table></figure></li><li><p>使用 -d 选项手动指定解压缩位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip -d /tmp/ ana.zip</span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把压缩包解压到指定位置</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="tar-打包">tar 打包</h3><p>tar（英文全拼：tape archive ）tape是磁带的意思，也即把数据打包成磁带文件，然后利用 gzip 和 bzip2 命令对磁带文件进行压缩存储。</p><p>📌<strong>tar命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [-options] 源文件或目录</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><p>打包常用选项：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-c</code>:<code>--directory=&lt;目的目录&gt;</code></td><td>将多个文件或目录进行打包。</td></tr><tr><td><code>-A</code>:<code>--catenate</code></td><td>追加 tar 文件到归档文件。</td></tr><tr><td><code>-f 包名</code>：<code>--file=&lt;备份文件&gt;</code></td><td>指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示打包文件过程</td></tr></tbody></table><p>解包常用选项：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>-x</code>：<code>--extract</code>：<code>--get</code></td><td>对 tar 包做解打包操作。</td></tr><tr><td><code>-f</code>：<code>--file=&lt;备份文件&gt;</code></td><td>指定要解压的 tar 包的包名。</td></tr><tr><td><code>-t</code>：<code>--list</code></td><td>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td></tr><tr><td><code>-C 目录</code>:<code>--directory=&lt;目的目录&gt;</code></td><td>指定解打包位置。</td></tr><tr><td><code>-v</code>：<code>--verbose</code></td><td>显示解打包的具体过程</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>常用命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  tar -cvf 打包后名字.tar 文件名1 文件名2 ...    # 打包并压缩</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  tar -xvf 需解压的文件.tar -C 解压的位置    # 解压</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># .gz 文件</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  tar -zcvf 打包后名字.tar.gz 文件名1 文件名2 ...    # 打包并压缩</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  tar -zxvf 需解压的文件.tar.gz     # 解压</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># .bz2 文件</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  tar -jcvf 打包后名字.tar.bz2 文件名1 文件名2 ...    # 打包并压缩</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  tar -jxvf 需解压的文件.tar.bz2     # 解压</span></span><br></pre></td></tr></table></figure><hr><h2 id="用户和用户组管理">用户和用户组管理</h2><h3 id="📂-etc-passwd-用户配置文件">📂<code>/etc/passwd</code> 用户配置文件</h3><p>Linux 系统中的 <code>/etc/passwd</code> 文件，是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作。</p><p>📌<strong>文件内容</strong>：</p><p>可以看到，<code>/etc/passwd</code> 文件中的内容非常规律，每行记录对应一个用户。这些用户中的绝大多数是系统或服务正常运行所必需的用户，这种用户通常称为系统用户或伪用户。系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /etc/passwd</span></span><br><span class="line"><span class="comment">#查看一下文件内容</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">...省略部分输出...</span><br><span class="line"><span class="comment"># 用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</span></span><br></pre></td></tr></table></figure><p>📌<strong>字段详解</strong>：</p><ul><li><p><strong>用户名</strong></p><p>用户名仅是为了方便用户记忆，Linux 系统是通过 UID 来识别用户身份，分配用户权限的。<code>/etc/passwd</code> 文件中就定义了用户名和 UID 之间的对应关系。</p></li><li><p><strong>密码</strong></p><p>“x” 表示此用户设有密码，但不是真正的密码，真正的密码保存在 <code>/etc/shadow</code> 文件中。在早期的 UNIX 中，这里保存的就是真正的加密密码串，但由于所有程序都能读取此文件，非常容易造成用户数据被窃取（虽然密码是加密的，但是采用暴力破解的方式也是能够进行破解的）。因此，现在 Linux 系统把真正的加密密码串放置在 <code>/etc/shadow</code> 文件中，此文件只有 root 用户可以浏览和操作，这样就最大限度地保证了密码的安全。</p><p>需要注意的是，虽然 “x” 并不表示真正的密码，但也不能删除，如果删除了 “x”，那么系统会认为这个用户没有密码，从而导致只输入用户名而不用输入密码就可以登陆。（只能在本地使用无密码登录，远程是不可以的）</p></li><li><p><strong>UID</strong></p><p>UID，也就是用户 ID。每个用户都有唯一的一个 UID，Linux 系统通过 UID 来识别不同的用户。实际上，UID 就是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份。</p><table><thead><tr><th>UID 范围</th><th>用户身份</th></tr></thead><tbody><tr><td>0</td><td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</td></tr><tr><td>1~499</td><td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1~99 用于系统自行创建的账号；100~499 分配给有系统账号需求的用户。 其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td></tr><tr><td>500~65535</td><td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 232 个 UID 了。</td></tr></tbody></table></li><li><p><strong>GID</strong></p><p>全称“Group ID”，简称“组ID”，表示用户初始组的组 ID 号。这里需要解释一下初始组和附加组的概念。</p><p><strong>初始组</strong>：指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。比如说，我们手工添加用户 lamp，在建立用户 lamp 的同时，就会建立 lamp 组作为 lamp 用户的初始组。</p><p><strong>附加组</strong>：指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。</p><p>当然，初始组和附加组的身份是可以修改的，但是我们在<strong>工作中不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱</strong>。需要注意的是，在 <code>/etc/passwd</code> 文件的第四个字段中看到的 ID 是这个用户的初始组。</p></li><li><p><strong>描述性信息</strong></p><p>这个字段并没有什么重要的用途，只是用来解释这个用户的意义而已。</p></li><li><p><strong>主目录</strong></p><p>也就是用户登录后有操作权限的访问目录，通常称为用户的主目录。</p><p>root 超级管理员账户的主目录为 <code>/root</code>，普通用户的主目录为 <code>/home/yourIDname</code>。</p></li><li><p><strong>默认的Shell</strong></p><p>Shell 就是 Linux 的命令解释器，是用户和 Linux 内核之间沟通的桥梁。</p><p>通常情况下，Linux 系统默认使用的命令解释器是 <code>bash</code>（<code>/bin/bash</code>），当然还有其他命令解释器，例如 sh、csh 等。</p><p>这里不能随便写入和登陆没有关系的命令（如 ls），系统不会识别这些命令，同时也就意味着这个用户不能登录。</p><p>把 lamp 用户的 Shell 命令解释器修改为 <code>/sbin/nologin</code>，那么，这个用户就不能登录了，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vi /etc/passwd</span><br><span class="line">lamp:x:502:502::/home/lamp:/usr/bin/passwd</span><br></pre></td></tr></table></figure></li></ul><h3 id="📂-etc-shadow-影子文件">📂<code>/etc/shadow</code> 影子文件</h3><p><code>/etc/shadow</code> 文件，用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。</p><p>前面介绍了 <code>/etc/passwd</code> 文件，由于该文件允许所有用户读取，易导致用户密码泄露，因此 Linux 系统将用户的密码信息从<code>/etc/passwd</code> 文件中分离出来，并单独放到了此文件中。</p><p><code>/etc/shadow</code> 文件只有 root 用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。</p><p>📌<strong>文件内容</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#vim /etc/shadow</span></span><br><span class="line">root: $6<span class="variable">$9w5Td6lg</span></span><br><span class="line"><span class="variable">$bgpsy3olsq9WwWvS5Sst2W3ZiJpuCGDY</span>.4w4MRk3ob/i85fl38RH15wzVoom ff9isV1 PzdcXmixzhnMVhMxbvO:15775:0:99999:7:::</span><br><span class="line">bin:*:15513:0:99999:7:::</span><br><span class="line">daemon:*:15513:0:99999:7:::</span><br><span class="line">…省略部分输出…</span><br><span class="line"><span class="comment"># 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</span></span><br></pre></td></tr></table></figure><p>📌<strong>字段详解</strong>：</p><ul><li><p><strong>用户名</strong></p><p>同 <code>/etc/passwd</code> 文件的用户名有相同的含义。</p></li><li><p><strong>加密密码</strong></p><p>这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。</p><blockquote><p>⚠️**注意！**这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件透过这个功能，在密码串前加上 “!”、“*” 或 “x” 使密码暂时失效。</p></blockquote><p>所有伪用户的密码都是 “!!” 或 “*”，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 “!!”，代表这个用户没有密码，不能登录。</p></li><li><p><strong>最后一次修改时间</strong></p><p>此字段表示最后一次修改密码的时间，可是，为什么 root 用户显示的是 15775 呢？</p><p>这是因为，Linux 计算日期的时间是以 1970 年 1 月 1 日作为 1 不断累加得到的时间，到 1971 年 1 月 1 日，则为 366 天。这里显示 15775 天，也就是说，此 root 账号在 1970 年 1 月 1 日之后的第 15775 天修改的 root 用户密码。</p><p>那么，到底 15775 代表的是哪一天呢？可以使用如下命令进行换算：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># date -d &quot;1970-01-01 15775 days&quot;</span></span><br><span class="line">2013年03月11日 星期一 00:00:00 CST</span><br></pre></td></tr></table></figure><p>可以看到，通过以上命令，即可将其换算为我们习惯的系统日期。</p></li><li><p><strong>最小修改时间间隔</strong></p><p>最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。</p><p>此字段是为了针对某些人频繁更改账户密码而设计的。</p></li><li><p><strong>密码有效期</strong></p><p>经常变更密码是个好习惯，为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。</p></li><li><p><strong>密码需要变更前的警告天数</strong></p><p>与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 “再过 n 天你的密码就要过期了，请尽快重新设置你的密码！”。</p><p>该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 “修改密码” 的警告信息。</p></li><li><p><strong>密码过期后的宽限天数</strong></p><p>也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。</p><p>比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。</p></li><li><p><strong>账号失效时间</strong></p><p>同第 3 个字段一样，使用自 1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！</p><p>该字段通常被使用在具有收费服务的系统中。</p></li><li><p><strong>保留</strong></p><p>这个字段目前没有使用，等待新功能的加入。</p></li><li><p><strong>忘记密码怎么办</strong></p><p>经常有读者会忘记自己的账户密码，该怎么处理呢？</p><p>对于普通账户的密码遗失，可以通过 root 账户解决，它会重新给你配置好指定账户的密码，而不需知道你原有的密码（利用 root 的身份使用 passwd 命令即可）。</p><p>如果 root 账号的密码遗失，则需要重新启动进入单用户模式，系统会提供 root 权限的 bash 接口，此时可以用 passwd 命令修改账户密码；也可以通过挂载根目录，修改 /etc/shadow，将账户的 root 密码清空的方法，此方式可使用 root 无法密码即可登陆，建议登陆后使用 passwd 命令配置 root 密码。</p></li></ul><h3 id="📂-etc-group-用户组配置文件">📂<code>/etc/group</code> 用户组配置文件</h3><p><code>/ect/group</code> 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。</p><p>此文件是记录组 ID（GID）和组名相对应的文件。前面讲过，<code>/etc/passwd</code> 文件中每行用户信息的第四个字段记录的是用户的初始组 ID，那么，此 GID 的组名到底是什么呢？就要从 /etc/group 文件中查找。</p><p>📌<strong>文件内容</strong>：</p><p>可以看到，<code>/etc/group</code> 中每一行各代表一个用户组。在前面章节中，我们曾创建 lamp 用户，系统默认生成一个 lamp 用户组，在此可以看到，此用户组的 GID 为 502，目前它仅作为 lamp 用户的初始组。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#vim /etc/group</span></span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:bin,daemon</span><br><span class="line">daemon:x:2:bin,daemon</span><br><span class="line">…省略部分输出…</span><br><span class="line">lamp:x:502:</span><br><span class="line"><span class="comment"># 组名：密码：GID：该用户组中的用户列表</span></span><br></pre></td></tr></table></figure><p>📌<strong>字段详解</strong>：</p><ul><li><p><strong>组名</strong></p><p>也就是是用户组的名称，有字母或数字构成。同 <code>/etc/passwd</code> 中的用户名一样，组名也不能重复。</p></li><li><p><strong>组密码</strong></p><p>和 <code>/etc/passwd</code> 文件一样，这里的 “x” 仅仅是密码标识，真正加密后的组密码默认保存在 <code>/etc/gshadow</code> 文件中。</p><p>不过，用户设置密码是为了验证用户的身份，那用户组设置密码是用来做什么的呢？用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，可以由该组的组管理员替代 root 进行管理。但是这项功能目前很少使用，我们也很少设置组密码。如果需要赋予某用户调整某个用户组的权限，则可以使用 sudo 命令代替。</p></li><li><p><strong>组ID (GID)</strong></p><p>就是群组的 ID 号，Linux 系统就是通过 GID 来区分用户组的，同用户名一样，组名也只是为了便于管理员记忆。</p><p>这里的组 GID 与 <code>/etc/passwd</code> 文件中第 4 个字段的 GID 相对应，实际上，<code>/etc/passwd</code> 文件中使用 GID 对应的群组名，就是通过此文件对应得到的。</p></li><li><p><strong>组中的用户</strong></p><p>此字段列出每个群组包含的所有用户。需要注意的是，如果该用户组是这个用户的初始组，则该用户不会写入这个字段，可以这么理解，该字段显示的用户都是这个用户组的附加用户。</p><p>举个例子，lamp 组的组信息为 “<code>lamp:x:502:</code>”，可以看到，第四个字段没有写入 lamp 用户，因为 lamp 组是 lamp 用户的初始组。如果要查询这些用户的初始组，则需要先到 <code>/etc/passwd</code> 文件中查看 GID（第四个字段），然后到 /etc/group 文件中比对组名。每个用户都可以加入多个附加组，但是只能属于一个初始组。所以我们在实际工作中，如果需要把用户加入其他组，则需要以附加组的形式添加。例如，我们想让 lamp 也加入 root 这个群组，那么只需要在第一行的最后一个字段加入 lamp，即 <code>root:x:0:lamp</code> 就可以了。</p></li></ul><h3 id="📂-etc-gshadow-安全组账户信息">📂<code>/etc/gshadow</code> 安全组账户信息</h3><p>前面讲过，/etc/passwd 文件存储用户基本信息，同时考虑到账户的安全性，将用户的密码信息存放另一个文件 /etc/shadow 中。本节要将的 /etc/gshadow 文件也是如此，组用户信息存储在 /etc/group 文件中，而将组用户的密码信息存储在 /etc/gshadow 文件中。</p><p>📌<strong>文件内容</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#vim /etc/gshadow</span></span><br><span class="line">root:::</span><br><span class="line">bin:::bin, daemon</span><br><span class="line">daemon:::bin, daemon</span><br><span class="line">...省略部分输出...</span><br><span class="line">lamp:!::</span><br><span class="line"><span class="comment"># 组名：加密密码：组管理员：组附加用户列表</span></span><br></pre></td></tr></table></figure><p>📌<strong>字段详解</strong>：</p><ul><li><p><strong>组名</strong></p><p>同 /etc/group 文件中的组名相对应。</p></li><li><p><strong>组密码</strong></p><p>对于大多数用户来说，通常不设置组密码，因此该字段常为空，但有时为 “!”，指的是该群组没有组密码，也不设有群组管理员。</p></li><li><p><strong>组管理员</strong></p><p>从系统管理员的角度来说，该文件最大的功能就是创建群组管理员。那么，什么是群组管理员呢？</p><p>考虑到 Linux 系统中账号太多，而超级管理员 root 可能比较忙碌，因此当有用户想要加入某群组时，root 或许不能及时作出回应。这种情况下，如果有群组管理员，那么他就能将用户加入自己管理的群组中，也就免去麻烦 root 了。</p><p>不过，由于目前有 sudo 之类的工具，因此群组管理员的这个功能已经很少使用了。</p></li><li><p><strong>组中的附加用户</strong></p><p>该字段显示这个用户组中有哪些附加用户，和 /etc/group 文件中附加组显示内容相同。</p></li></ul><h3 id="📂-etc-login-defs-Shadow密码套件配置">📂<code>/etc/login.defs</code> Shadow密码套件配置</h3><h3 id="📂-etc-skel-新用户配置文件">📂<code>/etc/skel</code> 新用户配置文件</h3><h3 id="w-who-whoami-who-am-i-查看登陆用户信息">w who whoami <code>who am i</code> 查看登陆用户信息</h3><p>💾<u><code>/etc/passwd</code></u></p><p>0️⃣<strong>它们的区别</strong>：</p><blockquote><ul><li>w</li></ul><p>显示服务器用户登录的详细信息（会打印每一列的表头）</p><p>包含用户名、终端设备、登录IP地址、登录时间等等。</p><ul><li>who</li></ul><p>显示用户登录信息，但是没有w命令显示的详细。</p><p>注意：w和who命令打印的结果是所有登录当前服务器的所有会话。</p><ul><li>whoami</li></ul><p>查看当前登录（当前会话）的用户名</p><ul><li>who am i</li></ul><p>查看当前登录（当前会话）的用户的详细登录信息</p></blockquote><p>1️⃣<strong>w</strong></p><p>w 命令除了能知道目前已登陆的用户信息，还可以知道每个用户执行任务的情况。</p><p>📌<strong>w命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [-options] [username]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>不显示输出信息的标题</td></tr><tr><td>-l</td><td>用长格式输出</td></tr><tr><td>-s</td><td>用短格式输出，不显示登陆时间，JCPU 和 PCPU 时间</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>显示当前用户登陆信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 13:13:56 up 13:00,  1 user,  load average: 0.08, 0.02, 0.01</span><br><span class="line">USER   TTY    FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root    tty1    -                        11:04       0.00s  0.36s   0.00s  -bash</span><br><span class="line">root    pts/0  192.168.0.108   13:15       0.00s   0.06s   0.02s   w</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前的系统时间、系统从启动至今已运行的时间、登陆到系统中的用户数和系统平均负载(平均负载（load average）指的是在 1 分钟、5 分钟、15 分钟内系统的负载状况)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>登录到系统的用户。</td></tr><tr><td>TTY</td><td>登录终端。</td></tr><tr><td>FROM</td><td>表示用户从哪里登陆进来，一般显示远程登陆主机的 IP 地址或者主机名。</td></tr><tr><td>LOGIN@</td><td>用户登陆的日期和时间。</td></tr><tr><td>IDLE</td><td>表示某个程序上次从终端开始执行到现在所持续的时间。</td></tr><tr><td>JCPU</td><td>和该终端连接的所有进程占用的 CPU 运算时间。这个时间里并不包括过去的后台作业时间，但是包括当前正在运行的后台作业所占用的时间。</td></tr><tr><td>PCPU</td><td>当前进程所占用的 CPU 运算时间。</td></tr><tr><td>WHAT</td><td>当前用户正在执行的进程名称和选项，换句话说，就是表示用户当前执行的是什么命令。</td></tr></tbody></table><p>2️⃣<strong>who</strong></p><p>who 命令只能显示当前登陆的用户信息，但无法知晓每个用户正在执行的命令。</p><p>who 命令默认是通过 <code>/var/run/utmp</code> 文件来获取登陆用户信息，但如果通过 file 指定另一个文件，则 who 命令将不再默认读取 <code>/var/run/utmp</code> 文件，而是读取该指定文件来获取信息。</p><p>📌<strong>who命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">who</span> [-options] [username]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>列出所有信息，相当于所有选项。</td></tr><tr><td>-b</td><td>列出系统最近启动的时间日期。</td></tr><tr><td><code>-H</code>或<code>-–heading</code></td><td>显示列标题</td></tr><tr><td>-l</td><td>列出所有可登陆的终端信息。</td></tr><tr><td><code>-m</code>或<code>am i</code></td><td>仅列出关于当前终端的信息，<code>who -m</code> 命令等同于 <code>who am i</code>。</td></tr><tr><td><code>-q</code>或<code>--count</code></td><td>列出在本地系统上的用户和用户数的清单。</td></tr><tr><td>-r</td><td>显示当前系统的运行级别。</td></tr><tr><td>-s</td><td>仅显示名称、线路和时间字段信息，这是 who 命令的默认选项。</td></tr><tr><td>-u</td><td>显示当前每个用户的用户名、登陆终端、<strong>登陆时间</strong>、线路活动和进程标识。</td></tr><tr><td><code>-w</code>或 <code>-T</code></td><td>显示 tty 终端的状态，“+”表示对任何人可写，“-”表示仅对 root 用户或所有者可写，“？”表示遇到线路故障</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>显示系统最新启动日期，以及每个用户的登陆详情、终端状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who     &lt;--等同于 who -s</span><br><span class="line">root tty1 2013-06-07 09：53</span><br><span class="line">root pts/0 2013-06-07 09：53 (192.168.0.108)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名 登录终端 登录时间（登录来源IP）</span></span><br></pre></td></tr></table></figure><p>3️⃣<strong>whoami</strong></p><p>4️⃣<strong>who am i</strong></p><p>仅列出关于当前终端的信息。详请查阅who命令，等同于<code>who -m</code>。</p><h3 id="exit-退出登入账户">exit 退出登入账户</h3><p>如果是图形界面，退出当前终端；</p><p>如果是使用ssh远程登录，退出登陆账户；</p><p>如果是切换后的登陆用户，退出则返回上一个登陆账号。</p><h3 id="useradd-添加新用户">useradd 添加新用户</h3><p>💾<u><code>/etc/passwd</code></u></p><p>Linux useradd 命令用于建立用户帐号。帐号建好之后，再用 <code>passwd</code> 设定帐号的密码。可用 <code>userdel</code> 删除帐号。使用 <code>useradd</code> 指令所建立的帐号。</p><p>📌<strong>useradd命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [-options] username</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-u UID</td><td>手工指定用户的 UID，注意 UID 的范围（不要小于 500）。</td></tr><tr><td>-d 主目录</td><td>手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</td></tr><tr><td>-c 用户说明</td><td>手工指定/etc/passwd文件中各用户信息中第 5 个字段的描述性内容，可随意配置；</td></tr><tr><td>-g 组名</td><td>手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时<br>会默认建立初始组。一旦手动指定，则系统将不会在创建此默认的初始组目录。</td></tr><tr><td>-G 组名</td><td>指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</td></tr><tr><td>-s shell</td><td>手工指定用户的登录 Shell，默认是 /bin/bash；</td></tr><tr><td>-e 曰期</td><td>指定用户的失效曰期，格式为 “YYYY-MM-DD”。也就是 /etc/shadow 文件的第八个字段；</td></tr><tr><td>-o</td><td>允许创建的用户的 UID 相同。例如，执行 “useradd -u 0 -o usertest” 命令<br>建立用户 usertest，它的 UID 和 root 用户的 UID 相同，都是 0；</td></tr><tr><td>-m</td><td>建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</td></tr><tr><td>-r</td><td>创建系统用户，也就是 UID 在 1~499 之间，供系统程序使用的用户。<br>由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</td></tr></tbody></table><p>其实，系统已经帮我们规定了非常多的默认值，在没有特殊要求下，无需使用任何选项即可成功创建用户。</p><p>📌<strong>示例说明</strong>：</p><p><strong>创建</strong>lamp<strong>用户的流程</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建 lamp 普通用户</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd lamp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看/etc/passwd，文件中创建一行与 lamp 用户相关的数据：</span></span><br><span class="line"><span class="comment"># 用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</span></span><br><span class="line"><span class="comment"># 可以看到，用户的 UID 是从 500 开始计算的。同时默认指定了用户的家目录为 /home/lamp/，用户的登录 Shell 为 /bin/bash。</span></span><br><span class="line"><span class="comment"># 当然，这个用户还没有设置密码，所以密码字段是 &quot;x&quot;，代表这个用户没有合理密码，不能正常登录。同时会按照默认值设定时间字段，例如密码有效期有 99999 天，距离密码过期 7 天系统会提示用户“密码即将过期”等。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;lamp&quot; /etc/passwd</span></span><br><span class="line">lamp:x:500:500::/home/lamp:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看/etc/group，文件中创建一行与用户名一模一样的群组</span></span><br><span class="line"><span class="comment"># 该群组会作为新建用户的初始组。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;lamp&quot; /etc/group</span></span><br><span class="line">lamp:x:500:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/etc/gshadow，文件中新增一行与新增群组相关的密码信息</span></span><br><span class="line"><span class="comment"># 当然，我们没有设定组密码，所以这里没有密码，也没有组管理员。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;lamp&quot; /etc/gshadow</span></span><br><span class="line">lamp:!::</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.默认创建用户的主目录和邮箱</span></span><br><span class="line"><span class="comment"># 注意这两个文件的权限，都要让 lamp 用户拥有相应的权限。</span></span><br><span class="line">[root@localhost ~]<span class="comment">#ll -d /home/lamp/</span></span><br><span class="line">drwx------ 3 lamp lamp 4096 1月6 00:19 /home/lamp/</span><br><span class="line">[root@localhost ~]<span class="comment">#ll /var/spod/mail/lamp</span></span><br><span class="line">-rw-rw---- 1 lamp mail 0 1月6 00:19 /var/spool/mail/lamp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.将 /etc/skel 目录中的配置文件复制到新用户的主目录中（新增用户配置文件目录）</span></span><br><span class="line"><span class="comment"># 这个目录下的所有文件会自动被复制到新添加的用户家目录下，可以为新创建的用户提供统一、标准的、初始化用户环境。</span></span><br></pre></td></tr></table></figure><blockquote><p>新增用户组时初始化数据，文件<code>/etc/default/useradd</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#vim /etc/default/useradd</span></span><br><span class="line"><span class="comment"># useradd defaults file</span></span><br><span class="line">GR0UP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>也可以用选项查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># useradd -D</span></span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=<span class="built_in">yes</span></span><br></pre></td></tr></table></figure><blockquote><p>文件内容：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>GR0UP=100</td><td>这个选项用于建立用户的默认组，也就是说，在添加每个用户时，用户的初始组就是 GID 为 100 的这个用户组。但 CentOS 并不是这样的，而是在添加用户时会自动建立和用户名相同的组作为此用户的初始组。也就是说这个选项并不会生效。 Linux 中默认用户组有两种机制：一种是私有用户组机制，系统会创建一个和用户名相同的用户组作为用户的初始组；另一种是公共用户组机制，系统用 GID 是 100 的用户组作为所有新建用户的初始组。目前我们采用的是私有用户组机制。</td></tr><tr><td>HOME=/home</td><td>指的是用户主目录的默认位置，所有新建用户的主目录默认都在 /home/下，刚刚新建的 lamp1 用户的主目录就为 /home/lamp1/。</td></tr><tr><td>INACTIVE=-1</td><td>指的是密码过期后的宽限天数，也就是 /etc/shadow 文件的第七个字段。这里默认值是 -1，代表所有新建立的用户密码永远不会失效。</td></tr><tr><td>EXPIRE=</td><td>表示密码失效时间，也就是 /etc/shadow 文件的第八个字段。默认值是空，代表所有新建用户没有失效时间，永久有效。</td></tr><tr><td>SHELL=/bin/bash</td><td>表示所有新建立的用户默认 Shell 都是 /bin/bash。</td></tr><tr><td>SKEL=/etc/skel</td><td>在创建一个新用户后，你会发现，该用户主目录并不是空目录，而是有 .bash_profile、.bashrc 等文件，这些文件都是从 /etc/skel 目录中自动复制过来的。因此，更改 /etc/skel 目录下的内容就可以改变新建用户默认主目录中的配置文件信息。</td></tr><tr><td>CREATE_MAIL_SPOOL=yes</td><td>指的是给新建用户建立邮箱，默认是创建。也就是说，对于所有的新建用户，系统都会新建一个邮箱，放在 /var/spool/mail/ 目录下，和用户名相同。</td></tr></tbody></table></blockquote></blockquote><p>📌<strong>示例说明</strong>：</p><h3 id="passwd-设置用户密码">passwd 设置用户密码</h3><p>一些Linux 发行版为了系统安装，都使用了 PAM 模块进行密码的检验，设置密码太短、与用户名相同、是常见字符串等，都会被 PAM 模块检查出来，从而禁止用户使用此类密码。</p><p>📌<strong>passwd命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [-options] username</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-S</code></td><td>查询用户密码的状态，也就是 /etc/shadow 文件中此用户密码的内容（仅 root 用户可用）</td></tr><tr><td><font style="color:red"><code>-l</code></font></td><td>暂时锁定用户，该选项会在 /etc/shadow 文件中指定用户的加密密码串前添加 “!”，使密码失效<br>（仅 root 用户可用）</td></tr><tr><td><font style="color:red"><code>-u</code></font></td><td>解锁用户，和 -l 选项相对应（ 仅 root 用户使用）</td></tr><tr><td><font style="color:red"><code>-d</code></font></td><td>删除密码</td></tr><tr><td><font style="color:red"><code>-f</code></font></td><td>强迫用户下次登录时必须修改口令</td></tr><tr><td><code>--stdin</code></td><td>可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用</td></tr><tr><td><code>-k</code></td><td>更新只能发送在过期之后</td></tr><tr><td><code>-n</code></td><td>设置该用户修改密码后，多长时间不能再次修改密码，也就是修改 /etc/shadow 文件中各行密码<br>的第 4 个字段</td></tr><tr><td><code>-x</code></td><td>设置该用户的密码有效期，对应 /etc/shadow 文件中各行密码的第 5 个字段</td></tr><tr><td><code>-w</code></td><td>设置用户密码过期前的警告天数，对于 /etc/shadow 文件中各行密码的第 6 个字段</td></tr><tr><td><code>-i</code></td><td>设置用户密码失效日期，对应 /etc/shadow 文件中各行密码的第 7 个字段</td></tr></tbody></table><p>⚠️<strong>注意：</strong></p><ol><li>普通用户只能使用 passwd 命令修改自己的密码，而不能修改其他用户的密码。</li><li>与使用 root 账户修改普通用户的密码不同，普通用户修改自己的密码需要先输入自己的旧密码，只有旧密码输入正确才能输入新密码。不仅如此，此种修改方式对密码的复杂度有严格的要求，新密码太短、太简单，都会被系统检测出来并禁止用户使用。</li><li><code>--stdin</code> 选项，用于批量给用户设置初始密码。使用此方式批量给用户设置初始密码，当然好处就是方便快捷，但需要注意的是，这样设定的密码会把密码明文保存在历史命令中，如果系统被攻破，别人可以在 /root/.bash_history 中找到设置密码的这个命令，存在安全隐患。（①手工清除历史命令；②强制这些新添加的用户在第一次登录时必须修改密码。）</li></ol><p>📌<strong>示例说明</strong>：</p><ol><li><p>使用 root 账户修改 lamp 普通用户的密码，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd lamp</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">New password: &lt;==直接输入新的口令，但屏幕不会有任何反应</span><br><span class="line">BAD PASSWORD: it is WAY too short &lt;==口令太简单或过短的错误！这里只是警告信息，输入的密码依旧能用</span><br><span class="line">Retype new password:  &lt;==再次验证输入的密码，再输入一次即可</span><br><span class="line">passwd: all authentication tokens updated successfully.  &lt;==提示修改密码成功</span><br></pre></td></tr></table></figure></li><li><p>使用 passwd 命令修改当前系统已登录用户的密码，但要注意的是，需省略掉 “选项” 和 “用户名”。登陆 lamp 用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#passwd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">passwd直接回车代表修改当前用户的密码</span></span><br><span class="line">Changing password for user vbird2.</span><br><span class="line">Changing password for vbird2</span><br><span class="line">(current) UNIX password: &lt;==这里输入『原有的旧口令』</span><br><span class="line">New password: &lt;==这里输入新口令</span><br><span class="line">BAD PASSWORD: it is WAY too short &lt;==口令检验不通过，请再想个新口令</span><br><span class="line">New password: &lt;==这里再想个来输入吧</span><br><span class="line">Retype new password: &lt;==通过口令验证！所以重复这个口令的输入</span><br><span class="line">passwd: all authentication tokens updated successfully. &lt;==成功修改用户密码</span><br></pre></td></tr></table></figure></li></ol><h3 id="usermod-修改用户信息">usermod 修改用户信息</h3><p>Linux usermod命令用于修改用户帐号信息。使用 Vi 文本编辑器手动修改涉及用户信息的相关文件（/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow），另一个方法就是使用本节介绍了 usermod 命令，该命令专门用于修改用户信息。</p><p>其实 usermod 命令提供的选项和 useradd 命令的选项相似，因为 usermod 命令就是用来调整使用 useradd 命令添加的用户信息的。usermod 命令还多出了几个选项，即 -L 和 -U，作用分别与 passwd 命令的 -l 和-u 相同。此命令对用户的临时锁定，同 passwd 命令一样，都是在 /etc/passwd 文件目标用户的加密密码字段前添加 “!”，使密码失效；反之，解锁用户就是将添加的 “!” 去掉。</p><p>📌<strong>usermod命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [-options] username</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-c 用户说明</code></td><td>修改用户的说明信息，即修改 <code>/etc/passwd</code> 文件目标用户信息的第 5 个字段</td></tr><tr><td><font style="color:red"><code>-d 主目录</code></font></td><td>修改用户的主目录，即修改 <code>/etc/passwd</code> 文件中目标用户信息的第 6 个字段，需要注意的是，主目录必须写绝对路径</td></tr><tr><td><code>-e 日期</code></td><td>修改用户的失效曰期，格式为 “YYYY-MM-DD”，即修改 /etc/shadow 文件目标用户密码信息的第 8 个字段</td></tr><tr><td><font style="color:red"><code>-g 组名</code></font></td><td>修改用户的初始组，即修改 <code>/etc/passwd</code> 文件目标用户信息的第 4 个字段（GID）</td></tr><tr><td><code>-u UID</code></td><td>修改用户的UID，即修改 <code>/etc/passwd</code> 文件目标用户信息的第 3 个字段（UID）</td></tr><tr><td><code>-G 组名</code></td><td>修改用户的附加组，其实就是把用户加入其他用户组，即修改 /etc/group 文件</td></tr><tr><td><code>-l 用户名</code></td><td>修改用户名称</td></tr><tr><td><code>-L</code></td><td>临时锁定用户（Lock）</td></tr><tr><td><code>-U</code></td><td>解锁用户（Unlock），和 -L 对应</td></tr><tr><td><code>-s shell</code></td><td>修改用户的登录 Shell，默认是 <code>/bin/bash</code></td></tr></tbody></table><h3 id="userdel-删除用户">userdel 删除用户</h3><p>Linux userdel命令用于删除用户帐号。userdel还可以删除用户帐号与相关的文件。若不加参数，则仅删除用户帐号，但是不删除用户的家目录，那么家目录就会变成没有属主和属组的目录，也就是垃圾文件。</p><p><strong><span style="color:red">※注意：如果要删除的用户已经使用过系统一段时间，那么此用户可能在系统中留有其他文件，因此，如果我们想要从系统中彻底的删除某个用户，最好在使用 userdel 命令之前，先通过 <code>find -user 用户名</code> 命令查出系统中属于该用户的文件，然后在加以删除。</span></strong></p><p>📌<strong>userdel命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [-options] username</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>删除用户登入目录以及目录中所有文件</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>手动删除用户，仅是为了对 userdel 命令理解地更透彻，实际使用中，使用 userdel 删除用户更方便。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立新 lamp 用户</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd lamp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为 lamp 用户设置密码，由此 lamp 用户才算是创建成功</span></span><br><span class="line">[root@localhost ~]<span class="comment"># passwd lamp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面开始手动删除 lamp</span></span><br><span class="line"><span class="comment">#修改用户信息文件，删除lamp用户行</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vi /etc/passwd</span></span><br><span class="line">lamp:x:501:501::/home/lamp:/bin/bash   &lt;--删除此行</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改影子文件，删除lamp用户密码行，注意，这个文件的权限是000，所以要强制保存</span></span><br><span class="line">[root@localhost ~]<span class="comment">#vi /etc/shadow</span></span><br><span class="line">lamp:$6<span class="variable">$KoOYtcOJ</span> <span class="variable">$56Xk9vp3D2vMRBxibNOn</span>.21cVJ9onbW8IHx4WrOx6qBqfGa9U3mjMsGjqYnj L/4t3zt3YxElce2X8rbb12x4a0:15716:0:99999:7:::   &lt;--删除此行</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改组信息文件，删除lamp群组信息</span></span><br><span class="line">[root@localhost ~]<span class="comment">#vi /etc/group</span></span><br><span class="line">lamp:x:501:  &lt;--删除此行</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改组影子文件，删除lamp群组密码信息。同样注意需要强制保存</span></span><br><span class="line">[root@localhost ~]<span class="comment">#vi /etc/gshadow</span></span><br><span class="line">lamp:!::  &lt;--删除此行</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf /var/spod/mail/lamp  #删除用户邮箱</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf/home/lamp/  #删除用户的家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#至此，用户彻底删除，再新建用户lamp。如果可以正常建立，则说明我们手工删除干净了</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># passwd lamp</span></span><br></pre></td></tr></table></figure><h3 id="id-查看用户的UID和GID">id 查看用户的UID和GID</h3><p>📌<strong>id命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> [-options] username</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-g</code>：<code>--group</code></td><td>显示用户所属群组的ID</td></tr><tr><td><code>-G</code>：<code>--groups</code></td><td>显示用户所属附加群组的ID</td></tr><tr><td><code>-n</code>：<code>--name</code></td><td>显示用户，所属群组或附加群组的名称</td></tr><tr><td><code>-r</code>：<code>--real</code></td><td>显示实际ID</td></tr><tr><td><code>-u</code>：<code>--user</code></td><td>显示用户ID</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><pre><code class="language-sh">[root@localhost ~]# id lamp
uid=501(lamp) gid=501(lamp) groups=501(lamp)
#能看到uid(用户ID)、gid(初始组ID), groups是用户所在组，这里既可以看到初始组，如果有附加组，则也能看到附加组
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```sh</span><br><span class="line">   [root@localhost ~]# usermod -G root lamp</span><br><span class="line">   #把用户加入root组</span><br><span class="line">   [root@localhost ~]# id lamp</span><br><span class="line">   uid=501(lamp) gid=501(lamp) groups=501(lamp),0(root)</span><br><span class="line">   #大家发现root组中加入了lamp用户的附加组信息</span><br></pre></td></tr></table></figure></code></pre></li></ol><h3 id="su-用户间切换">su 用户间切换</h3><p>Linux su（英文全拼：switch user）命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。</p><p>📌<strong>su命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-options] username</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><font style="color:red"><code>-</code></font></td><td>当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境<br>（包括 PATH 变量、MAIL 变量等），使用 - 选项可省略用户名，默认会切换为 root 用户。</td></tr><tr><td><code>-l</code></td><td>同 - 的使用类似，也就是在切换用户身份的同时，完整切换工作环境，但后面需要添加欲切换的使用者账号。</td></tr><tr><td><code>-p</code>：<code>-m</code></td><td>表示切换为指定用户的身份，但不改变当前的工作环境（不使用切换用户的配置文件）。</td></tr><tr><td><code>-c 命令</code></td><td>仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。</td></tr></tbody></table><p>📌<strong><code>su</code> 和 <code>su -</code> 的区别</strong></p><p>使用 su 命令时，有 <code>-</code> 和没有 <code>-</code> 是完全不同的，<code>-</code> 选项表示在切换用户身份的同时，连当前使用的环境变量也切换成指定用户的。我们知道，环境变量是用来定义操作系统环境的，因此如果系统环境没有随用户身份切换，很多命令无法正确执行。</p><p>📌<strong>示例说明</strong>：</p><ol><li><pre><code class="language-sh">#查询用户身份，我是lamp
[lamp@localhost ~]$ whoami
lamp

#切换到root，但是没有切换环境变量。注意：普通用户切换到root需要密码
[lamp@localhost ~]$ su root
密码：
&lt;-输入root密码

[root@localhost ~]# env | grep lamp
USER=lamp	#查看环境变量，提取包含lamp的行
PATH=/usr/lib/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/lamp/bin	#命令査找的路径不包含超级用户路径
MAIL=/var/spool/mail/lamp	#邮箱、主目录、目前用户名还是lamp
PWD=/home/lamp
LOGNAME=lamp
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```sh</span><br><span class="line">   #当前我是lamp</span><br><span class="line">   [lamp@localhost ~]$ whoami</span><br><span class="line">   lamp</span><br><span class="line">   </span><br><span class="line">   #不切换成root，但是执行useradd命令添加user1用户</span><br><span class="line">   [lamp@localhost ~]$ su - -c &quot;useradd user1&quot; root</span><br><span class="line">   密码：</span><br><span class="line">   </span><br><span class="line">   #我还是lamp</span><br><span class="line">   [lamp@localhost ~]$ whoami</span><br><span class="line">   lamp</span><br><span class="line">   </span><br><span class="line">   #user用户已经添加了</span><br><span class="line">   [lamp@localhost ~]$ grep &quot;user1&#x27; /etc/passwd</span><br><span class="line">   userl:x:502:504::/home/user1:/bin/bash</span><br></pre></td></tr></table></figure></code></pre></li></ol><h3 id="groupadd-添加用户组">groupadd 添加用户组</h3><p>💾<code>/etc/group</code> <code>/etc/gshadow</code> <code>/etc/login.defs</code></p><p>📌<strong>groupadd命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [-options] groupname</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-g</td><td>指定新建工作组的 id</td></tr><tr><td>-r</td><td>创建系统工作组，系统工作组的组 ID 小于 500</td></tr><tr><td>-K</td><td>覆盖配置文件 <code>/etc/login.defs</code></td></tr><tr><td>-o</td><td>允许添加组 ID 号不唯一的工作组</td></tr><tr><td>-f：–force</td><td>如果指定的组已经存在，此选项将失明了仅以成功状态退出。当与 -g 一起使用，并且指定的 GID_MIN 已经存在时，选择另一个唯一的 GID（即 -g 关闭）</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加group1组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupadd group1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;group1&quot; /etc/group</span></span><br><span class="line">/etc/group:group1:x:502:</span><br><span class="line">/etc/gshadow:group1:!::</span><br></pre></td></tr></table></figure><h3 id="groupmod-修改用户组">groupmod 修改用户组</h3><p>Linux groupmod命令用于更改群组识别码或名称。需要更改群组的识别码或名称时，可用groupmod指令来完成这项工作。</p><p>⚠️ <font style="color:red">**注意！**用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。</font></p><p>📌<strong>groupmod命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [-options] groupname</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-g &lt;群组识别码&gt;</td><td>设置欲使用的群组识别码</td></tr><tr><td>-o</td><td>重复使用群组识别码</td></tr><tr><td>-n &lt;新群组名称&gt;</td><td>设置欲使用的群组名称</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把组名group1修改为testgrp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupmod -n testgrp group1</span></span><br><span class="line"><span class="comment">#注意GID还是502，但是组名已经改变</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;testgrp&quot; /etc/group</span></span><br><span class="line">testgrp:x:502:</span><br></pre></td></tr></table></figure><p><strong>groupdel 刪除用户组</strong></p><p>Linux groupdel命令用于删除群组。需要从系统上删除群组时，可用groupdel(group delete)指令来完成这项工作。倘若该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组。</p><p>⚠️ <font style="color:red">**注意！**不能使用 groupdel 命令随意删除群组。此命令仅适用于删除那些 “不是任何用户初始组” 的群组，换句话说，如果有群组还是某用户的初始群组，则无法使用 groupdel 命令成功删除。</font></p><p>📌<strong>groupdel命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel groupname</span><br></pre></td></tr></table></figure><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># useradd temp</span></span><br><span class="line"><span class="comment">#运行如下命令，可以看到 temp 用户建立的同时，还创建了 temp 群组，且将其作为 temp用户的初始组（组ID都是 505）</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;temp&quot; /etc/passwd /etc/group /etc/gshadow</span></span><br><span class="line">/etc/passwd:temp:x:505:505::/home/temp:/bin/bash</span><br><span class="line">/etc/group:temp:x:505:</span><br><span class="line">/etc/gshadow:temp:!::</span><br><span class="line"><span class="comment">#下面尝试删除 temp 群组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupdel temp</span></span><br><span class="line">groupdel:cannot remove the primary group of user <span class="string">&#x27;temp&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到，groupdel 命令删除 temp 群组失败，且提示“不能删除 temp 用户的初始组”。如果一定要删除 temp 群组，要么修改 temp 用户的 GID，也就是将其初始组改为其他群组，要么先删除 temp 用户。</p><h3 id="gpasswd-把用户添加进组或从组中删除">gpasswd 把用户添加进组或从组中删除</h3><p>可设置多个普通用户作为群组的管理员，但也只能做“将用户加入群组”和“将用户移出群组”的操作。</p><p>📌<strong>gpasswd命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd [-options] groupname</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td></td><td>选项为空时，表示给群组设置密码（仅 root 用户可用）</td></tr><tr><td><code>-A user1,...</code></td><td>将群组的控制权交给 user1,… 等用户管理，也就是说，设置 user1,… 等用户为群组的管理员（仅 root 用户可用）</td></tr><tr><td><code>-M user1,...</code></td><td>将 user1,… 加入到此群组中（仅 root 用户可用）</td></tr><tr><td><code>-r</code></td><td>移除群组的密码（仅 root 用户可用）</td></tr><tr><td><code>-R</code></td><td>让群组的密码失效（仅 root 用户可用）</td></tr><tr><td><code>-a user</code></td><td>将 user 用户加入到群组中</td></tr><tr><td><code>-d user</code></td><td>将 user 用户从群组中移除</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>设置 lamp 用户为 group1 群组的管理员：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建新群组 group1，并将群组交给 lamp 管理</span></span><br><span class="line">[root@localhost ~]# groupadd group1  &lt;-- 创建群组</span><br><span class="line">[root@localhost ~]# gpasswd group1   &lt;-- 设置密码吧！</span><br><span class="line">Changing the password for group group1</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br><span class="line">[root@localhost ~]# gpasswd -A lamp group1  &lt;==加入群组管理员为 lamp</span><br><span class="line">[root@localhost ~]# grep &quot;group1&quot; /etc/group /etc/gshadow</span><br><span class="line">/etc/group:group1:x:506:</span><br><span class="line">/etc/gshadow:group1:$1$I5ukIY1.$o5fmW.cOsc8.K.FHAFLWg0:lamp:</span><br></pre></td></tr></table></figure></li><li><p>用群主管理员加入群主成员:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以lamp用户登陆系统，并将用户 lamp 和 lamp1 加入group1群组。</span></span><br><span class="line">[lamp@localhost ~]#gpasswd -a lamp group1</span><br><span class="line">[lamp@localhost ~]#gpasswd -a lamp1 group1</span><br><span class="line">[lamp@localhost ~]#grep &quot;group1&quot; /etc/group</span><br><span class="line">group1:x:506:lamp,lamp1</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>usermod -G</code> 命令也可以将用户加入群组，但会产生一个问题，即使用此命令将用户加入到新的群组后，该用户之前加入的那些群组都将被清空:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新创建一个群组group2</span></span><br><span class="line">[root@localhost ~]# groupadd group2</span><br><span class="line">[root@localhost ~]# usermod -G group2 lamp</span><br><span class="line">[root@localhost ~]# grep &quot;group2&quot; /etc/group</span><br><span class="line">group2:x:509:lamp</span><br><span class="line">[root@localhost ~]# grep &quot;group1&quot; /etc/group</span><br><span class="line">group1:x:506:lamp1</span><br></pre></td></tr></table></figure><p>对比例 2 可以发现，虽然使用 usermod 命令成功地将 lamp 用户加入在 group2 群组中，但 lamp 用户原本在 group1 群组中，此时却被移出，这就是使用 usermod 命令造成的。因此，将用户加入或移出群组，最好使用 gpasswd 命令。</p></li></ol><h3 id="newgrp-切换用户的有效组">newgrp 切换用户的有效组</h3><p>newgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。</p><p>每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。用户可以属于这么多用户组，用户在创建文件后，初始用户组的组身份生效。既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。</p><p>📌<strong>newgrp命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgp groupname</span><br></pre></td></tr></table></figure><p>📌<strong>命令的底层实现</strong>：</p><p>newgrp 命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。</p><blockquote><p>以下实例中，通过添加 shell 内置命令 “echo $$” 就可以发现，每次使用 newgrp 命令，都会切换到一个新的进程。</p></blockquote><p>在本节实例中，使用 newgrp 命令切换用户初始组的整个过程：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Z4121K230D9.gif" alt="newgrp 切换初始组程序运行过程图"></p><p>📌<strong>示例说明</strong>：</p><p>通过一个实例，讲解此命令的具体用法和功能：</p><ol><li><p>首先，建立 3 个用户组 group1、group2 和 group3，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd group1</span><br><span class="line">[root@localhost ~]# groupadd group2</span><br><span class="line">[root@localhost ~]# groupadd group3</span><br></pre></td></tr></table></figure></li><li><p>创建一个用户 user1，同时指定 user1 的初始组为 group1，附加组为 group2 和 group3，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd -g group1 -G group2,group3 user1</span><br><span class="line">\#由于指定了初始组，因此不会在创建 user1 默认群组</span><br><span class="line">[root@localhost ~]# more /etc/group | grep user1</span><br><span class="line">group2:x:501:user1</span><br><span class="line">group3:x:502:user1</span><br></pre></td></tr></table></figure></li><li><p>对用户 user1 设置密码，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line">Changing password for user user1.</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure></li><li><p>切换至 user1 用户，通过 newgrp 切换用户组进行下列操作，读者可从中体会出 newgrp 命令的作用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\#切换至 user1 用户</span><br><span class="line">[root@localhost ~]# su - user1</span><br><span class="line">[root@localhost ~]# whoami</span><br><span class="line">user1</span><br><span class="line">\#使用 newgrp 命令一边切换 user1 的初始组，一边创建文件</span><br><span class="line">[root@localhost ~]# mkdir user1_doc</span><br><span class="line">[root@localhost ~]# newgrp group2</span><br><span class="line">[root@localhost ~]# mkdir user2_doc</span><br><span class="line">[root@localhost ~]# newgrp group3</span><br><span class="line">[root@localhost ~]# mkdir user3_doc</span><br><span class="line">\#查看各文件的详细信息</span><br><span class="line">[root@localhost ~]# ll</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 user1 group1 4096 Oct 24 01:18 user1_doc</span><br><span class="line">drwxr-xr-x 2 user1 group2 4096 Oct 24 01:18 user2_doc</span><br><span class="line">drwxr-xr-x 2 user1 group3 4096 Oct 24 01:19 user3_doc</span><br></pre></td></tr></table></figure></li></ol><p>​ 通过使用 newgrp 命令切换用户的初始组，所创建的文件各自属于不同的群组，这就是 newgrp 所发挥的作用，即通过切换附加组成为新的初始组，从而让用户获得使用各个附加组的权限。</p><hr><h2 id="系统管理">系统管理</h2><h3 id="进程管理">进程管理</h3><p>无论是 Linux 系统管理员还是普通用户，监视系统进程的运行情况并适时终止一些失控的进程，是每天的例行事务。和 Linux 系统相比，进程管理在 Windows 中更加直观，它主要是使用&quot;任务管理器&quot;来进行进程管理的。</p><p><strong>📌使用&quot;任务管理器&quot;目的</strong></p><ol><li><p>利用&quot;应用程序&quot;和&quot;进程&quot;标签来査看系统中到底运行了哪些程序和进程；</p></li><li><p>利用&quot;性能&quot;和&quot;用户&quot;标签来判断服务器的健康状态；</p></li><li><p>在&quot;应用程序&quot;和&quot;进程&quot;标签中强制中止任务和进程；</p></li></ol><p>📌<strong>进程和程序</strong></p><p>进程是正在执行的一个程序或命令，每个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。</p><p>这么讲很难理解，那我们换一种说法。程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。而进程是正在执行中的程序。当程序被执行时，执行人的权限和属性，以及程序的代码都会被加载入内存，操作系统给这个进程分配一个 ID，称为 PID（进程 ID）。</p><p>也就是说，在操作系统中，所有可以执行的程序与命令都会产生进程。只是有些程序和命令非常简单，如 ls 命令、touch 命令等，它们在执行完后就会结束，相应的进程也就会终结，所以我们很难捕捉到这些进程。但是还有一些程和命令，比如 httpd 进程，启动之后就会一直驻留在系统当中，我们把这样的进程称作常驻内存进程。</p><p>某些进程会产生一些新的进程，我们把这些进程称作子进程，而把这个进程本身称作父进程。比如，我们必须正常登录到 Shell 环境中才能执行系统命令，而 Linux 的标准 Shell 是 bash。我们在 bash 当中执行了 ls 命令，那么 bash 就是父进程，而 ls 命令是在 bash 进程中产生的进程，所以 ls 进程是 bash 进程的子进程。也就是说，子进程是依赖父进程而产生的，如果父进程不存在，那么子进程也不存在了。</p><p>📌<strong>进程管理的作用</strong></p><p>在使用 Windows 系统的过程中，使用任务管理器，很大程度上是为了强制关闭“未反应”的软件，也就是杀死进程。的确，这是很多使用进程管理工具或进程管理命令的人最常见的使用方法。不过，杀死进程（强制中止进程）只是进程管理工作中最不常用的手段，因为每个进程都有自己正确的结束方法，而杀死进程是在正常方法已经失效的情况下的后备手段。</p><p>进程管理主要有以下 3 个作用：</p><ol><li><p>判断服务器的健康状态</p><p>运维工程师最主要的工作就是保证服务器安全、稳定地运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。</p><p>进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的 CPU 占用率、内存占用率过高，就需要人为介入解决问题了。这又出现了一个问题，我们发现服务器的 CPU 或内存占用率很高，该如何介入呢？是直接终止高负载的进程吗？</p><p>当然不是，应该判断这个进程是否是正常进程，如果是正常进程，则说明你的服务器已经不能满足应用需求，你需要更好的硬件或搭建集群了；如果是非法进程占用了系统资源，则更不能直接中止进程，而要判断非法进程的来源、作用和所在位置，从而把它彻底清除。</p><p>当然，如果服务器数量很少，我们完全可以人为通过进程管理命令来进行监控与干预，但如果服务器数量较多，那么人为手工监控就变得非常困难了，这时我们就需要相应的监控服务，如 cacti 或 nagios。总之，进程管理工作中最重要的工作就是判断服务器的健康状 态，最理想的状态是服务器宕机之前就解决问题，从而避免服务器的宕机。</p></li><li><p>查看系统中所有的进程</p><p>我们需要查看看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务、是否有非法服务在运行。</p></li><li><p>杀死进程</p><p>这是进程管理中最不常用的手段。当需要停止服务时，会通过正确关闭命令来停止服务（如 apache 服务可以通过 service httpd stop 命令来关闭）。只有在正确终止进程的手段失效的情况下，才会考虑使用 kill 命令杀死进程。</p><p>其实，进程管理和 Windows 中任务管理器的作用非常类似，不过大家在使用任务管理器时是为了杀死进程，而不是为了判断服务器的健康状态。</p></li></ol><h3 id="ps-查看正在运行的进程">ps 查看正在运行的进程</h3><p>📌<strong>ps命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [[-]options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><p>ps 命令有些与众不同，它的部分选项不能加入&quot;-“，比如命令&quot;ps aux”，其中&quot;aux&quot;是选项，但是前面不能带“-”。</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>显示一个终端的所有进程，除会话引线外；</td></tr><tr><td>u</td><td>显示进程的归属用户及内存的使用情况；</td></tr><tr><td>x</td><td>显示没有控制终端的进程；</td></tr><tr><td>-l</td><td>长格式显示更加详细的信息；</td></tr><tr><td>-e</td><td>显示所有进程；</td></tr><tr><td>-f</td><td>查看子父进程的关系；</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p><code>-ef</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ps -ef|grep nginx</span></span><br><span class="line">root        841      1  0 2月17 ?       00:00:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">nginx       843    841  0 2月17 ?       00:00:02 nginx: worker process</span><br><span class="line">nginx       916    819  0 2月17 ?       00:00:15 php-fpm: pool www</span><br><span class="line">nginx       923    819  0 2月17 ?       00:00:16 php-fpm: pool www</span><br><span class="line">...省略部分数据...</span><br></pre></td></tr></table></figure></li><li><p><code>aux</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看系统中所有的进程</span></span><br><span class="line">USER PID %CPU %MEM  VSZ  RSS   TTY STAT START TIME COMMAND</span><br><span class="line">root   1  0.0  0.2 2872 1416   ?   Ss   Jun04 0:02 /sbin/init</span><br><span class="line">root   2  0.0  0.0    0    0   ?    S   Jun04 0:00 [kthreadd]</span><br><span class="line">root   3  0.0  0.0    0    0   ?    S   Jun04 0:00 [migration/0]</span><br><span class="line">root   4  0.0  0.0    0    0   ?    S   Jun04 0:00 [ksoftirqd/0]</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>该进程是由哪个用户产生的。</td></tr><tr><td>PID</td><td>进程的 ID。</td></tr><tr><td>%CPU</td><td>该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。</td></tr><tr><td>%MEM</td><td>该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。</td></tr><tr><td>VSZ</td><td>该进程占用虚拟内存的大小，单位为 KB。</td></tr><tr><td>RSS</td><td>该进程占用实际物理内存的大小，单位为 KB。</td></tr><tr><td>TTY</td><td>该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts/0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts/0，第二个远程连接占用 pts/1，依次増长。</td></tr><tr><td>STAT</td><td>进程状态。常见的状态有以下几种：-D：不可被唤醒的睡眠状态，通常用于 I/O 情况。-R：该进程正在运行。-S：该进程处于睡眠状态，可被唤醒。-T：停止状态，可能是在后台暂停或进程处于除错状态。-W：内存交互状态（从 2.6 内核开始无效）。-X：死掉的进程（应该不会出现）。-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。-&lt;：高优先级（以下状态在 BSD 格式中出现）。-N：低优先级。-L：被锁入内存。-s：包含子进程。-l：多线程（小写 L）。-+：位于后台。</td></tr><tr><td>START</td><td>该进程的启动时间。</td></tr><tr><td>TIME</td><td>该进程占用 CPU 的运算时间，注意不是系统时间。</td></tr><tr><td>COMMAND</td><td>产生此进程的命令名。</td></tr></tbody></table></li><li><p><code>-le</code></p><p>&quot;ps aux&quot;命令可以看到系统中所有的进程，&quot;ps -le&quot;命令也能看到系统中所有的进程。由于 “-l” 选项的作用，所以 “ps -le” 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">F S UID PID PPID C  PRI Nl ADDR  SZ WCHAN TTY      TIME  CMD</span><br><span class="line">4 S   0   1    0 0  80   0 -    718 -     ?    00:00:02  init</span><br><span class="line">1 S   0   2    0 0  80   0 -      0 -     ?    00:00:00  kthreadd</span><br><span class="line">1 S   0   3    2 0 -40   - -      0 -     ?    00:00:00  migration/0</span><br><span class="line">1 S   0   4    2 0  80   0 -      0 -     ?    00:00:00  ksoflirqd/0</span><br><span class="line">1 S   0   5    2 0 -40   - -      0 -     ?    00:00:00  migration/0</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头</th><th>含义</th></tr></thead><tbody><tr><td>F</td><td>进程标志，说明进程的权限，常见的标志有两个: 1：进程可以被复制，但是不能被执行；4：进程使用超级用户权限；</td></tr><tr><td>S</td><td>进程状态。具体的状态和&quot;psaux&quot;命令中的 STAT 状态一致；</td></tr><tr><td>UID</td><td>运行此进程的用户的 ID；</td></tr><tr><td>PID</td><td>进程的 ID；</td></tr><tr><td>PPID</td><td>父进程的 ID；</td></tr><tr><td>C</td><td>该进程的 CPU 使用率，单位是百分比；</td></tr><tr><td>PRI</td><td>进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行；</td></tr><tr><td>NI</td><td>进程的优先级，数值越小，该进程越早被执行；</td></tr><tr><td>ADDR</td><td>该进程在内存的哪个位置；</td></tr><tr><td>SZ</td><td>该进程占用多大内存；</td></tr><tr><td>WCHAN</td><td>该进程是否运行。&quot;-&quot;代表正在运行；</td></tr><tr><td>TTY</td><td>该进程由哪个终端产生；</td></tr><tr><td>TIME</td><td>该进程占用 CPU 的运算时间，注意不是系统时间；</td></tr><tr><td>CMD</td><td>产生此进程的命令名；</td></tr></tbody></table></li></ol><h3 id="top-持续监听进程运行状态">top 持续监听进程运行状态</h3><p>top 命令可以动态地持续监听进程地运行状态，与此同时，该命令还提供了一个交互界面，用户可以根据需要，人性化地定制自己的输出，进而更清楚地了进程的运行状态。</p><p>📌<strong>top命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定 top 命令每隔几秒更新。默认是 3 秒；</td></tr><tr><td>-b</td><td>使用批处理模式输出。一般和&quot;-n&quot;选项合用，用于把 top 命令重定向到文件中；</td></tr><tr><td>-n 次数</td><td>指定 top 命令执行的次数。一般和&quot;-&quot;选项合用；</td></tr><tr><td>-p 进程PID</td><td>仅查看指定 ID 的进程；</td></tr><tr><td>-s</td><td>使 top 命令在安全模式中运行，避免在交互模式中出现错误；</td></tr><tr><td>-u 用户名</td><td>只监听某个用户的进程。</td></tr></tbody></table><p>📌<strong>交互命令</strong>：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>?：h</td><td>显示交互模式的帮助；</td></tr><tr><td>P</td><td>按照 CPU 的使用率排序，默认就是此选项；</td></tr><tr><td>M</td><td>按照内存的使用率排序；</td></tr><tr><td>N</td><td>按照 PID 排序；</td></tr><tr><td>T</td><td>按照 CPU 的累积运算时间排序，也就是按照 TIME+ 项排序；</td></tr><tr><td>k</td><td>按照 PID 给予某个进程一个信号。一般用于中止某个进程，信号 9 是强制中止的信号；</td></tr><tr><td>r</td><td>按照 PID 给某个进程重设优先级（Nice）值；</td></tr><tr><td>q</td><td>退出 top 命令。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>top 命令的执行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 12:26:46 up 1 day, 13:32, 2 users, load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.7%id, 0.1%wa, 0.0%hi, 0.1%si, 0.0%st</span><br><span class="line">Mem: 625344k total, 571504k used, 53840k free, 65800k buffers</span><br><span class="line">Swap: 524280k total, 0k used, 524280k free, 409280k cached</span><br><span class="line">PID   USER PR NI VIRT  RES  SHR S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">19002 root 20  0 2656 1068  856 R  0.3  0.2 0:01.87 top</span><br><span class="line">1     root 20  0 2872 1416 1200 S  0.0  0.2 0:02.55 init</span><br><span class="line">2     root 20  0    0    0    0 S  0.0  0.0 0:00.03 kthreadd</span><br><span class="line">3     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0</span><br><span class="line">4     root 20  0    0    0    0 S  0.0  0.0 0:00.15 ksoftirqd/0</span><br><span class="line">5     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0</span><br><span class="line">6     root RT  0    0    0    0 S  0.0  0.0 0:10.01 watchdog/0</span><br><span class="line">7     root 20  0    0    0    0 S  0.0  0.0 0:05.01 events/0</span><br><span class="line">8     root 20  0    0    0    0 S  0.0  0.0 0:00.00 cgroup</span><br><span class="line">9     root 20  0    0    0    0 S  0.0  0.0 0:00.00 khelper</span><br><span class="line">10    root 20  0    0    0    0 S  0.0  0.0 0:00.00 netns</span><br><span class="line">11    root 20  0    0    0    0 S  0.0  0.0 0:00.00 async/mgr</span><br><span class="line">12    root 20  0    0    0    0 S  0.0  0.0 0:00.00 pm</span><br><span class="line">13    root 20  0    0    0    0 S  0.0  0.0 0:01.70 sync_supers</span><br><span class="line">14    root 20  0    0    0    0 S  0.0  0.0 0:00.63 bdi-default</span><br><span class="line">15    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kintegrityd/0</span><br><span class="line">16    root 20  0    0    0    0 S  0.0  0.0 0:02.52 kblockd/0</span><br><span class="line">17    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpid</span><br><span class="line">18    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpi_notify</span><br></pre></td></tr></table></figure><p>我们解释一下命令的输出。top 命令的输出内容是动态的，默认每隔 3 秒刷新一次。命令的输出主要分为两部分：</p><p><strong>第一部分</strong>是前五行（显示的是整个系统的资源使用状况，我们就是通过这些输出来判断服务器的资源使用状态的）</p><p>1.第一行为任务队列信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>12:26:46</td><td>系统当前时间</td></tr><tr><td>up 1 day, 13:32</td><td>系统的运行时间.本机己经运行 1 天 13 小时 32 分钟</td></tr><tr><td>2 users</td><td>当前登录了两个用户</td></tr><tr><td>load average: 0.00,0.00，0.00</td><td>系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 （这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU 的核数）</td></tr></tbody></table><p>2.第二行为进程信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Tasks: 95 total</td><td>系统中的进程总数</td></tr><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>94 sleeping</td><td>睡眠的进程数</td></tr><tr><td>0 stopped</td><td>正在停止的进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数。如果不是 0，则需要手工检查僵尸进程</td></tr></tbody></table><p>3.第三行为 CPU 信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Cpu(s): 0.1 %us</td><td>用户模式占用的 CPU 百分比</td></tr><tr><td>0.1%sy</td><td>系统模式占用的 CPU 百分比</td></tr><tr><td>0.0%ni</td><td>改变过优先级的用户进程占用的 CPU 百分比</td></tr><tr><td>99.7%id</td><td>空闲 CPU 占用的 CPU 百分比</td></tr><tr><td>0.1%wa</td><td>等待输入/输出的进程占用的 CPU 百分比</td></tr><tr><td>0.0%hi</td><td>硬中断请求服务占用的 CPU 百分比</td></tr><tr><td>0.1%si</td><td>软中断请求服务占用的 CPU 百分比</td></tr><tr><td>0.0%st</td><td>st（steal time）意为虚拟时间百分比，就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分比</td></tr></tbody></table><p>4.四行为物理内存信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Mem: 625344k total</td><td>物理内存的总量，单位为KB</td></tr><tr><td>571504k used</td><td>己经使用的物理内存数量</td></tr><tr><td>53840k&amp;ee</td><td>空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存</td></tr><tr><td>65800k buffers</td><td>作为缓冲的内存数量</td></tr></tbody></table><p>5.第五行为交换分区（swap）信息</p><table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody><tr><td>Swap: 524280k total</td><td>交换分区（虚拟内存）的总大小</td></tr><tr><td>Ok used</td><td>已经使用的交换分区的大小</td></tr><tr><td>524280k free</td><td>空闲交换分区的大小</td></tr><tr><td>409280k cached</td><td>作为缓存的交换分区的大小</td></tr></tbody></table><p>我们通过 top 命令的第一部分就可以判断服务器的健康状态。如果 1 分钟、5 分钟、15 分钟的平均负载高于 1，则证明系统压力较大。如果 CPU 的使用率过高或空闲率过低，则证明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。</p><p>这时，我们就应该判断是什么进程占用了系统资源。如果是不必要的进程，就应该结束这些进程；如果是必需进程，那么我们该増加服务器资源（比如増加虚拟机内存），或者建立集群服务器。</p><p>解释一下缓冲（buffer）和缓存（cache）的区别：<font style="color:red">（缓存（cache）是用来加速数据从硬盘中&quot;读取&quot;的，而缓冲（buffer）是用来加速数据&quot;写入&quot;硬盘的）</font></p><ul><li>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。</li></ul></li></ol><ul><li>缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</li></ul><p><strong>第二部分</strong>从第六行开始（显示的是系统中进程的信息）</p><ul><li><p>PID：进程的 ID。</p></li><li><p>USER：该进程所属的用户。</p><ul><li><p>PR：优先级，数值越小优先级越高。</p></li><li><p>NI：优先级，数值越小、优先级越高。</p></li><li><p>VIRT：该进程使用的虚拟内存的大小，单位为 KB。</p></li><li><p>RES：该进程使用的物理内存的大小，单位为 KB。</p></li><li><p>SHR：共享内存大小，单位为 KB。</p></li><li><p>S：进程状态。</p></li><li><p>%CPU：该进程占用 CPU 的百分比。</p></li><li><p>%MEM：该进程占用内存的百分比。</p></li><li><p>TIME+：该进程共占用的 CPU 时间。</p></li><li><p>COMMAND：进程的命令名。</p></li></ul></li></ul><ol start="2"><li><p>top 命令如果不正确退出，则会持续运行。在 top 命令的交互界面中按 “q” 键会退出 top 命令；也可以按 “?” 或 “h” 键得到 top 命令交互界面的帮助信息；还可以按键中止某个进程。比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># top</span></span><br><span class="line">top - 14:10:15 up 1 day, 15:15， 3 <span class="built_in">users</span>, load average: 0.00，0.00, 0.00</span><br><span class="line">Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.0%us, 0.0%sy, 0.0%ni,100.0%<span class="built_in">id</span>, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</span><br><span class="line">Mem: 625344k total, 574248k used, 51096k free, 66840k buffers</span><br><span class="line">Swap: 524280k total, Ok used, 524280k free, 409324k cached</span><br><span class="line">PID to <span class="built_in">kill</span>:15273</span><br><span class="line"><span class="comment">#按&quot;k&quot;键，会提示输入要杀死进程的PID</span></span><br><span class="line">PID     USER PR NI VIRT  RES SHR S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">15273 daemon 20  0 4520 1192 580 S  0.0 0.2  0:00.00 httpd</span><br><span class="line">..省略部分输出...</span><br></pre></td></tr></table></figure></li><li><p>输入要中止进程的 PID，比如要中止 <code>15273</code> 这个 apache 进程，接下来 top 命令提示我们输入信号，信号 <code>9</code> 代表强制中止，这时就能够强制中止 15273 进程了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   top - 14:11:42 up 1 day, 15:17， 3 <span class="built_in">users</span>, load average: 0.00，0.00, 0.00</span><br><span class="line">   Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombie</span><br><span class="line">   Cpu(s): 0.0%us, 0.3%sy, 0.0%ni, 99.7%<span class="built_in">id</span>, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</span><br><span class="line">   Mem: 625344k total, 574248k used, 51096k free, 66856k buffers</span><br><span class="line">   Swap: 524280k total, 0k used, 524280k free, 409324k cached</span><br><span class="line">   Kill PID 15273 with signal [15]:9</span><br><span class="line">   <span class="comment">#提示输入信号，信号9代表强制中止</span></span><br><span class="line">   PID     USER PR NI VIRT  RES SHR S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">   15273 daemon 20  0 4520 1192 580 S 0.0   0.2 0:00.00 httpd</span><br><span class="line">   …省略部分输出…</span><br><span class="line"></span><br><span class="line">4. 改变某个进程的优先级，就要利用 `r` 交互命令：需要注意的是，我们能够修改的只有 NI（Nice） 的优先级，而不能修改 PR（Priority） 的优先级。</span><br><span class="line"></span><br><span class="line">   ```sh</span><br><span class="line">   [root@localhost ~]<span class="comment"># top -p 18977</span></span><br><span class="line">   top - 14:17:09 up 1 day, 15:22, 3 <span class="built_in">users</span>, load average: 0.00，0.00, 0.00</span><br><span class="line">   Tasks: 97 total, 1 running, 96 sleeping, 0 stopped, 0 zombie</span><br><span class="line">   Cpu(s): 0.3%us, 0.0%sy, 0.0%ni, 99.7%<span class="built_in">id</span>, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st</span><br><span class="line">   Mem: 625344k total, 574124k used, 51220k free, 66896k buffers</span><br><span class="line">   Swap: 524280k total, 0k used, 524280k free, 409324k cached</span><br><span class="line">   PID to renice:</span><br><span class="line">   <span class="comment">#输入&quot;r&quot;交互命令之后，提示输入要修改优先级的进程的PID</span></span><br><span class="line">   PID   USER PR NI  VIRT  RES SHR  S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">   18977 root 20 0  11592 3304 2572 S  0.0 0.5  0:04.37 sshd</span><br></pre></td></tr></table></figure><p>输入 “r” 交互命令，会提示输入需要修改优先级的进程的 PID:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Renice PID 18977 to value: 10</span><br><span class="line"><span class="comment">#输入PID后，需要输入Nice的优先级号</span></span><br><span class="line"><span class="comment">#我们把18977进程的优先级调整为10,回车后就能看到</span></span><br><span class="line">PID   USER PR NI  VIRT  RES SHR  S %CPU %MEM   TIME+ COMMAND</span><br><span class="line">18977 root 30 10 11592 3304 2572 R  0.0 0.5  0:04.38 sshd</span><br><span class="line"><span class="comment">#18977进程的优先级已经被修改了</span></span><br></pre></td></tr></table></figure></li><li><p>如果在操作终端执行 top 命令，则并不能看到系统中所有的进程，默认看到的只是 CPU 占比靠前的进程。如果我们想要看到所有的进程，则可以把 top 命令的执行结果重定向到文件中。不过 top 命令是持续运行的，这时就需要使用 “-b” 和 “-n” 选项了。具体命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># top -b -n 1 &gt; /root/top.log</span></span><br><span class="line"><span class="comment">#让top命令只执行一次，然后把执行结果保存到top.log文件中，这样就能看到所有的进程了</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="lsof-列出进程调用或打开的文件信息">lsof 列出进程调用或打开的文件信息</h3><p>lsof 命令，“list opened files”的缩写，直译过来，就是列举系统中已经被打开的文件。通过 lsof 命令，我们就可以根据文件找到对应的进程信息，也可以根据进程信息找到进程打开的文件。</p><p>📌<strong>lsof命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td><code>-c 字符串</code></td><td>只列出以字符串开头的进程打开的文件；</td></tr><tr><td><code>+d 目录名</code></td><td>列出某个目录中所有被进程调用的文件；</td></tr><tr><td><code>-u 用户名</code></td><td>只列出某个用户的进程打开的文件；</td></tr><tr><td><code>-p pid</code></td><td>列出某个 PID 进程打开的文件。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p><code>lsof</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof | more</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询系统中所有进程调用的文件</span></span><br><span class="line">COMMAND PID  USER  FD    TYPE  DEVICE  SIZE/OFF  NODE  NAME</span><br><span class="line">init               1      root    cwd  DIR    8，3       4096        2           /</span><br><span class="line">init               1      root    rtd    DIR    8，3       4096        2           /</span><br><span class="line">init               1      root    txt     REG   8，3       145180    130874 /sbin/init</span><br><span class="line">init               1      root    mem REG   8，3       142472    665291 /lib/ld-2.12.so</span><br><span class="line">init               1      root    mem REG   8，3       58704      655087 /lib/libnss_files-2.12.so</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><p>这个命令的输出非常多。它会按照 PID，从 1 号进程开始列出系统中所有的进程正在调用的文件名。</p></li><li><p><code>lsof 路径</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof /sbin/init</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询某个文件被哪个进程调用</span></span><br><span class="line">COMMAND PID USER  FD  TYPE  DEVICE  SIZE/OFF  NODE    NAME</span><br><span class="line">init               1     root    txt  REG   8，3      145180     130874   /sbin/init</span><br></pre></td></tr></table></figure><p>lsof 命令也可以反过来查询某个文件被哪个进程调用。这个例子就查询到 /sbin/init 文件是被 init 进程调用的。</p></li></ol><h3 id="pstree-查看进程树">pstree 查看进程树</h3><p>Linux pstree(英文全称：display a tree of processes）) 命令将所有进程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本进程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的进程。</p><p>📌<strong>pstree安装</strong>：</p><p>CentOS7 默认没有安装该命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install psmisc</span><br></pre></td></tr></table></figure><p>📌<strong>pstree命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [-options] [[PID][userName]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示启动每个进程对应的完整指令，包括启动进程的路径、参数等。</td></tr><tr><td>-c</td><td>不使用精简法显示进程信息，即显示的进程中包含子进程和父进程。</td></tr><tr><td>-n</td><td>根据进程 PID 号来排序输出，默认是以程序名排序输出的。</td></tr><tr><td>-p</td><td>显示进程的 PID。</td></tr><tr><td>-u</td><td>显示进程对应的用户名称。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p><code>-p</code> 显示进程的 PID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# pstree -p</span><br><span class="line">systemd(1)─┬─NetworkManager(542)─┬─dhclient(628)</span><br><span class="line">           │                     ├─&#123;NetworkManager&#125;(563)</span><br><span class="line">           │                     └─&#123;NetworkManager&#125;(567)</span><br><span class="line">...省略部分输出...</span><br><span class="line">           ├─sshd(893)───sshd(1146)─┬─bash(1150)───pstree(8599)		#Pstree命令进程是在远程连接中被执行的</span><br><span class="line">           │                        ├─bash(1171)───top(1248)</span><br><span class="line">           │                        ├─bash(8589)───sleep(8598)</span><br><span class="line">           │                        └─sftp-server(1165)</span><br><span class="line">           ├─systemd-journal(367)</span><br><span class="line">           ├─systemd-logind(547)</span><br><span class="line">           ├─systemd-udevd(397)</span><br><span class="line">           ├─tuned(891)─┬─&#123;tuned&#125;(1139)</span><br><span class="line">           │            ├─&#123;tuned&#125;(1140)</span><br><span class="line">           │            ├─&#123;tuned&#125;(1142)</span><br><span class="line">           │            └─&#123;tuned&#125;(1143)</span><br><span class="line">           └─vmtoolsd(535)─┬─&#123;vmtoolsd&#125;(562)</span><br><span class="line">                           └─&#123;vmtoolsd&#125;(575)</span><br></pre></td></tr></table></figure></li><li><p>如果想知道某个用户都启动了哪些进程，使用 pstree 命令可以很容易实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@1ocalhost ~]# pstree mysql</span><br><span class="line">mysqid---6*[&#123;mysqid&#125;]</span><br></pre></td></tr></table></figure><p>此输出结果显示了 mysql 用户对应的进程为 mysqid，并且 mysqid 进程拥有 5 个子进程（外加 1 个父进程，共计 6 个进程）。</p></li></ol><h3 id="kill-终止进程">kill 终止进程</h3><p>kill 命令的执行原理是这样的，kill 命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的 PID，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。</p><p>⚠️ <font style="color:red"><strong>注意！</strong><code>/user/sbin/sshd -D</code> 此守护进程不能关闭，否则将无法远程登录，需要去机房重启sshd服务守护进程要谨慎的处理否则可能会造成重大故障！</font></p><p>kill 命令只是“发送”一个信号，因此，只有当信号被程序成功“捕获”，系统才会执行 kill 命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则 kill 命令将会失效。</p><p>📌<strong>kill命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [-options] PID</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-l &lt;信息编号&gt;</code></td><td>打印指定编号的信息名称；<br>若不加&lt;信息编号&gt;选项，则 -l 参数会列出全部的信息名称</td></tr><tr><td><code>-&lt;信息名称或编号&gt; &lt;程序&gt;</code><br><code>-s &lt;信息名称或编号&gt; &lt;程序&gt;</code></td><td>指定要送出的信息。<br><code>-1 nginx</code> #（以信息1为例）nginx 进程重启。<br>详情请看常用信息名称表。<br>&lt;程序&gt;可以是程序的PID或是PGID，也可以是工作编号。</td></tr></tbody></table><p>📌<strong>信息名称表</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]<span class="comment"># kill -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX   </span><br></pre></td></tr></table></figure><p>常用信息名称表：</p><table><thead><tr><th>信息编号</th><th>信息名</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>EXIT</td><td>程序退出时收到该信息。</td></tr><tr><td>1</td><td>HUP</td><td>挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td></tr><tr><td>2</td><td>INT</td><td>表示结束进程，但并不是强制性的，常用的 “Ctrl+C” 组合键发出就是一个 kill -2 的信号。</td></tr><tr><td>3</td><td>QUIT</td><td>退出。</td></tr><tr><td>9</td><td>KILL</td><td>杀死进程，即强制结束进程。</td></tr><tr><td>11</td><td>SEGV</td><td>段错误。</td></tr><tr><td>15</td><td>TERM</td><td>正常结束进程，是 kill 命令的默认信号。</td></tr><tr><td>19</td><td>STOP</td><td>让进程暂停</td></tr></tbody></table><h3 id="killall-终止特定的一类进程">killall 终止特定的一类进程</h3><p>📌<strong>kill命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall [-options] [-signal] PID</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code></td><td>交互式，询问是否要杀死某个进程</td></tr><tr><td><code>-l</code></td><td>忽略进程名的大小写</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>杀死 httpd 进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service httpd start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动RPM包默认安装的apache服务</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;httpd&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root 1600 0.0 0.2 4520 1696? Ss 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1601 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1602 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1603 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1604 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line">daemon 1605 0.0 0.1 4520 1188? S 19:42 0:00 /usr/local/apache2/bin/httpd -k start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看httpd进程</span></span><br><span class="line">[root@localhost ~]# killall httpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">杀死所有进程名是httpd的进程</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;httpd&quot; | grep -v &quot;grep&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询发现所有的httpd进程都消失了</span></span><br></pre></td></tr></table></figure></li><li><p>交互式杀死 sshd 进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux | grep &quot;sshd&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root 1733 0.0 0.1 8508 1008? Ss 19:47 0:00/usr/sbin/sshd</span><br><span class="line">root 1735 0.1 0.5 11452 3296? Ss 19:47 0:00 sshd: root@pts/0</span><br><span class="line">root 1758 0.1 0.5 11452 3296? Ss 19:47 0:00 sshd: root@pts/1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询系统中有3个sshd进程。1733是sshd服务的进程，1735和1758是两个远程连接的进程</span></span><br><span class="line">[root@localhost ~]# killall -i sshd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">交互式杀死sshd进程</span></span><br><span class="line">杀死sshd(1733)?(y/N)n</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个进程是sshd的服务进程，如果杀死，那么所有的sshd连接都不能登陆</span></span><br><span class="line">杀死 sshd(1735)?(y/N)n</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是当前登录终端，不能杀死我自己吧</span></span><br><span class="line">杀死 sshd(1758)?(y/N)y</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">杀死另一个sshd登陆终端</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="crontab-循环执行定时任务">crontab 循环执行定时任务</h3><p>💾<u><code>/var/spool/cron/</code></u></p><p>Linux crontab 是用来定期执行程序的命令。</p><p>crontab 命令需要 crond 服务支持。crond 是 Linux 下用来周期地执行某种任务或等待处理某些事件的一个守护进程，和 Windows 中的计划任务有些类似。</p><p>在安装完成操作系统后，默认会安装 crond 服务工具，且 crond 服务默认就是自启动的。crond 进程每分钟会定期检查是否有要执行的任务，如果有，则会自动执行该任务。</p><p><strong>通过 <code>/etc/cron.allow</code> 和 <code>/etc/cron.deny</code> 文件来限制某些用户是否可以使用 crontab 命令:</strong></p><ul><li>当系统中有 <code>/etc/cron.allow</code> 文件时，只有写入此文件的用户可以使用 crontab 命令，没有写入的用户不能使用 crontab 命令。同样，如果有此文件，<code>/etc/cron.deny</code> 文件会被忽略，因为 <code>/etc/cron.allow</code> 文件的优先级更高。</li><li>当系统中只有 /etc/cron.deny 文件时，写入此文件的用户不能使用 crontab 命令，没有写入文件的用户可以使用 crontab 命令。</li><li>这个规则基本和 at 命令的规则一致，同样是 <code>/etc/cron.allow</code> 文件比 <code>/etc/cron.deny</code> 文件的优先级高，Linux 系统中默认只有 <code>/etc/cron.deny</code> 文件。</li></ul><p>📌<strong>crontab命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><p>每个用户都可以实现自己的 crontab 定时任务，只需使用这个用户身份执行“<code>crontab -e</code>”命令即可。当然，这个用户不能写入 <code>/etc/cron.deny</code> 文件。</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-u user</td><td>用来设定某个用户的 crontab 服务，例如 “-u demo” 表示设备 demo 用户的 crontab 服务，此选项一般有 root 用户来运行。</td></tr><tr><td>-e</td><td>编辑某个用户的 crontab 文件内容。如果不指定用户，则表示编辑当前用户的 crontab 文件。</td></tr><tr><td>-l</td><td>显示某用户的 crontab 文件内容，如果不指定用户，则表示显示当前用户的 crontab 文件内容。</td></tr><tr><td>-r</td><td>从 /var/spool/cron 删除某用户的 crontab 文件，如果不指定用户，则默认删除当前用户的 crontab 文件。</td></tr><tr><td>-i</td><td>在删除用户的 crontab 文件时，给确认提示。</td></tr></tbody></table><p>📌<strong>crontab文件格式</strong>：</p><p>其实 crontab 定时任务非常简单，只需执行“crontab -e”命令，然后输入想要定时执行的任务即可。不过，当我们执行“crontab -e”命令时，打开的是一个空文件，而且操作方法和 Vim 是一致的。那么，这个文件的格式才是我们真正需要学习的内容。文件格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ！]<span class="comment"># crontab -e</span></span><br><span class="line"><span class="comment">#进入 crontab 编辑界面。会打开Vim编辑你的任务</span></span><br><span class="line">* * * * * 执行的任务</span><br></pre></td></tr></table></figure><p>这个文件中是通过 5 个“*”来确定命令或任务的执行时间的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*    *    *    *    *</span><br><span class="line">-    -    -    -    -</span><br><span class="line">|    |    |    |    |</span><br><span class="line">|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class="line">|    |    |    +---------- 月份 (1 - 12)</span><br><span class="line">|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class="line">|    +-------------------- 小时 (0 - 23)</span><br><span class="line">+------------------------- 分钟 (0 - 59)</span><br></pre></td></tr></table></figure><p>在时间表示中，还有一些特殊符号需要学习</p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*（星号）</td><td>代表任何时间。比如第一个&quot;*&quot;就代表一小时种每分钟都执行一次的意思。</td></tr><tr><td>,（逗号）</td><td>代表不连续的时间。比如&quot;0 8,12,16 * * * 命令&quot;就代表在每天的 8 点 0 分、12 点 0 分、16 点 0 分都执行一次命令。</td></tr><tr><td>-（中杠）</td><td>代表连续的时间范围。比如&quot;0 5 * * 1-6 命令&quot;，代表在周一到周六的凌晨 5 点 0 分执行命令。</td></tr><tr><td>/（正斜线）</td><td>代表每隔多久执行一次。比如&quot;* /10* * * * 命令&quot;，代表每隔 10 分钟就执行一次命令。</td></tr></tbody></table><p>当“crontab -e”编辑完成之后，一旦保存退出，那么这个定时任务实际就会写入 <code>/var/spool/cron/</code> 目录中，每个用户的定时任务用自己的用户名进行区分。而且 crontab 命令只要保存就会生效，只要 crond 服务是启动的。</p><p><strong>在书写 crontab 定时任务时，需要注意以下几个事项：</strong></p><ul><li>6 个选项都不能为空，必须填写。如果不确定，则使用“*”代表任意时间。</li><li>crontab 定时任务的最小有效时间是分钟，最大有效时间是月。像 2018 年某时执行、3 点 30 分 30 秒这样的时间都不能被识别。</li><li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都以天为单位，非常容易让管理员混淆。</li><li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都使用绝对路径。有时使用相对路径的命令会报错。</li></ul><h3 id="free-查看内存使用状态">free 查看内存使用状态</h3><p>free 命令用来显示系统内存状态，包括系统物理内存、虚拟内存（swap 交换分区）、共享内存和系统缓存的使用情况，其输出和 top 命令的内存部分非常相似。</p><p>📌<strong>free命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>以 Byte（字节）为单位，显示内存使用情况。</td></tr><tr><td>-h</td><td>显示人性化的内存大小信息</td></tr><tr><td>-k</td><td>以 KB 为单位，显示内存使用情况，此选项是 free 命令的默认选项。</td></tr><tr><td>-l</td><td>显示占用内存的高低</td></tr><tr><td>-m</td><td>以 MB 为单位，显示内存使用情况。</td></tr><tr><td>-g</td><td>以 GB 为单位，显示内存使用情况。</td></tr><tr><td>-t</td><td>在输出的最终结果中，输出内存和 swap 分区的总量。</td></tr><tr><td>-o</td><td>不显示系统缓冲区这一列。</td></tr><tr><td>-s 间隔秒数</td><td>根据指定的间隔时间，持续显示内存使用情况。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># free -m</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1819         762         276          18         779         868</span><br><span class="line">Swap:          2047           0        2047</span><br></pre></td></tr></table></figure><ul><li>total 是总内存数；</li><li>used 是已经使用的内存数；</li><li>free 是空闲的内存数；</li><li>shared 是多个进程共享的内存总数；</li><li>buffers 是缓冲内存数；</li><li>cached 是缓存内存数。</li></ul><h3 id="cal-查看日历">cal 查看日历</h3><p>📌<strong>cal命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [-options] [[[day] month] year]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-1</code>： <code>-one</code></td><td>只显示当前月份(默认)</td></tr><tr><td><code>-3</code>：<code>--three</code></td><td>显示上个月、当月和下个月</td></tr><tr><td><code>-s</code>： <code>--sunday</code></td><td>周日作为一周第一天</td></tr><tr><td><code>-m</code>：<code>--monday</code></td><td>周一作为一周第一天</td></tr><tr><td><code>-j</code>： <code>--julian</code></td><td>输出儒略日（显示每一天是本年的第几天）</td></tr><tr><td><code>-y</code>：<code>--year</code></td><td>输出整年</td></tr></tbody></table><h3 id="date-日期与时间">date 日期与时间</h3><p>📌<strong>date命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> [-options] [MMDDhhmm[[CC]YY][.ss]] +format</span><br></pre></td></tr></table></figure><p>MM为月，DD为天，hh为小时，mm为分钟；CC为年前两位，YY为年的后两位，ss为秒。如： date 010203042016.55。</p><p>显示时间格式（date ‘+%y,%m,%d,%H,%M,%S’）</p><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code>：<code>--date=STRING</code></td><td>显示 datestr 中所设定的时间 (非系统时间)</td></tr><tr><td><code>-s</code>,：<code>--set=STRING</code></td><td>将系统时间设为 datestr 中所设定的时间</td></tr><tr><td><code>-u</code>： <code>--utc</code>：<code>--universal</code></td><td>打印或设置协调世界时（UTC）</td></tr></tbody></table><p>📌<strong>format格式</strong>：</p><table><caption>0. 常用格式</caption><thead><tr><th align="left">format格式</th><th>含义</th></tr></thead><tbody><tr><td align="left">%Y，%y</td><td>年</td></tr><tr><td align="left">%m</td><td>月</td></tr><tr><td align="left">%d</td><td>日</td></tr><tr><td align="left">%H</td><td>时</td></tr><tr><td align="left">%M</td><td>分</td></tr><tr><td align="left">%S</td><td>秒</td></tr></tbody></table><table><caption>1. 时间格式</caption><thead><tr><th align="left">format格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">%</td><td align="left">印出 %</td></tr><tr><td align="left">%n</td><td align="left">下一行</td></tr><tr><td align="left">%t</td><td align="left">跳格</td></tr><tr><td align="left">%H</td><td align="left">小时(00…23)</td></tr><tr><td align="left">%I</td><td align="left">小时(01…12)</td></tr><tr><td align="left">%k</td><td align="left">小时(0…23)</td></tr><tr><td align="left">%l</td><td align="left">小时(1…12)</td></tr><tr><td align="left">%M</td><td align="left">分钟(00…59)</td></tr><tr><td align="left">%p</td><td align="left">显示本地 AM 或 PM</td></tr><tr><td align="left">%r</td><td align="left">直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</td></tr><tr><td align="left">%R</td><td align="left">24小时制方式显示时间，相当于%H:%M</td></tr><tr><td align="left">%s</td><td align="left">从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数</td></tr><tr><td align="left">%S</td><td align="left">秒(00…60)</td></tr><tr><td align="left">%T</td><td align="left">直接显示时间 (24 小时制)</td></tr><tr><td align="left">%X</td><td align="left">相当于 %H:%M:%S</td></tr><tr><td align="left">%z</td><td align="left">数字方式显示时区</td></tr><tr><td align="left">%Z</td><td align="left">字母缩写方式显示时区</td></tr></tbody></table><table><caption>2. 日期格式</caption><thead><tr><th align="left">format格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">%a</td><td align="left">星期几 ，缩写(Sun…Sat)</td></tr><tr><td align="left">%A</td><td align="left">星期几 ，完整英文星期(Sunday…Saturday)</td></tr><tr><td align="left">%b</td><td align="left">月份 (Jan…Dec)</td></tr><tr><td align="left">%B</td><td align="left">月份 (January…December)</td></tr><tr><td align="left">%c</td><td align="left">直接显示日期与时间</td></tr><tr><td align="left">%d</td><td align="left">日 (01…31)</td></tr><tr><td align="left">%D</td><td align="left">直接显示日期 (mm/dd/yy)</td></tr><tr><td align="left">%e</td><td align="left">一个月中的第几天，类似%_d</td></tr><tr><td align="left">%F</td><td align="left">完整的日期，相当于%Y-%m-%d</td></tr><tr><td align="left">%h</td><td align="left">同 %b</td></tr><tr><td align="left">%j</td><td align="left">一年中的第几天 (001…366)</td></tr><tr><td align="left">%m</td><td align="left">月份 (01…12)</td></tr><tr><td align="left">%u</td><td align="left">一周中的第几天 (1…7) (1是星期一)</td></tr><tr><td align="left">%U</td><td align="left">一年中的第几周 (00…53) (以 Sunday 为一周的第一天的情形)</td></tr><tr><td align="left">%w</td><td align="left">一周中的第几天 (0…6)(0是星期天)</td></tr><tr><td align="left">%W</td><td align="left">一年中的第几周 (00…53) (以 Monday 为一周的第一天的情形)</td></tr><tr><td align="left">%x</td><td align="left">直接显示日期 (mm/dd/yy)</td></tr><tr><td align="left">%y</td><td align="left">年份的最后两位数字 (00.99)</td></tr><tr><td align="left">%Y</td><td align="left">完整年份 (0000…9999)</td></tr></tbody></table><h3 id="网络配置">网络配置</h3><p>💾 IP地址配置：　<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code></p><p>💾 网关配置：　　<code>/etc/sysconfig/network</code></p><p>💾 DNS配置：　　<code>/etc/resolv.conf</code></p><p>📌<strong>配置方法</strong>： （<em>静态ip只需执行步骤1、4</em>）</p><ol><li><p>首先要编辑<strong>网卡配置</strong>文件，CentOS7的网卡配置文件路径是：(虚拟机一般为ifcfg-ens33)</p><p><code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>，此路径非常重要，以后企业主机网络不通，可从此配置文件中查看。万一有一天，忘记了，怎么办呢？这里大家 一定要善用find命令；因为我只是知道网卡配置文件在/etc目录下，名字是eth0结尾，因此find命令为：<code>find /etc -iname *eth0</code> 。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/b44a9b802c0a42ecafbcb03d8e99cf2a.png" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/sysconfig/network-script/ifcfg-eth0</span><br><span class="line"> DEVICE=eth0                   # 物理设备名</span><br><span class="line"> IPADDR=192.168.1.10           # IP地址</span><br><span class="line"> NETMASK=255.255.255.0         # 掩码值</span><br><span class="line"> NETWORK=192.168.1.0           # 网络地址 ( 可不要 )</span><br><span class="line"> BROADCAST=192.168.1.255       # 广播地址（ 可不要 ）</span><br><span class="line"> GATEWAY=192.168.1.1           # 网关地址</span><br><span class="line"> ONBOOT=yes                    # [yes|no]（引导时是否激活设备）--开机自启</span><br><span class="line"> USERCTL=no                    # [yes|no]（非root用户是否可以控制该设备）</span><br><span class="line"> BOOTPROTO=static              # [none|static|bootp|dhcp]（引导时不使用协议|静态分配|BOOTP协议|DHCP协议）</span><br></pre></td></tr></table></figure></li><li><p><strong>网关配置：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/sysconfig/network</span><br><span class="line"> NETWORKING=yes</span><br><span class="line"> HOSTNAME=localhost.localdomain</span><br><span class="line"> GATEWAY=192.168.1.1</span><br></pre></td></tr></table></figure></li><li><p><strong>DNS配置：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/resolv.conf </span><br><span class="line">nameserver 192.168.237.200</span><br><span class="line">nameserver 114.114.114.114       # 主DNS</span><br><span class="line">nameserver 8.8.8.8               # 次DNS</span><br></pre></td></tr></table></figure><p>第三方的 DNS 服务器：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/1049141419-0.jpg" alt="img"></p></li><li><p><strong>重启网络服务：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务重启</span></span><br><span class="line">[root@localhost ~]# systemctl restart network</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">脚本重启,一般不必这样执行</span></span><br><span class="line">[root@localhost ~]# /etc/init.d/network restart</span><br></pre></td></tr></table></figure></li></ol><h3 id="ss-网络状态工具">ss 网络状态工具</h3><p>📄<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34493319/article/details/124764072">Linux系统–ss命令详解</a></p><p>ss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息，它显示的内容和 netstat 类似。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快。当服务器的 socket 连接数量变得非常大时，无论是使用 netstat 命令还是直接 cat /proc/net/tcp，执行速度都会很慢。ss 命令利用到了 TCP 协议栈中 tcp_diag。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，因此 ss 命令的性能会好很多。</p><p>ss命令可以提供如下信息：</p><ul><li><p>所有的TCP sockets</p></li><li><p>所有的UDP sockets</p></li><li><p>所有ssh/ftp/ttp/https持久连接</p></li><li><p>所有连接到Xserver的本地进程，使用state（例如：connected, synchronized, SYN-RECV, SYN-SENT,TIME-WAIT）、地址、端口过滤</p></li><li><p>所有的state FIN-WAIT-1 tcpsocket连接以及更多</p></li></ul><p>📌<strong>ss命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss [-options] [filter]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><p>常用选项</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-s</td><td>列出当前socket详细信息</td></tr><tr><td>-t, --tcp</td><td>显示 TCP 协议的 sockets</td></tr><tr><td>-u, --udp</td><td>显示 UDP 协议的 sockets</td></tr><tr><td>-x, --unix</td><td>显示 unix domain sockets，与 -f 选项相同</td></tr><tr><td>-n, --numeric</td><td>不解析服务的名称，如 “22” 端口不会显示成 “ssh”</td></tr><tr><td>-l, --listening</td><td>只显示处于监听状态的端口</td></tr><tr><td>-p, --processes</td><td>显示监听端口的进程(Ubuntu 上需要 sudo)</td></tr><tr><td>-a, --all</td><td>对 TCP 协议来说，既包含监听的端口，也包含建立的连接</td></tr><tr><td>-r, --resolve</td><td>把 IP 解释为域名，把端口号解释为协议名称</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p><code>-lntup</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ss -lntup | grep nginx</span></span><br><span class="line">tcp    LISTEN     0      128       *:80       *:*       <span class="built_in">users</span>:((&quot;nginx&quot;,pid=<span class="number">843</span>,fd=<span class="number">6</span>),(&quot;nginx&quot;,pid=<span class="number">841</span>,fd=<span class="number">6</span>))</span><br></pre></td></tr></table></figure><h3 id="netstat-查看网络状态">netstat 查看网络状态</h3><p>📌<strong>netstat安装</strong>：</p><p>CentOS7 默认没有安装该命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install net-tools</span><br></pre></td></tr></table></figure><p>📌<strong>netstat命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><strong>-a或–all</strong></td><td>显示所有连线中的Socket。</td></tr><tr><td>-A&lt;网络类型&gt;或–&lt;网络类型&gt;</td><td>列出该网络类型连线中的相关地址。</td></tr><tr><td>-c或–continuous</td><td>持续列出网络状态。</td></tr><tr><td>-C或–cache</td><td>显示路由器配置的快取信息。</td></tr><tr><td>-e或–extend</td><td>显示网络其他相关信息。</td></tr><tr><td>-F或–fib</td><td>显示路由缓存。</td></tr><tr><td>-g或–groups</td><td>显示多重广播功能群组组员名单。</td></tr><tr><td>-h或–help</td><td>在线帮助。</td></tr><tr><td>-i或–interfaces</td><td>显示网络界面信息表单。</td></tr><tr><td><strong>-l或–listening</strong></td><td>显示监控中的服务器的Socket。</td></tr><tr><td>-M或–masquerade</td><td>显示伪装的网络连线。</td></tr><tr><td><strong>-n或–numeric</strong></td><td>直接使用IP地址，而不通过域名服务器。</td></tr><tr><td>-N或–netlink或–symbolic</td><td>显示网络硬件外围设备的符号连接名称。</td></tr><tr><td>-o或–timers</td><td>显示计时器。</td></tr><tr><td><strong>-p或–programs</strong></td><td>显示正在使用Socket的程序识别码和程序名称。</td></tr><tr><td><strong>-r或–route</strong></td><td>显示Routing Table。</td></tr><tr><td>-s或–statistics</td><td>显示网络工作信息统计表。</td></tr><tr><td>-t或–tcp</td><td>显示TCP传输协议的连线状况。</td></tr><tr><td>-u或–udp</td><td>显示UDP传输协议的连线状况。</td></tr><tr><td>-v或–verbose</td><td>显示指令执行过程。</td></tr><tr><td>-V或–version</td><td>显示版本信息。</td></tr><tr><td>-w或–raw</td><td>显示RAW传输协议的连线状况。</td></tr><tr><td>-x或–unix</td><td>此参数的效果和指定&quot;-A unix&quot;参数相同。</td></tr><tr><td>–ip或–inet</td><td>此参数的效果和指定&quot;-A inet&quot;参数相同。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># netstat -tunlp | grep nginx	# 查看网络信息,也可填进程或端口</span></span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      841/nginx: master p </span><br><span class="line"></span><br><span class="line">[root@docker01 ~]<span class="comment"># netstat -anp | grep 80</span></span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      841/nginx: master p </span><br><span class="line">tcp6       0      0 127.0.0.1:10050         127.0.0.1:34680         TIME_WAIT   -                   </span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     28880    1107/master          private/defer</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     29681    1000/dockerd         /var/run/docker/libnetwork/a17803d03212.sock</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># netstat -anp | grep 3306 | wc -l # 统计进程数，如果接近预设值，说明不够用，需要增加</span></span><br></pre></td></tr></table></figure><h3 id="ping-测试网络的连通信">ping 测试网络的连通信</h3><p>不管在windows平台，还是在linux平台，ping都是非常常用的网络命令；ping命令通过ICMP（Internet控制消息协议）工作；ping可以用来测试本机与目标主机是否联通、联通速度如何、稳定性如何。</p><p>在网络中ping是一个十分强大的TCP/IP工具。它的作用主要为：</p><ul><li>用来检测网络的连通情况和分析网络速度</li><li>根据域名得到服务器IP</li><li>根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。</li></ul><p>📌<strong>ping命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [-options] address</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>使用Socket的SO_DEBUG功能。</td></tr><tr><td><font style="color:red"><code>-c &lt;完成次数&gt;</code></font></td><td>设置完成要求回应的次数。</td></tr><tr><td>-f</td><td>极限检测。</td></tr><tr><td><font style="color:red">-i&lt;间隔秒数&gt;</font></td><td>指定收发信息的间隔时间。</td></tr><tr><td><code>-I &lt;网络界面&gt;</code></td><td>使用指定的网络接口送出数据包。</td></tr><tr><td><code>-l &lt;前置载入&gt;</code></td><td>设置在送出要求信息之前，先行发出的数据包。</td></tr><tr><td>-n</td><td>只输出数值。</td></tr><tr><td><code>-p&lt;范本样式&gt;</code></td><td>设置填满数据包的范本样式。</td></tr><tr><td>-q</td><td>不显示指令执行过程，开头和结尾的相关信息除外。</td></tr><tr><td>-r</td><td>忽略普通的Routing Table，直接将数据包送到远端主机上。</td></tr><tr><td>-R</td><td>记录路由过程。</td></tr><tr><td><font style="color:red"><code>-s&lt;数据包大小&gt;</code></font></td><td>设置数据包的大小。</td></tr><tr><td><font style="color:red"><code>-t &lt;存活数值&gt;</code></font></td><td>设置存活数值TTL的大小。</td></tr><tr><td>-v</td><td>详细显示指令的执行过程。</td></tr><tr><td><code>-w &lt;deadline&gt;</code></td><td>在 deadline 秒后退出。</td></tr><tr><td><code>-W &lt;timeout&gt;</code></td><td>在等待 timeout 秒后开始执行。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ping baidu.com</span></span><br><span class="line">PING baidu.com (39.156.66.10) 56(84) bytes of data.</span><br><span class="line">64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=1 ttl=128 time=46.4 ms</span><br><span class="line">64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=2 ttl=128 time=46.2 ms</span><br><span class="line">64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=3 ttl=128 time=46.3 ms</span><br></pre></td></tr></table></figure><ul><li><p>bytes值：数据包大小，也就是字节。</p></li><li><p>time值：响应时间，这个时间越小，说明你连接这个地址速度越快。</p></li><li><p>TTL值：Time To Live,表示DNS记录在DNS服务器上存在的时间，它是IP协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过Ping返回的TTL值大小，粗略地判断目标系统类型是Windows系列还是UNIX/Linux系列。</p></li></ul><h3 id="traceroute-追踪路由">traceroute 追踪路由</h3><p>📌<strong>traceroute安装</strong>：</p><p>CentOS7 默认没有安装该命令。</p><h3 id="ifconfig-显示或配置网络设备">ifconfig 显示或配置网络设备</h3><p>ifconfig可以手动启动、观察与修改网络接口的相关参数，可以修改的参数很多，包括 IP 参数以及 MTU 等都可以修改。</p><p>📌<strong>ifconfig命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [interface] [options]</span><br></pre></td></tr></table></figure><ul><li>Interface，网卡接口代号，包括 eth0、eth1、ppp0 等</li><li>Options，可以接的选项</li></ul><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>参数</th></tr></thead><tbody><tr><td>Up或down</td><td>启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)</td></tr><tr><td>mtu</td><td>可以设置不同的 MTU 数值，例如MTU 1500 (单位为 byte)</td></tr><tr><td>netmask</td><td>子屏蔽网络</td></tr><tr><td>broadcast</td><td>广播地址</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>观察所有的网络接口(直接输入 ifconfig)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@linux ~]<span class="comment"># ifconfig</span></span><br><span class="line">eth0 Link encap:Ethernet  HWaddr 00:0F:EA:A3:06:A2</span><br><span class="line">      inet addr:192.168.10.100  Bcast:192.168.10.255  </span><br><span class="line">Mask:255.255.255.0</span><br><span class="line">      inet6 addr: fe80::20f:eaff:fe73:682/64 Scope:Link</span><br><span class="line">      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">      RX packets:3439 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">      TX packets:2735 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">      collisions:0 txqueuelen:1000</span><br><span class="line">      RX bytes:646935 (631.7 KiB)  TX bytes:562313 (549.1 KiB)</span><br><span class="line">      Interrupt:209 Memory:fb000000-0</span><br></pre></td></tr></table></figure><p>一般来说，直接输入 ifconfig 就会列出目前已经被启动的卡，不论这个卡是否有设置 IP，都会被显示出来。而如果是输入 ifconfig eth0，则会显示出这个接口的相关数据，而不管该接口是否启动。所以，如果你想要知道某个网卡的 Hardware Address，直接输入“ifconfig “网络接口代号””即可。至于上述代码中出现的各项数据是这样的（数据排列由上而下、由左而右）。</p><ul><li>eth0：网卡的代号，也有 lo 这个 loopback。</li><li>HWaddr：网卡的硬件地址，习惯称为 MAC。</li><li>inet addr：IPv4 的 IP 地址，后续的 Bcase、Mask 分别代表的是 Broadcast 与 Netmask。</li><li>inet6 addr：是 IPv6 的版本的 IP，我们没有使用，所以略过。</li><li>RX：那一行代表的是网络由启动到目前为止的数据包接收情况，packets 代表数据包数、errors 代表数据包发生错误的数量、dropped 代表数据包由于有问题而遭丢弃的数量等。</li><li>TX：与 RX 相反，为网络由启动到目前为止的传送情况。</li><li>collisions：代表数据包碰撞的情况，如果发生太多次，表示你的网络状况不太好。</li><li>txqueuelen：代表用来传输数据的缓冲区的储存长度。</li><li>RX Bytes、TX Bytes：总传送、接收的字节总量。</li><li>Interrupt、Memory：网卡硬件的数据，IRQ 岔断与内存地址。</li></ul><p>通过观察上述的资料，大致上可以了解到你的网络情况，尤其是 RX、TX 内的 error 数量，以及是否发生严重的 collision 情况，都是需要注意的。</p></li><li><p>暂时修改网络接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[root@linux ~]<span class="comment"># ifconfig eth0 192.168.100.100</span></span><br><span class="line"><span class="comment"># 如果不加任何其他参数，则系统会依照该 IP 所在的 class 范围，</span></span><br><span class="line"><span class="comment"># 自动地计算出 netmask 以及 network, broadcast 等 IP 参数</span></span><br><span class="line"></span><br><span class="line">[root@linux ~]<span class="comment"># ifconfig eth0 192.168.100.100 netmask 255.255.255.128 \</span></span><br><span class="line">&gt; mtu 8000 </span><br><span class="line"><span class="comment"># 设置网络接口，同时设置 MTU 的数值</span></span><br><span class="line"></span><br><span class="line">[root@linux ~]<span class="comment"># ifconfig eth0 MTU 9000</span></span><br><span class="line"><span class="comment"># 仅修改该接口的 MTU 数值，其他的保持不动</span></span><br><span class="line"></span><br><span class="line">[root@linux ~]<span class="comment"># ifconfig eth0:0 192.168.50.50</span></span><br><span class="line"><span class="comment"># 仔细看那个接口， eth0:0 。那就是在该网络接口上，再仿真一个网络接口，</span></span><br><span class="line"><span class="comment"># 亦即是在一个网卡上面设置多个 IP 的意思啦</span></span><br><span class="line"></span><br><span class="line">[root@linux ~]<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0F:EA:A3:06:A2</span><br><span class="line">          inet addr:192.168.10.100 Bcast:192.168.10.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3669 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:2892 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:667547 (651.9 KiB)  TX bytes:584799 (571.0 KiB)</span><br><span class="line">          Interrupt:209 Memory:fb000000-0</span><br><span class="line"></span><br><span class="line">eth0:0    Link encap:Ethernet  HWaddr 00:0F:EA:A3:06:A2</span><br><span class="line">          inet addr:192.168.200.2 Bcast:192.168.200.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          Interrupt:209 Memory:fb000000-0</span><br><span class="line"><span class="comment"># 仔细看，是否与硬件有关的信息都相同。没错。因为是同一个网卡。</span></span><br><span class="line"></span><br><span class="line">[root@linux ~]<span class="comment"># ifconfig eth0:0 down</span></span><br><span class="line"><span class="comment"># 关掉 eth0:0 这个接口。如果想要启动 eth1 ，并且不设置任何网络参数</span></span><br><span class="line"><span class="comment"># ifconfig eth1 up 就可以实现</span></span><br><span class="line"></span><br><span class="line">[root@linux ~]<span class="comment"># /etc/init.d/network restart</span></span><br><span class="line"><span class="comment"># 刚刚设置的数据全部失效，会以 ifcfg-ethx 的设置为主</span></span><br></pre></td></tr></table></figure><p>使用 ifconfig 可以暂时用手动来设置或修改某个适配卡的相关功能，并且也可以通过 eth0:0 这种虚拟的网络接口来设置一张网卡上面的多个 IP。手动的方式是比较简单。而且设置错误也没有关系，因为我们可以利用 /etc/init.d/network restart 来重新启动整个网络接口，那么之前手动的设置数据会全部失效。另外，要启动某个网络接口，但又不让它具有 IP 参数时，直接给它 ifconfig eth0 up 即可。这个操作经常在无线网卡当中进行，因为我们需要启动无线网卡让它去检测 AP 存在与否。</p></li></ol><h3 id="ip-addr-查看IP地址">ip addr 查看IP地址</h3><p>💾<code>/etc/sysconfig/network-scripts/&lt;网卡名&gt;</code></p><p>使用命令的方式增加或者删除路由记录<strong>都是临时的</strong>，如果重启network服务，那么操作就失效了。想要永久生效可以编辑配置文件<code>/etc/sysconfig/network-scripts/route-eth*</code>。</p><p>📌<strong>ip addr命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr [[options] [interface]]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td></td><td>空选项，查看当前所有网卡信息</td></tr><tr><td><code>show device</code></td><td>查看指定网卡的信息</td></tr><tr><td><code>add ip/netmask dev 接口</code></td><td>增加ip</td></tr><tr><td><code>del ip/netmask dev 接口</code></td><td>删除ip</td></tr><tr><td><code>flush dev 接口</code></td><td>清空指定网卡的所有ip</td></tr><tr><td><code>add ip/netmask dev eth0 label eth0:1</code></td><td>给 <code>eh0</code> 取别名 <code>eth0:1</code></td></tr><tr><td><code>del ip/netmask dev eth0 [label eth0:1]</code></td><td>删除别名</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>虚拟机上执行<code>ip addr</code>命令结果有两部分，<code>lo</code>和<code>enp0s3</code>，如果有多块网卡，每块网卡都会显示一部分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 00:0c:29:30:e0:5a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.0.111/24 brd 10.0.0.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::423a:d794:f794:b784/64 scope <span class="built_in">link</span> noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><blockquote><p>lo：全称loopback，是回环地址，一般被分配到127.0.0.1地址上，用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</p><p>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; - 网络设备状态标识：</p><p>UP：网卡处于启动状态。</p><p>BROADCAST：网卡可以发广播包。</p><p>MULTICAST：网卡可以发多播包。</p><p>LOWER_UP：L1是启动的，L1指的是物理层，即网线是插着的。</p><p>mtu：最大传输单元（mtu）。</p><p>enp0s3：网卡名，如果有多块网卡，会有多个类似这种名称的网卡。</p><p>link/ether：MAC地址，一块网卡有一个MAC地址。</p><p>inet：IPV4地址，一块网卡可以绑定多个IPV4地址。</p><p>inet6：IPV6地址，一块网卡可以绑定多个IPV6地址。</p><blockquote><p>scope {global|link|host}]：指明作用域</p><ul><li>global: 全局可用，即两个接口进来的数据我都可以响应。是默认状态</li><li>link: 仅链接可用，进来的数据只有直接相连的那个接口能够响应</li><li>host: 本机可用，即只能自己访问</li></ul></blockquote></blockquote><h3 id="shutdown-halt-poweroff-reboot-init-关机和重启"><code>shutdown</code> <code>halt</code> <code>poweroff</code> <code>reboot</code> <code>init</code> 关机和重启</h3><p>⚠️重启前请使用 <code>sync</code> 将数据从内存同步到硬盘。</p><p>📌<strong>shutdown</strong>：关机或重启</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>在指定时间重启计算机。</td></tr><tr><td>-h</td><td>在指定时间关闭计算机。</td></tr><tr><td>-p</td><td>关闭操作系统，并调用poweroff关闭电源。</td></tr><tr><td>-k</td><td>向系统中的登录者发送警告信息，并不真正执行关机操作。</td></tr><tr><td>-c</td><td>取消目前正在执行的关机程序。这个选项没有时间参数，但是可以输入一个用来解释的讯息，而这信息将会送到每位系统登录者。</td></tr></tbody></table><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>shutdown -h 12:00</td><td>系统将在12时准时关机。</td></tr><tr><td>shutdown -h now</td><td>立刻关机。</td></tr><tr><td>shutdown -r now</td><td>立刻重启系统。</td></tr><tr><td>shutdown -h +10</td><td>系统将在10分钟后关机。</td></tr></tbody></table><p>📌<strong>halt</strong>：关闭正在运行的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=linux">linux</a>操作系统</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>关机时不执行sync操作，相关操作不写入日志文件‘/var/log/wtmp’中。</td></tr><tr><td>-w</td><td>不真正的关机，仅在日志文件‘/var/log/wtmp’中添加相应的记录。</td></tr><tr><td>-d</td><td>关机，相关操作不写入日志文件‘/var/log/wtmp’中。</td></tr><tr><td>-f</td><td>强制关机，不调用shutdown操作。</td></tr><tr><td>-i</td><td>关机前关掉所有的网络接口。</td></tr><tr><td>-p</td><td>关机后切断系统电源。</td></tr></tbody></table><p>📌<strong>poweroff</strong>：关闭正在运行的linux操作系统并切断系统电源</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>关机时不执行sync操作，相关操作不写入日志文件‘/var/log/wtmp’中。</td></tr><tr><td>-w</td><td>不真正的关机，仅在日志文件‘/var/log/wtmp’中添加相应的记录。</td></tr><tr><td>-d</td><td>关机，相关操作不写入日志文件‘/var/log/wtmp’中。</td></tr><tr><td>-f</td><td>强制关机，不调用shutdown操作。</td></tr><tr><td>-i</td><td>关机前关掉所有的网络接口。</td></tr></tbody></table><p>📌<strong>reboot</strong>：重启正在运行的linux操作系统</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>重启时不执行sync操作，相关操作不写入日志文件‘/var/log/wtmp’中。</td></tr><tr><td>-w</td><td>不真正的重启，仅在日志文件‘/var/log/wtmp’中添加相应的记录。</td></tr><tr><td>-d</td><td>重启，相关操作不写入日志文件‘/var/log/wtmp’中。</td></tr><tr><td>-f</td><td>强制重启，不调用shutdown操作。</td></tr><tr><td>-i</td><td>重启前关掉所有的网络接口。</td></tr></tbody></table><p>📌<strong>init</strong>：操作系统启动运行方式</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>init 0</td><td>表示关机。</td></tr><tr><td>init 6</td><td>表示重启。</td></tr><tr><td>init 1</td><td>表示单用户命令行模式。</td></tr><tr><td>init 2</td><td>表示没有网络的多用户命令行模式。</td></tr><tr><td>init 3</td><td>表示多用户命令行模式（推荐使用这个模式）。</td></tr><tr><td>init 4</td><td>表示预留的未使用。</td></tr><tr><td>init 5</td><td>表示图形界面模式（安装有图形界面的系统的默认启动级别）。</td></tr></tbody></table><h3 id="服务运行级别">服务运行级别</h3><p>💾<u><code>vim /etc/inittab</code></u></p><p>Linux系统有7种运行级别（runlevel）：</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则无法正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li><li>运行级别2：多用户状态（没有NFS），不支持网络</li><li><font style="background:#ff0">运行级别3</font>：完全的多用户状态（有NFS），无界面，登录后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登录后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><p>📌<strong>init</strong>：使用<code>init</code>控制上篇中已经列举。</p><p>📌<strong>开机流程</strong>：</p><p>1️⃣CentOS 6</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/18572620-3a9bd2a5777e5a78.png" alt="img"></p><ol><li>开机加电自检 — 检查bios中识别的硬件信息是否正常</li><li>开机MBR引导 — /boot分区引导系统启动的记录信息（MBR引导记录–系统启动文件信息/分区表信息）</li><li>grup选择菜单 — 可以选择系统内核信息/可以选择进入单用户模</li><li>加载内核信息 — 用于管理控制硬件</li><li>启动系统进程 — /sbin/init — 后续进程启动（串型—详见图）注：后续进程被第一个进程所管理。查看init下面的服务是第几号开机 是第几号关机。</li><li>加载启动级别文件 — 加载/etc/inittab 选择不同级别启动系统</li><li>运行初始化脚本 — /etc/rc.d/rc.sysinit 设置主机名称 设置网卡地址信息</li><li>执行服务运行脚本 — /etc/rc.d/rc 实现服务开机自动运行</li><li>启动mingetty进程 — 显示登录提示信息</li></ol><p>2️⃣CentOS 7</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/18572620-b1a779f51bd3ec82.png" alt="img"></p><ol><li>开机加电自检 — 检查bios中识别的硬件信息是否正常</li><li>开机MBR引导 — /boot分区引导系统启动的记录信息（MBR引导记录–系统启动文件信息/分区表信息）</li><li>grup选择菜单 — 可以选择系统内核信息/可以选择进入单用户模式</li><li>加载内核信息 — 用于管理控制硬件</li><li>启动系统进程 — /usr/lib/systemd/systemd — 后续进程启动（并型）</li><li>加载启动target文件 — /etc/systemd/system/default.target 选择不同级别启动系统</li><li>加载系统初始化文件 — /usr/lib/systemd/system/sysinit.target 设置主机名称 设置网卡地址信息</li><li>执行服务运行脚本 — /etc/systemd/system 实现服务开机自动运行<br>/usr/lib/systemd/system/ 保存系统中所有程序启动文件</li><li>启动mingetty进程 — 显示登录提示信息</li></ol><p>📌<strong>运行级别操作</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前默认运行级别</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl get-default</span></span><br><span class="line"><span class="comment"># 修改默认运行级别</span></span><br><span class="line">[root@localhost ~]<span class="comment"># systemctl set-default TARGET.target</span></span><br></pre></td></tr></table></figure><blockquote><p>CentOS7后运行级别简化，如下：</p><p>multi-user.target # 等价于原运行级别3（多用户有网，无图形界面）</p><p>graphical.target # 等价于原运行级别5（多用户有网，有图形界面）</p></blockquote><h3 id="service-OS6">service (OS6)</h3><p>💾<u><code>/etc/init.d</code></u></p><p>服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，因此我们又称为守护进程。</p><p>service 指令管理的服务在 <code>/etc/init.d</code> 查看。<strong>在CentOS7.0后很多服务不再使用<code>service</code>，而是<code>systemctl</code>。</strong></p><p>📌<strong>service命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service 服务名 [start | stop | restart | status]</span><br></pre></td></tr></table></figure><p>📌<strong>示例说明</strong>：</p><p>配置 service 服务（以tomcat的服务为例）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/init.d/tomcat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># description: Tomcat8 Start Stop Restart</span></span><br><span class="line"><span class="comment"># processname: tomcat8</span></span><br><span class="line"><span class="comment"># chkconfig: 345 99 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CATALINA_HOME=/usr/local/tomcat8</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        start)</span><br><span class="line">                sh <span class="variable">$CATALINA_HOME</span>/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        stop)</span><br><span class="line">                sh <span class="variable">$CATALINA_HOME</span>/bin/shutdown.sh</span><br><span class="line">                ;;</span><br><span class="line">        restart)</span><br><span class="line">                sh <span class="variable">$CATALINA_HOME</span>/bin/shutdown.sh</span><br><span class="line">                sh <span class="variable">$CATALINA_HOME</span>/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&#x27;please use : tomcat &#123;start | stop | restart&#125;&#x27;</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 755 /etc/init.d/tomcat</span></span><br></pre></td></tr></table></figure><h3 id="chkconfig-OS6">chkconfig (OS6)</h3><p>💾<u><code>/etc/init.d/rcN.d</code></u></p><p>chkconfig命令主要用来更新（启动或停止）和查询系统服务的运行级信息。谨记chkconfig不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。</p><p>📌<strong>chkconfig命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig -options</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><blockquote><p><code>--add name</code> 　增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。</p><p><code>--del name</code> 　删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据。</p><p><code>--level &lt;等级代号&gt;</code>：设置某一服务在指定的运行级是被启动，停止还是重置。</p><blockquote><p>level选项可以指定要查看的运行级而不一定是当前运行级。对于每个运行级，只能有一个启动脚本或者停止脚本。当切换运行级时，init不会重新启动已经启动的服务，也不会再次去停止已经停止的服务。等级代号:</p><ul><li><p>等级0表示：表示关机</p></li><li><p>等级1表示：单用户模式</p></li><li><p>等级2表示：无网络连接的多用户命令行模式</p></li><li><p>等级3表示：有网络连接的多用户命令行模式</p></li><li><p>等级4表示：不可用</p></li><li><p>等级5表示：带图形界面的多用户模式</p></li><li><p>等级6表示：重新启动</p></li></ul></blockquote><p><code>--list [name]</code>：显示所有运行级系统服务的运行状态信息（on或off）。如果指定了name，那么只显示指定的服务在不同运行级的状态。</p></blockquote><p>📌<strong>示例说明</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list        <span class="comment">#列出所有的系统服务</span></span><br><span class="line">chkconfig --add httpd        <span class="comment">#增加httpd服务</span></span><br><span class="line">chkconfig --del httpd        <span class="comment">#删除httpd服务</span></span><br><span class="line">chkconfig --level httpd 2345 on        <span class="comment">#设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态</span></span><br><span class="line">chkconfig --list        <span class="comment">#列出系统所有的服务启动情况</span></span><br><span class="line">chkconfig --list mysqld        <span class="comment">#列出mysqld服务设置情况</span></span><br><span class="line">chkconfig --level 35 mysqld on        <span class="comment">#设定mysqld在等级3和5为开机运行服务，--level 35表示操作只在等级3和5执行，on表示启动，off表示关闭</span></span><br><span class="line">chkconfig mysqld on        <span class="comment">#设定mysqld在各等级为on，“各等级”包括2、3、4、5等级</span></span><br></pre></td></tr></table></figure><h3 id="systemctl-OS7">systemctl (OS7)</h3><p>💾 <code>/usr/lib/systemd/system</code></p><p>在Centos 中 systemctl 是设置系统服务的命令，即 service , 它融合之前service和chkconfig的功能于一体。 可以使用它永久性或只在当前会话中启用/禁用服务。 CentOS 7 的 /etc/rc.d/rc.local 是没有执行权限的， 系统建议创建 systemd service 启动服务。</p><p>📌<strong>systemctl命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl [start|stop|restart|status] 服务名</span><br></pre></td></tr></table></figure><p>📌<strong>服务管理命令</strong>：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><span style="background:#ff0"><strong>systemctl start 服务名</strong></span></td><td><strong>开启服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl stop 服务名</strong></span></td><td><strong>关闭服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl status 服务名</strong></span></td><td><strong>显示状态</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl restart 服务名</strong></span></td><td><strong>重启服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl enable 服务名</strong></span></td><td><strong>开机启动服务</strong></td></tr><tr><td><span style="background:#ff0"><strong>systemctl disable 服务名</strong></span></td><td><strong>禁止开机启动</strong></td></tr><tr><td>systemctl list-units</td><td>查看系统中所有正在运行的服务</td></tr><tr><td>systemctl list-unit-files</td><td>查看系统中所有服务的开机启动状态</td></tr><tr><td>systemctl list-dependencies 服务名</td><td>查看系统中服务的依赖关系</td></tr><tr><td>systemctl mask 服务名</td><td>冻结服务</td></tr><tr><td>systemctl unmask 服务名</td><td>解冻服务</td></tr><tr><td>systemctl set-default multi-user.target</td><td>开机时不启动图形界面</td></tr><tr><td>systemctl set-default graphical.target</td><td>开机时启动图形界面</td></tr><tr><td><span style="background:#ff0"><strong>systemctl daemon-reload</strong></span></td><td><strong>修改服务配置文件后，重新载入</strong></td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p><strong>配置 systemctl 服务</strong>（以nginx的服务为例）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]<span class="comment"># systemctl cat nginx</span></span><br><span class="line"><span class="comment"># /usr/lib/systemd/system/nginx.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server	<span class="comment"># 注释、描述</span></span><br><span class="line">Documentation=http://nginx.org/en/docs/	<span class="comment"># 帮助或文档</span></span><br><span class="line">After=network-online.target remote-fs.target nss-lookup.target	<span class="comment"># 核心 nginx在这些服务后才能执行（依赖）</span></span><br><span class="line">Wants=network-online.target	<span class="comment"># 依赖</span></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking	<span class="comment"># 服务类型</span></span><br><span class="line">PIDFile=/var/run/nginx.pid</span><br><span class="line"><span class="comment"># Environment=&quot;&quot; # 环境</span></span><br><span class="line">ExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.conf	<span class="comment"># 服务启动</span></span><br><span class="line">ExecReload=/bin/sh -c <span class="string">&quot;/bin/kill -s HUP <span class="subst">$(/bin/cat /var/run/nginx.pid)</span>&quot;</span>	<span class="comment"># 服务重启</span></span><br><span class="line">ExecStop=/bin/sh -c <span class="string">&quot;/bin/kill -s TERM <span class="subst">$(/bin/cat /var/run/nginx.pid)</span>&quot;</span>	<span class="comment"># 服务关闭</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target	<span class="comment"># 指定运行级别</span></span><br></pre></td></tr></table></figure><h3 id="iptables（OS6）">iptables（OS6）</h3><p>💾<code>/etc/sysconfig/iptables</code></p><h3 id="span-id-firewall-firewall-span-（0S7）"><span id="firewall">firewall</span>（0S7）</h3><p>💾<code>/etc/firewalld/zones/public.xml</code> 💻<code>firewalld.service</code></p><p>⚠️<span style="color:orange;background:red">打开防火墙后一定要先添加ssh端口(22)到规则中，并重新载入</span></p><p>在真正是生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。CentOS7采用新的firewalld，CentOS6及以前版本采用iptables，不过firewalld底层仍然调用的是iptables</p><p>firewalld 配置文件在 <code>/etc/firewalld</code> 和 <code>/usr/lib/firewalld</code>。如果名称相同的配置文件同时存储 在两个位置中，则将使用 <code>/etc/firewalld</code> 中的版本。</p><p>📌<strong>firewall命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --options</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><blockquote><p>firewall-cmd 可以执行 firewall-config 能够执行的相同操作。在使用 firewall-cmd 命令时：</p><p><code>--permanent</code>：使所有命令永久生效。如果更改可能诱发危险，则可以不指定-–permanent 参数，使更改 仅在运行状态下生效。</p><p><code>--zone=</code>：用来指定所影响的区域，如果未指定–zone=参数，则将使用默认区域。</p><blockquote><p>firewalld防火墙为了简化管理，将所有网络流量分为多个区域（zone）。然后根据数据包的源IP地址或传入的网络接口等条件将流量传入相应区域，每个区域都定义了自己打开或者关闭的端口和服务列表。</p><ul><li>区域（zone）是针对特定位置或场景（例如家庭、公共、受信任等）可能具有的各种信任级别的规则集。</li><li>不同的区域（zone）可允许不同的网络服务和入站流量的类型，而拒绝其他任何流量。</li></ul><p>firewalld 的9个区域：</p><ul><li>public(公共) —— [默认]公网访问，不受任何限制。</li><li>work(工作) —— 用于工作区。基本信任的网络，仅仅接收经过选择的连接。</li><li>home(家庭) —— 用于家庭网络。基本信任的网络，仅仅接收经过选择的连接。</li><li>trusted(信任) —— 接收的外部网络连接是可信任、可接受的。</li><li>block(限制) —— 任何接收的网络连接都被IPv4的icmp-host-prohibited信息和IPv6的icmp6-adm-prohibited信息所拒绝。</li><li>dmz(隔离区) —— 英文&quot;demilitarized zone&quot;的缩写，此区域内可公开访问，它是非安全系统与安全系统之间的缓冲区。</li><li>drop(丢弃) —— 任何接收的网络数据包都被丢弃，没有任何回复。仅能有发送出去的网络连接。</li><li>external(外部) —— 允许指定的外部网络进入连接，特别是为路由器启用了伪装功能的外部网。</li><li>internal(内部) —— 内部访问。只限于本地访问，其他不能访问。</li></ul></blockquote><p><code>--reload</code>：重新载入规则。配置防火墙时，管理员如果使用–permanent 参数更改配置，再使用 firewall-cmd --reload 来使更改生效。</p><p><code>--timeout=</code>：指定某些更改在一定的时间后自动删除，从而防止意外锁定某个系统。</p><p><code>--state</code>：查看防火墙状态</p><p><code>--list-ports</code>：查看所有打开的端口</p><p><code>--get-active-zones</code>：查看区域信息</p><p><code>--add-port=22/tcp</code>：添加规则</p><p><code>--remove-port=22/tcp</code>：删除规则</p><p><code>--query-port=22/tcp</code>：查看规则状态</p><p><code>--panic-on</code>：拒绝所有包</p><p><code>--panic-off</code>：取消拒绝状态</p><p><code>--query-panic</code>：查看是否拒绝</p><p><code>--add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;10.1.1.14/32&quot; port protocol=&quot;tcp&quot; port=&quot;80&quot; accept&quot;</code>：开启某个端口（指定IP可访问）</p><p><code>--remove-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;10.1.1.14/32&quot; port protocol=&quot;tcp&quot; port=&quot;80&quot; accept&quot;</code>：关闭某个端口（删除策略）</p><p><code>--get-services</code>：显示服务列表</p><p><code>--add-service=ssh</code>：允许SSH服务通过</p><p><code>--remove-service=ssh</code>：禁止SSH服务通过</p><p><code>--list-services</code>：显示当前服务</p><p><code>--list-all</code>：查看防火墙，添加的端口也可以看到</p><p><code>--enable service=samba --timeout=600</code>：临时允许Samba服务通过600秒</p><p><code>--get-zone-of-interface=eth0</code>：查看指定接口所属区域</p><p><code>--complete-reload</code>：完全重新载入规则（会中断已连接的连接，类似于重启）</p><p><code>--list-all-zones</code>：列出所有区域的设置</p><p><code>--add-rich-rule='rule protocol value=icmp drop'</code>：禁止ping数据包</p></blockquote><h3 id="journalctl">journalctl</h3><h3 id="homenamectl-配置主机名">homenamectl 配置主机名</h3><p>💾<code>/etc/hostname</code></p><p>📌<strong>homenamectl常用命令</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl	<span class="comment"># 查看主机名</span></span><br><span class="line">hostnamectl set-hostname newname	<span class="comment"># 修改主机名</span></span><br></pre></td></tr></table></figure><p>📌<strong>修改配置文件修改主机名</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;newhostname&quot;</span> &gt; /etc/hostname</span><br></pre></td></tr></table></figure><h2 id="文件系统管理">文件系统管理</h2><h3 id="df-查看文件系统硬盘使用情况">df 查看文件系统硬盘使用情况</h3><p>Linux df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。包括文件系统所在硬盘分区的总容量、已使用的容量、剩余容量等。</p><p>整个文件系统有关的数据，都保存在 Super block（超级块）中，而 df 命令主要读取的数据几乎都针对的是整个文件系统，所以 df 命令主要是从各文件系统的 Super block 中读取数据。</p><p>📌<strong>df命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> [-options] [目录或文件名]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><font style="color:red"><code>-a</code></font></td><td>显示所有文件系统信息，包括系统特有的 /proc、/sysfs 等文件系统；</td></tr><tr><td><code>-m</code></td><td>以 MB 为单位显示容量；</td></tr><tr><td><code>-k</code></td><td>以 KB 为单位显示容量，默认以 KB 为单位；</td></tr><tr><td><font style="color:red"><code>-h</code></font></td><td>使用人们习惯的 KB、MB 或 GB 等单位自行显示容量；</td></tr><tr><td><font style="color:red"><code>-T</code></font></td><td>显示该分区的文件系统名称；</td></tr><tr><td><code>-i</code></td><td>不用硬盘容量显示，而是以含有 inode 的数量来显示。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>正常使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df</span><br><span class="line">Filesystem      1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2         9920624   3823112   5585444  41% /</span><br><span class="line">/dev/hdc3         4956316    141376   4559108   4% /home</span><br><span class="line">/dev/hdc1          101086     11126     84741  12% /boot</span><br><span class="line">tmpfs              371332         0    371332   0% /dev/shm</span><br></pre></td></tr></table></figure><blockquote><p>由 df 命令显示出的各列信息的含义分别是：</p><ul><li>Filesystem：表示该文件系统位于哪个分区，因此该列显示的是设备名称；</li><li>1K-blocks：此列表示文件系统的总大小，默认以 KB 为单位；</li><li>Used：表示用掉的硬盘空间大小；</li><li>Available：表示剩余的硬盘空间大小；</li><li>Use%：硬盘空间使用率。如果使用率高达 90% 以上，就需要额外注意，因为容量不足，会严重影响系统的正常运行；</li><li>Mounted on：文件系统的挂载点，也就是硬盘挂载的目录位置。</li></ul></blockquote></li><li><p>-aT</p><p>注意，使用 -a 选项，会将很多特殊的文件系统显示出来，这些文件系统包含的大多是系统数据，存在于内存中，不会占用硬盘空间，因此你会看到，它们所占据的硬盘总容量为 0。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -aT</span><br><span class="line">Filesystem    Type 1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/hdc2     ext3   9920624 3823112   5585444  41% /</span><br><span class="line">proc          proc         0       0         0   -  /proc</span><br><span class="line">sysfs        sysfs         0       0         0   -  /sys</span><br><span class="line">devpts      devpts         0       0         0   -  /dev/pts</span><br><span class="line">/dev/hdc3     ext3   4956316  141376   4559108   4% /home</span><br><span class="line">/dev/hdc1     ext3    101086   11126     84741  12% /boot</span><br><span class="line">tmpfs        tmpfs    371332       0    371332   0% /dev/shm</span><br><span class="line">none   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc</span><br><span class="line">sunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs</span><br></pre></td></tr></table></figure></li></ol><h3 id="du-统计目录或文件所占磁盘空间大小">du 统计目录或文件所占磁盘空间大小</h3><p>du 是统计目录或文件所占磁盘空间大小的命令。</p><p>需要注意的是，使用&quot;ls -r&quot;命令是可以看到文件的大小的。但是大家会发现，在使用&quot;ls -r&quot;命令査看目录大小时，目录的大小多数是 4KB，这是因为目录下的子目录名和子文件名是保存到父目录的 block（默认大小为 4KB）中的，如果父目录下的子目录和子文件并不多，一个 block 就能放下，那么这个父目录就只占用了一个 block 大小。大家可以将其想象成图书馆的书籍目录和实际书籍。如果我们用&quot;ls-l&quot;命令査看，则只能看到这些书籍占用了 1 页纸的书籍目录，但是实际书籍到底有多少是看不到的，哪怕它堆满了几个房间。</p><p>但是我们在统计目录时，不是想看父目录下的子目录名和子文件名到底占用了多少空间，而是想看父目录下的子目录和子文件的总磁盘占用量大小，这时就需要使用 du 命令才能统计目录的真正磁盘占用量大小。</p><p>📌<strong>du命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> [-options] [目录或文件名]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</td></tr><tr><td><code>-h</code></td><td>使用习惯单位显示磁盘占用量，如 KB、MB 或 GB 等</td></tr><tr><td><code>-s</code></td><td>统计总磁盘占用量，而不列出子目录和子文件的磁盘占用量</td></tr></tbody></table><p>📌<strong>du命令和df命令的区别</strong></p><p>有时我们会发现，使用 du 命令和 df 命令去统计分区的使用情况时，得到的数据是不一样的。那是因为df命令是从文件系统的角度考虑的，通过文件系统中未分配的空间来确定文件系统中已经分配的空间大小。也就是说，在使用 df 命令统计分区时，不仅要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除，但是程序并没有释放空间）。</p><p>而 du 命令是面向文件的，只会计算文件或目录占用的磁盘空间。也就是说，df 命令统计的分区更准确，是真正的空闲空间。</p><h3 id="lsblk-查看设备挂载情况">lsblk 查看设备挂载情况</h3><p>lsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。</p><p>📌<strong>lsblk命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-d</code></td><td>仅列出磁盘本身，并不会列出该磁盘的分区数据</td></tr><tr><td><code>-f</code></td><td>同时列出该磁盘内的文件系统名称</td></tr><tr><td><code>-i</code></td><td>使用 ASCII的线段输出，不要使用复杂的编码（再某些环境下很有用）</td></tr><tr><td><code>-m</code></td><td>同时输出该装置在 /dev 底下的权限数据（rwx 的数据）</td></tr><tr><td><code>-p</code></td><td>列出该装置的完整文件名!而不是仅列出最后的名字而已。</td></tr><tr><td><code>-t</code></td><td>列出该磁盘装置的详细数据，包括磁盘队列机制、预读写的数据量大小等</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>-p参数之后就显示出了完整的文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# lsblk -p</span><br><span class="line">NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">/dev/sda      8:0    0   20G  0 disk </span><br><span class="line">├─/dev/sda1   8:1    0  300M  0 part /boot</span><br><span class="line">├─/dev/sda2   8:2    0    1G  0 part [SWAP]</span><br><span class="line">└─/dev/sda3   8:3    0 18.7G  0 part /</span><br><span class="line">/dev/sr0     11:0    1 1024M  0 rom  </span><br></pre></td></tr></table></figure></li><li><p>-f 参数之后就显示出了uuid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# lsblk -f</span><br><span class="line">NAME   FSTYPE LABEL UUID                                 MOUNTPOINT</span><br><span class="line">sda                                                      </span><br><span class="line">├─sda1 xfs          f8e94199-eac8-45d5-9cff-80f7696d8fe3 /boot</span><br><span class="line">├─sda2 swap         9aaf14d0-ed51-4220-b5fd-032b7ae14e36 [SWAP]</span><br><span class="line">└─sda3 xfs          0f37330d-bb9f-43b4-a71f-463043b5c786 /</span><br><span class="line">sr0   </span><br><span class="line">[root@loaclhost ~]#</span><br><span class="line">[root@loaclhost ~]# blkid</span><br><span class="line">/dev/sda1: UUID=&quot;f8e94199-eac8-45d5-9cff-80f7696d8fe3&quot; TYPE=&quot;xfs&quot; </span><br><span class="line">/dev/sda2: UUID=&quot;9aaf14d0-ed51-4220-b5fd-032b7ae14e36&quot; TYPE=&quot;swap&quot; </span><br><span class="line">/dev/sda3: UUID=&quot;0f37330d-bb9f-43b4-a71f-463043b5c786&quot; TYPE=&quot;xfs&quot;</span><br></pre></td></tr></table></figure><p>① 上面演示了使用-f参数显示分区的uuid,其实直接使用blkid也是可以显示uuid的。</p><p>② 使用parted命令可以显示分区的格式（Partition Table）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# parted /dev/sda print</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sda: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    Type     File system     标志</span><br><span class="line"> 1      1049kB  316MB   315MB   primary  xfs             启动</span><br><span class="line"> 2      316MB   1389MB  1074MB  primary  linux-swap(v1)</span><br><span class="line"> 3      1389MB  21.5GB  20.1GB  primary  xfs</span><br></pre></td></tr></table></figure></li></ol><h3 id="mount-umount-挂载-卸载">mount/umount 挂载/卸载</h3><p>💾<u><code>/etc/fatab</code></u></p><p>1️⃣<strong>mount 挂载</strong></p><p>所有的硬件设备必须挂载之后才能使用，只不过，有些硬件设备（比如硬盘分区）在每次系统启动时会自动挂载，而有些（比如 U 盘、光盘）则需要手动进行挂载。挂载指的是将硬件设备的文件系统和 Linux 系统中的文件系统，通过指定目录（作为挂载点）进行关联。而要将文件系统挂载到 Linux 系统上，就需要使用 mount 挂载命令。</p><p>📌<strong>mount命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-options] 设备文件名 挂载点</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-t 系统类型</td><td>指定欲挂载的文件系统类型。Linux 常见的支持类型有 EXT2、EXT3、EXT4、iso9660（光盘格式）、vfat、reiserfs 等。如果不指定具体类型，挂载时 Linux 会自动检测；</td></tr><tr><td>-L 卷标名</td><td>除了使用设备文件名（例如 /dev/hdc6）之外，还可以利用文件系统的卷标名称进行挂载；</td></tr><tr><td>-n</td><td>在默认情况下，系统会将实际挂载的情况实时写入 /etc/mtab 文件中，但在某些场景下（例如单人维护模式），为了避免出现问题，会刻意不写入，此时就需要使用这个选项；</td></tr><tr><td>-o 特殊选项</td><td>可以指定挂载的额外选项，比如读写权限、同步/异步等，如果不指定，则使用默认值（defaults）。具体的特殊选项参见表 1（挂载参数）。</td></tr></tbody></table><table><thead><tr><th>-o 特殊选项</th><th>功能</th></tr></thead><tbody><tr><td>rw/ro</td><td>是否对挂载的文件系统拥有读写权限，rw 为默认值，表示拥有读写权限；ro 表示只读权限。</td></tr><tr><td>async/sync</td><td>此文件系统是否使用同步写入（sync）或异步（async）的内存机制，默认为异步 async。</td></tr><tr><td>dev/nodev</td><td>是否允许从该文件系统的 block 文件中提取数据，为了保证数据安装，默认是 nodev。</td></tr><tr><td>auto/noauto</td><td>是否允许此文件系统被以 mount -a 的方式进行自动挂载，默认是 auto。</td></tr><tr><td>suid/nosuid</td><td>设定文件系统是否拥有 SetUID 和 SetGID 权限，默认是拥有。</td></tr><tr><td>exec/noexec</td><td>设定在文件系统中是否允许执行可执行文件，默认是允许。</td></tr><tr><td>user/nouser</td><td>设定此文件系统是否允许让普通用户使用 mount 执行实现挂载，默认是不允许（nouser），仅有 root 可以。</td></tr><tr><td>defaults</td><td>定义默认值，相当于 rw、suid、dev、exec、auto、nouser、async 这 7 个选项。</td></tr><tr><td>remount</td><td>重新挂载已挂载的文件系统，一般用于指定修改特殊权限。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>挂载分区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /mnt/disk1</span></span><br><span class="line"><span class="comment">#建立挂载点目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount /dev/sdb1 /mnt/disk1</span></span><br><span class="line"><span class="comment">#挂载分区</span></span><br></pre></td></tr></table></figure><p>2️⃣<strong>umount 卸载</strong></p><p>umount（英文全拼：unmount 命令用于卸载已经挂载的硬件设备。</p><p>📌<strong>umount命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-options] 设备文件名或挂载点</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>卸除/etc/mtab中记录的所有文件系统。</td></tr><tr><td>-h</td><td>显示帮助。</td></tr><tr><td>-n</td><td>卸除时不要将信息存入/etc/mtab文件中。</td></tr><tr><td>-r</td><td>若无法成功卸除，则尝试以只读的方式重新挂入文件系统。</td></tr><tr><td>-t&lt;文件系统类型&gt;</td><td>仅卸除选项中所指定的文件系统。</td></tr><tr><td>-v</td><td>执行时显示详细的信息。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>下面两条命令分别通过设备名和挂载点卸载文件系统，同时输出详细信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过设备名卸载</span></span><br><span class="line">[root@localhost ~]<span class="comment"># umount -v /dev/sda1         </span></span><br><span class="line">/dev/sda1 umounted  </span><br><span class="line"><span class="comment"># 通过挂载点卸载 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># umount -v /mnt/mymount/</span></span><br><span class="line">/tmp/diskboot.img umounted </span><br></pre></td></tr></table></figure><p>如果设备正忙，卸载即告失败。卸载失败的常见原因是，我们已经进入了挂载点，在执行 umount 命令之前，用户须退出挂载目录。</p><p><font style="color:#fff;background:grey">卸载硬件设备成功与否，除了执行 umount 命令不报错之外，还可以使用 <code>df</code> 命令或 <code>mount -l</code> 来查看目标设备是否还挂载在系统中。</font></p><h3 id="etc-fatab-配置-开机自动挂载硬件设备">/etc/fatab 配置-开机自动挂载硬件设备</h3><p>如果我们想实现开机自动挂载某个硬件设备，需要使用 root 身份在 /etc/fstab 文件中添加此设备即可。</p><p>📌<strong>查看 <code>/etc/fatab</code></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /etc/fstab</span></span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults 1 1</span><br><span class="line">UUID=0b23d315-33a7-48a4-bd37-9248e5c44345 /boot ext4 defaults 1 2</span><br><span class="line">UUID=4021be19-2751-4dd2-98cc-383368c39edb swap swap defaults 0 0</span><br><span class="line">\<span class="comment">#只有这三个是真正的硬盘分区，下面的都是虚拟文件系统或交换分区</span></span><br><span class="line">tmpfs /dev/shm tmpfs defaults 0 0</span><br><span class="line">devpts /dev/pts devpts gid=5, mode=620 0 0</span><br><span class="line">sysfs /sys sysfe defaults 0 0</span><br><span class="line">proc /proc proc defaults 0 0</span><br><span class="line"><span class="comment"># 字段的含义:</span></span><br><span class="line"><span class="comment"># UUID/文件名 挂载点 文件系统的类型 各种挂载参数 指定分区是否被dump备份 指定分区是否被fsck检测</span></span><br></pre></td></tr></table></figure><blockquote><p>tmpfs、devpts、sysfs 和 proc 这几行，它们分别是与共享内存、终端窗口、设备信息和内核参数相关联的特殊设备。</p></blockquote><p>📌<strong>字段的含义</strong></p><p><strong>UUID</strong></p><p>UUID 即通用唯一标识符，是一个 128 位比特的数字，可以理解为就是硬盘的 ID，UUID 由系统自动生成和管理。</p><p>① 用 dumpe2fs 命令（后续会讲）就可以查看到每个分区的 UUID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs /dev/sdb5</span><br><span class="line">dumpe2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem volume name: test_label</span><br><span class="line">Last mounted on: &lt;not available&gt;</span><br><span class="line">Filesystem UUID: 63f238f0-a715-4821-8ed1-b3d18756a3ef</span><br><span class="line">\#UUID</span><br><span class="line">...省略部分输出..</span><br></pre></td></tr></table></figure><p>② 也可以通过查看每个硬盘UUID的链接文件名来确定UUID:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /dev/disk/by-uuid/</span><br><span class="line">总用量 0</span><br><span class="line">Irwxrwxrwx. 1 root root 10 4 月 11 00:17 0b23d315-33a7-48a4-bd37-9248e5c44345</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sdal</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4 月 11 00:17 4021 be19-2751 -4dd2-98cc-383368c39edb</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sda2</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4 月 11 00:17 63f238f0-a715-4821-8ed1-b3d18756a3ef</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sdb5</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4月 11 00:17 6858b440-ad9e-45cb-b411 -963c5419e0e8</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sdb6</span></span><br><span class="line">Irwxrwxrwx. 1 root root 10 4月 11 00:17 c2ca6f57-b15c-43ea-bca0-f239083d8bd2</span><br><span class="line"><span class="meta prompt_">-&gt; </span><span class="language-bash">../../sda3</span></span><br></pre></td></tr></table></figure><p><strong>挂载点</strong></p><p>需要强调的是，挂载点一定要是已经建立的空目录。</p><p><strong>文件系统类型</strong></p><p>默认文件系统是 ext4。</p><table><thead><tr><th>文件系统</th><th>描 述</th></tr></thead><tbody><tr><td>Ext</td><td>Linux 中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用,是为 Linux 核心所做的第一个文件系统，最大可支持 2GB 的文件系统。</td></tr><tr><td>Ext2</td><td>是 Ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是 Ext2 文件系统。于 1993 年发布，支持最大 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024x1024KB) Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成。 目录项:包括文件名和inode节点号。 Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。 数据块：文件的具体内容存放地。 将硬盘分区时会划分出目录块、inode Table区块和data block数据区域。一个文件由一个目录项、inode和数据区域块组成。 Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。 当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据</td></tr><tr><td>Ext3</td><td>是 Ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大 2TB 的文件</td></tr><tr><td>Ext4</td><td>是 Ext3 文件系统的升级版。Ext4 在性能、伸缩性和可靠性方面进行了大量改进。Ext4 的变化可以说是翻天覆地的，比如向下兼容 Ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块 概念、多块分配、延迟分配、持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、默认启用 barrier 等。它是 CentOS 6.3 的默认文件系统</td></tr><tr><td>xfs</td><td>被业界称为最先进、最具有可升级性的文件系统技术，由 SGI 公司设计，目前最新的 CentOS 7 版本默认使用的就是此文件系统。</td></tr><tr><td>swap</td><td>swap 是 Linux 中用于交换分区的文件系统（类似于 Windows 中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的 2 倍，但是不要超过 2GB。它是 Linux 的必需分区</td></tr><tr><td>NFS</td><td>NFS 是网络文件系统（Network File System）的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td></tr><tr><td>iso9660</td><td>光盘的标准文件系统。Linux 要想使用光盘，必须支持 iso9660 文件系统</td></tr><tr><td>fat</td><td>就是 Windows 下的 fatl6 文件系统，在 Linux 中识别为 fat</td></tr><tr><td>vfat</td><td>就是 Windows 下的 fat32 文件系统，在 Linux 中识别为 vfat。支持最大 32GB 的分区和最大 4GB 的文件</td></tr><tr><td>NTFS</td><td>就是 Windows 下的 NTFS 文件系统，不过 Linux 默认是不能识别 NTFS 文件系统的，如果需要识别，则需要重新编译内核才能支持。它比 fat32 文件系统更加安全，速度更快，支持最大 2TB 的分区和最大 64GB 的文件</td></tr><tr><td>ufs</td><td>Sun 公司的操作系统 Solaris 和 SunOS 所采用的文件系统</td></tr><tr><td>proc</td><td>Linux 中基于内存的虚拟文件系统，用来管理内存存储目录 /proc</td></tr><tr><td>sysfs</td><td>和 proc —样，也是基于内存的虚拟文件系统，用来管理内存存储目录 /sysfs</td></tr><tr><td>tmpfs</td><td>也是一种基于内存的虚拟文件系统，不过也可以使用 swap 交换分区</td></tr></tbody></table><p><strong>挂载参数</strong></p><p>参数和 mount 命令的挂载参数一致。</p><p><strong>指定分区是否被 dump 备份</strong></p><p>0 代表不备份，1 代表备份，2 代表不定期备份。</p><p><strong>指定分区是否被 fsck 检测</strong></p><p>0 代表不检测，其他数字代表检测的优先级，1 的优先级比 2 高。所以先检测 1 的分区，再检测 2 的分区。一般分区的优先级是 1，其他分区的优先级是 2。</p><h3 id="fdisk-磁盘分区">fdisk 磁盘分区</h3><p>⚠️<font style="color:red"><strong>注意！</strong></font>千万不要在当前物理机的硬盘上尝试使用 fdisk，这会完整删除整个系统，一定要再找一块硬盘，或者使用虚拟机。</p><p>我们在安装操作系统的过程中已经对系统硬盘进行了分区，但如果新添加了一块硬盘，想要正常使用就需要使用fdisk分区。</p><p>在 Linux 中有专门的分区命令 fdisk 和 parted。其中 fdisk 命令较为常用，但不支持大于 2TB 的分区；如果需要支持大于 2TB 的分区，则需要使用 parted 命令，当然 parted 命令也能分配较小的分区。</p><p>📌<strong>fdisk命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk [-options]</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说 明</th></tr></thead><tbody><tr><td>-b<size></size></td><td>扇区大小(512、1024、2048或4096)</td></tr><tr><td>-c</td><td>兼容模式：“dos”或“nondos”(默认)</td></tr><tr><td>-l</td><td>列出指定的外围设备的分区表状况</td></tr><tr><td>-h</td><td>打印此帮助文本</td></tr><tr><td>-u<size></size></td><td>搭配&quot;-l&quot;参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址；<br>显示单位：“cylinders”(柱面)或“sectors”(扇区，默认)；</td></tr><tr><td>-v</td><td>打印版本信息</td></tr><tr><td>-C<number></number></td><td>指定柱面数</td></tr><tr><td>-H<number></number></td><td>指定磁头数</td></tr><tr><td>-S<number></number></td><td>指定每个磁道的扇区数</td></tr></tbody></table><p>📌<strong>分区交互界面的命令</strong>：</p><table><thead><tr><th>命令</th><th>说 明</th></tr></thead><tbody><tr><td>a</td><td>设置可引导标记</td></tr><tr><td>b</td><td>编辑 bsd 磁盘标签</td></tr><tr><td>c</td><td>设置 DOS 操作系统兼容标记</td></tr><tr><td>d</td><td>删除一个分区</td></tr><tr><td>1</td><td>显示已知的文件系统类型。82 为 Linux swap 分区，83 为 Linux 分区</td></tr><tr><td>m</td><td>显示帮助菜单</td></tr><tr><td>n</td><td>新建分区</td></tr><tr><td>0</td><td>建立空白 DOS 分区表</td></tr><tr><td>P</td><td>显示分区列表</td></tr><tr><td>q</td><td>不保存退出</td></tr><tr><td>s</td><td>新建空白 SUN 磁盘标签</td></tr><tr><td>t</td><td>改变一个分区的系统 ID</td></tr><tr><td>u</td><td>改变显示记录单位</td></tr><tr><td>V</td><td>验证分区表</td></tr><tr><td>w</td><td>保存退出</td></tr><tr><td>X</td><td>附加功能（仅专家）</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>显示当前分区情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># fdisk -l							#查询本机可以识别的硬盘和分区</span></span><br><span class="line">Disk /dev/sda:32.2 GB, 32212254720 bytes				<span class="comment">#硬盘文件名和硬盘大小</span></span><br><span class="line">255 heads, 63 sectors/track, 3916 cylinders				<span class="comment">#共255个磁头、63个扇区和3916个柱面</span></span><br><span class="line">Units = cylinders of 16065 *512 = 8225280 bytes			<span class="comment">#每个柱面的大小</span></span><br><span class="line">Sector size (logical/physical): 512 bytes/512 bytes		<span class="comment">#每个扇区的大小</span></span><br><span class="line">I/O size (minimum/optimal): 512 bytes/512 bytes			<span class="comment">#硬盘文件名和硬盘大小</span></span><br><span class="line">Disk identifier: 0x0009e098</span><br><span class="line"></span><br><span class="line">Device Boot Start End Blocks ld System					<span class="comment">#设备文件名启动分区 起始柱面 终止柱面容量 ID 系统</span></span><br><span class="line">/dev/sda1 * 1 26 204800 83 Linux</span><br><span class="line">Partition 1 does not end on cylinder boundary.			<span class="comment">#分区1没有占满硬盘</span></span><br><span class="line">/dev/sda2 26 281 2048000 82 Linux swap / Solaris</span><br><span class="line">Partition 2 does not end on cylinder boundary			<span class="comment">#分区2没有占满硬盘</span></span><br><span class="line">/dev/sda3 281 3917 29203456 83 Linux</span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes				<span class="comment">#第二个硬盘识别，这个硬盘的大小</span></span><br><span class="line">255 heads, 63 sectors/track, 2610 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes/512 bytes Disk identifier: 0x00000000</span><br></pre></td></tr></table></figure><blockquote><ul><li>Device：分区的设备文件名。</li><li>Boot：是否为启动引导分区，在这里 /dev/sda1 为启动引导分区。</li><li>Start：起始柱面，代表分区从哪里开始。</li><li>End：终止柱面，代表分区到哪里结束。</li><li>Blocks：分区的大小，单位是 KB。</li><li>id：分区内文件系统的 ID。在 fdisk 命令中，可以 使用 “i” 查看。</li><li>System：分区内安装的系统是什么。</li></ul></blockquote><h3 id="parted-大容量磁盘分区">parted 大容量磁盘分区</h3><p>⚠️<font style="color:red"><strong>注意！</strong></font>parted 中所有的操作都是立即生效的，没有保存生效的概念。这一点和 fdisk 交互命令明显不同，所以做的所有操作大家要加倍小心。</p><p>虽然我们可以使用 fdisk命令对硬盘进行快速的分区，但对高于 2TB 的硬盘分区，此命令却无能为力，此时就需要使用 parted 命令。</p><p>📌<strong>parted命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parted 硬盘设备文件名	<span class="comment">#进入交互模式</span></span><br></pre></td></tr></table></figure><p>📌<strong>分区交互界面的命令</strong>：</p><table><thead><tr><th>parted交互命令</th><th>说 明</th></tr></thead><tbody><tr><td>check NUMBER</td><td>做一次简单的文件系统检测</td></tr><tr><td>cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER</td><td>复制文件系统到另一个分区</td></tr><tr><td>help [COMMAND]</td><td>显示所有的命令帮助</td></tr><tr><td>mklabel,mktable LABEL-TYPE</td><td>创建新的磁盘卷标（分区表）</td></tr><tr><td>mkfs NUMBER FS-TYPE</td><td>在分区上建立文件系统</td></tr><tr><td>mkpart PART-TYPE [FS-TYPE] START END</td><td>创建一个分区</td></tr><tr><td>mkpartfs PART-TYPE FS-TYPE START END</td><td>创建分区，并建立文件系统</td></tr><tr><td>move NUMBER START END</td><td>移动分区</td></tr><tr><td>name NUMBER NAME</td><td>给分区命名</td></tr><tr><td>print [devices|free|list,all|NUMBER]</td><td>显示分区表、活动设备、空闲空间、所有分区</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>rescue START END</td><td>修复丢失的分区</td></tr><tr><td>resize NUMBER START END</td><td>修改分区大小</td></tr><tr><td>rm NUMBER</td><td>删除分区</td></tr><tr><td>select DEVICE</td><td>选择需要编辑的设备</td></tr><tr><td>set NUMBER FLAG STATE</td><td>改变分区标记</td></tr><tr><td>toggle [NUMBER [FLAG]]</td><td>切换分区表的状态</td></tr><tr><td>unit UNIT</td><td>设置默认的单位</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p><strong>进入交互</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打算继续划分/dev/sdb硬盘</span></span><br><span class="line">GNU Parted 2.1</span><br><span class="line">使用/dev/sdb</span><br><span class="line">Welcome to GNU Parted! Type &#x27;help&#x27; to view a list of commands.</span><br><span class="line">(parted)   &lt;--parted 的等待输入交互命令的位置，输入 help，可以看到在交互模式下支持的所有命令</span><br></pre></td></tr></table></figure><p><strong>查看分区表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入<span class="built_in">print</span>指令</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">硬盘参数，是虚拟机</span></span><br><span class="line">Disk/dev/sdb: 21.5GB</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">硬盘大小</span></span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扇区大小</span></span><br><span class="line">Partition Table: msdos</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区表类型，是MBR分区表</span></span><br><span class="line">Number Start End Size Type File system 标志</span><br><span class="line">1 32.3kB 5379MB 5379MB primary</span><br><span class="line">2 5379MB 21.5GB 16.1GB extended</span><br><span class="line">5 5379MB 7534MB 2155MB logical ext4</span><br><span class="line">6 7534MB 9689MB 2155MB logical ext4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">看到了我们使用fdisk命令创建的分区，其中1分区没被格式化；2分区是扩展分区，不能被格式化</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 print 命令可以査看分区表信息，包括硬盘参数、硬盘大小、扇区大小、分区表类型和分区信息。分区信息共有 7 列，分别如下：</p><ol><li>Number：分区号，比如，1号就代表 /dec/sdb1；</li><li>Start：分区起始位置。这里不再像 fdisk 那样用柱面表示，使用字节表示更加直观；</li><li>End：分区结束位置；</li><li>Size：分区大小；</li><li>Type：分区类型，有 primary、extended、logical 等类型；</li><li>Filesystem：文件系统类型；</li><li>标志：分区的标记。</li></ol></blockquote><p><strong>修改成 GPT 分区表</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(partcd) mklabel gpt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改分区表命令</span></span><br><span class="line">警告：正在使用/dev/sdb上的分区。由于/dev/sdb分区已经挂载，所以有警告。注意，如果强制修改，那么原有分区及数据会消失</span><br><span class="line">忽略/Ignore/放弃/Cancel? ignore</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入ignore忽略报错</span></span><br><span class="line">警告：The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入 <span class="built_in">yes</span></span></span><br><span class="line">警告：WARNING: the kernel failed to re-read the partition table on /dev/sdb (设 备或资源忙）.As a result, it may not reflect all of your changes until after reboot.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下次重启后才能生效</span></span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下分区表</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区表已经变成 GPT</span></span><br><span class="line">Number Start End Size File system Name 标志</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有的分区都消失了</span></span><br></pre></td></tr></table></figure><p>修改了分区表，如果这块硬盘上已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才能生效。</p><p>另外，我们转换分区表的目的是支持大于 2TB 的分区，如果分区并没有大于 2TB，那么这一步是可以不执行的。</p><p><font style="color:red">注意，一定要把 /etc/fstab 文件和原有分区中的内容删除才能重启，否则会报错。</font></p><p><strong>建立分区</strong></p><p>因为修改过了分区表，所以/dev/sdb硬盘中的所有数据都消失了，我们就可以重新对这块硬盘分区了。不过，在建立分区时，默认文件系统就只能是 ext2 了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(parted)mkpart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入创建分区命令，后面不要参数，全部靠交互</span></span><br><span class="line">指定</span><br><span class="line">分区名称？ []?disk1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区名称，这里命名为disk 1</span></span><br><span class="line">文件系统系统？ [ext2]?</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件系统类型，直接回车，使用默认文件系统ext2</span></span><br><span class="line">起始点？ 1MB</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区从1MB开始</span></span><br><span class="line">结束点？5GB分区到5GB结束</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区完成</span></span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B Partition Table: gpt</span><br><span class="line">Number Start End Size Rle system Name 标志</span><br><span class="line">1 1049kB 5000MB 4999MB disk1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区1已经出现</span></span><br></pre></td></tr></table></figure><p>不知道大家有没有注意到，我们现在用 print 查看的分区和第一次查看 MBR 分区表的分区时有些不一样了，少了 Type 这个字段，也就是分区类型字段，多了 Name（分区名）字段。分区类型是用于标识主分区、扩展分区和逻辑分区的，不过这种标识只在 MBR 分区表中使用，现在已经变成了 GPT 分区表，所以就不再有 Type 类型了。</p><p><strong>建立文件系统</strong></p><p>分区分完后，还需要进行格式化。我们知道，如果使用 parted 交互命令格式化，则只能格式化成 ext2 文件系统。我们在这里要演示一下 parted 命令的格式化方法，所以就格式化成 ext2 文件系统。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkfs</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式化命令（很奇怪，也是mkfs，但是这只是parted的交互命令）</span></span><br><span class="line">WARNING: you are attempting to use parted to operate on (mkfs) a file system.</span><br><span class="line">parted&#x27;s file system manipulation code is not as robust as what you&#x27;ll find in</span><br><span class="line">dedicated, file-system-specific packages like e2fsprogs. We recommend</span><br><span class="line">you use parted only to manipulate partition tables, whenever possible.</span><br><span class="line">Support for performing most operations on most types of file systems</span><br><span class="line">will be removed in an upcoming release.</span><br><span class="line">警告：The existing file system will be destroyed and all data on the partition will be lost. Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">警告你格式化丟失，没关系，已经丢失过了</span></span><br><span class="line">分区编号？ 1</span><br><span class="line">文件系统类型 [ext2]?</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定文件系统类型，写别的也没用，直接回车</span></span><br><span class="line">(parted) print #格式化完成，查看一下</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21,5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Number Start End Size File system Name标志</span><br><span class="line">1 1049kB 5000MB 4999MB ext2 diski</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拥有了文件系统</span></span><br></pre></td></tr></table></figure><p>如果要格式化成 ext4 文件系统，那么请 mkfs 命令帮忙吧（注意：不是 parted 交互命令中的 mkfs，而是系统命令 mkfs)。</p><p><strong>调整分区大小</strong></p><p>parted 命令还有一大优势，就是可以调整分区的大小（在 Windows 中也可以实现，不过要么需要转换成动态磁盘，要么需要依赖第三方工具，如硬盘分区魔术师）。起始 Linux 中 LVM 和 RAID 是可以支持分区调整的，不过这两种方法也可以看成动态磁盘方法，使用 parted 命令调整分区更加简单。</p><p><font style="color:red">注意，parted 调整已经挂载使用的分区时，是不会影响分区中的数据的，也就是说，数据不会丢失。但是一定要先卸载分区，再调整分区大小，否则数据是会出现问题的。另外，要调整大小的分区必须已经建立了文件系统（格式化），否则会报错。</font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(parted) resize</span><br><span class="line">分区编号？ 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定要修改的分区编号</span></span><br><span class="line">起始点？ [1049kB]? 1MB</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区起始位置</span></span><br><span class="line">结束点？ [5000MB]? 6GB</span><br><span class="line">分区结束位置</span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21,5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Number Start End Size File system Name标志</span><br><span class="line">1 1049kB 6000MB 5999MB ext2 diski</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分区大小改变</span></span><br></pre></td></tr></table></figure><p><strong>删除分区</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">命令如下：</span><br><span class="line">(parted) rm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除分区命令</span></span><br><span class="line">分区编号？ 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">指定分区编号</span></span><br><span class="line">(parted) print</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看一下</span></span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk/dev/sdb: 21.5GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Number Start End Size File system Name 标志 #分区消失</span><br></pre></td></tr></table></figure><h3 id="mkfs-格式化分区">mkfs 格式化分区</h3><p>（为分区写入文件系统）</p><p>在磁盘分区上创建ext2、ext3、ext4、ms-dos、vfat文件系统，默认情况下会创建ext2。mkfs用于在设备上构建Linux文件系统，通常是硬盘分区。文件要么是设备名称(例如/dev/hda1，/dev/sdb2)，要么是包含文件系统的常规文件。成功返回0，失败返回1。</p><p>实际上，mkfs只是Linux下可用的各种文件系统构建器(mkfs.fstype)的前端，在可能/sbin、/sbin/fs、/sbin/fs.d、/etc/fs、/etc/fs等多个目录中搜索特定于文件系统的生成器(编译时定义了精确的列表，但至少包含/sbin和/sbin/fs)，最后在PATH环境变量中列出的目录中搜索。</p><p>📌<strong>mkfs命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs [-options] 分区设备文件名</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><tbody><tr><td>device</td><td>预备检查的硬盘分区，例如：/dev/sda1</td></tr><tr><td>-t</td><td>给定档案系统的型式，Linux 的预设值为 ext2</td></tr><tr><td>-c</td><td>在制做档案系统前，检查该partition 是否有坏轨</td></tr><tr><td>-l bad_blocks_file</td><td>将有坏轨的block资料加到 bad_blocks_file 里面</td></tr><tr><td>block&nbsp;</td><td>给定 block 的大小</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>在 /dev/hda5 上建一个 msdos 的档案系统，同时检查是否有坏轨存在，并且将过程详细列出来:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]<span class="comment"># mkfs -V -t msdos -c /dev/hda5 </span></span><br></pre></td></tr></table></figure></li><li><p>将sda6分区格式化为ext3格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]# mfks -t ext3 /dev/sda6   </span><br></pre></td></tr></table></figure></li></ol><h3 id="mke2fs-格式化分区">mke2fs 格式化分区</h3><p>mkfs 命令为硬盘分区写入文件系统时，无法手动调整分区的默认参数（比如块大小是 4096 Bytes），如果想要调整，就需要使用本节介绍的 mke2fs 命令。</p><p><strong>mke2fs命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mke2fs [-options] 分区设备文件名</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td><code>-t 文件系统</code></td><td>指定格式化成哪个文件系统， 如 ext2、ext3、ext4；</td></tr><tr><td><code>-b 字节</code></td><td>指定 block 的大小；</td></tr><tr><td><code>-i 字节</code></td><td>指定&quot;字节 inode &quot;的比例，也就是多少字节分配一个 inode；</td></tr><tr><td><code>-j</code></td><td>建立带有 ext3 日志功能的文件系统；</td></tr><tr><td><code>-L 卷标名</code></td><td>给文件系统设置卷标名，就不使用 e2label 命令设定了；</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>格式化 <code>/dev/sdb6</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs -t ext4 -b 2048 /dev/sdb6</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">格式化分区，并指定block的大小为2048 Bytes</span></span><br><span class="line">mke2fe 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type：Linux</span><br><span class="line">Block size=2048 (log=1)  &lt;--block 的大小配置为 2K</span><br><span class="line">Fragment size=2048 (log=1)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks 131560</span><br><span class="line">inodes,1052240 blocks 52612 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=538968064 65 block groups</span><br><span class="line">16384 blocks per group, 16384 fragments per group</span><br><span class="line">2024 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">16384, 49152, 81920, 114688, 147456, 409600, 442368, 802816</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (32768 blocks):done</span><br><span class="line">Writing superblocks and filesystem accounting information:done</span><br><span class="line">This filesystem will be automatically checked every 38 mounts or 180 days, whichever comes first. Use tune2fs -c or-i to override.</span><br></pre></td></tr></table></figure><p>如果没有特殊需要，建议使用 mkfs 命令对硬盘分区进行格式化。</p><h3 id="fsck-磁盘检验">fsck 磁盘检验</h3><p>fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><p>📌<strong>fsck命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-options] 装置名称</span><br></pre></td></tr></table></figure><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>参数</th></tr></thead><tbody><tr><td>-t</td><td>给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数</td></tr><tr><td>-s</td><td>依序一个一个地执行 fsck 的指令来检查</td></tr><tr><td>-A</td><td>对/etc/fstab 中所有列出来的 分区（partition）做检查</td></tr><tr><td>-C</td><td>显示完整的检查进度</td></tr><tr><td>-d</td><td>打印出 e2fsck 的 debug 结果</td></tr><tr><td>-p</td><td>同时有 -A 条件时，同时有多个 fsck 的检查一起执行</td></tr><tr><td>-R</td><td>同时有 -A 条件时，省略 / 不检查</td></tr><tr><td>-a</td><td>如果检查有错则自动修复</td></tr><tr><td>-r</td><td>如果检查有错则由使用者回答是否修复</td></tr><tr><td>-y</td><td>选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>查看系统有多少文件系统支持的 fsck 命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># fsck[tab][tab]</span></span><br><span class="line">fsck         fsck.cramfs  fsck.ext2    fsck.ext3    fsck.msdos   fsck.vfat</span><br></pre></td></tr></table></figure></li><li><p>强制检测 /dev/hdc6 分区:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># fsck -C -f -t ext3 /dev/hdc6 </span></span><br><span class="line">fsck 1.39 (29-May-2006)</span><br><span class="line">e2fsck 1.39 (29-May-2006)</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">vbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks</span><br></pre></td></tr></table></figure><p>如果没有加上 -f 的选项，则由于这个文件系统不曾出现问题，检查的经过非常快速！若加上 -f 强制检查，才会一项一项的显示过程。</p></li><li><p>修复坏的分区文件系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@coonote ~]<span class="comment"># fsck -t ext3 -r /usr/local</span></span><br><span class="line"> fsck from util-linux 2.23.2</span><br><span class="line"> e2fsck 1.42.9 (28-Dec-2013)</span><br><span class="line"> fsck.ext3: Is a directory <span class="keyword">while</span> trying to open /usr/local</span><br><span class="line"> The superblock could not be <span class="built_in">read</span> or does not describe a correct ext2</span><br><span class="line"> filesystem.  If the device is valid and it really contains an ext2</span><br><span class="line"> filesystem (and not swap or ufs or something <span class="keyword">else</span>), <span class="keyword">then</span> the superblock</span><br><span class="line"> is corrupt, and you might try running e2fsck with an alternate superblock:</span><br><span class="line">     e2fsck -b 8193 </span><br><span class="line"> /usr/local: status 8, rss 1232, real 0.020288, user 0.002022, sys 0.005354</span><br></pre></td></tr></table></figure></li></ol><h3 id="添加磁盘及分区挂载">添加磁盘及分区挂载</h3><p>📌<strong>操作汇总</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev | grep <span class="string">&quot;^sb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#...(暂未整理)</span></span><br></pre></td></tr></table></figure><p>📌<strong>示例说明</strong>：</p><p>1️⃣<strong>使用虚拟机添加硬盘</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/39a1089d38a0400fb7f62a07b10c76bf.gif" alt="vmware添加硬盘"></p><p>2️⃣<strong>查看初始磁盘情况</strong><br>方法1：查看<code>/dev</code>下sd开头的文件<code>ls /dev</code>，没有sdb磁盘。方法2：<code>fdisk -l</code>命令 查看系统中的磁盘信息，此时是没有sdb磁盘。</p><p>3️⃣<strong>使用fdisk分区</strong></p><p>⚠如果提示 <strong>“Permission denied”</strong> 则是没有权限，在终端中输入 <strong><code>su</code></strong> 并填写密码进入到<strong>超级管理员模式</strong>即可。</p><p>使用命令查看分区：<code>fdisk -l</code></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/da9bf932811b424186a061792973b3b6.png" alt="fdisk分区1"></p><p>上图红色部分就是我们在 <strong>第二步</strong> 新建的磁盘 分区的路径名字为 <code>/dev/sdb</code></p><p>将这个空白分区分为两个20G的分区,输入分区的路径，也就是 <strong><code>fdisk /dev/sdb</code></strong> 进入到该分区下。</p><p>切换到该分区后我们输入 <code>p</code> 查看当前的分区的详细信息：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/a96b72eede464349a7ec4172635a44ef.png" alt="fdisk分区2"></p><p>可以看到，有40多G的空白分区接下来我们对磁盘进行操作，分出两个 <strong>20G</strong> 的分区</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/8eaff871f94e480e87bcf213e924efe6.gif" alt="fdisk分区3"></p><p>操作完成后，输入<code>w</code> <strong>保存并退出</strong>。这样我们就已经新建了一个<strong>20G</strong>的<strong>分区</strong>，重复上述操作两次即可新建出两个<strong>20G</strong>的<strong>分区</strong>。</p><p>在我们新建第二块分区时，可能会出现下面的问题。值超出范围<code>Value out of range.</code>。分区<strong>的大小要小于你定义的</strong>虚拟磁盘**大小。适当减少 **1G 就可以了。</p><p>此时输入 <code>fdisk -l</code> 查看新建的分区</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/91814c7ce1f54145af28d9aba2cb94e2.png" alt="fdisk分区4"></p><p><strong><code>/dev/sdb1</code></strong> 和 <strong><code>/dev/sdb2</code></strong> 就是我们新建的两个分区了</p><p>4️⃣<strong>格式化分区并挂载硬盘</strong></p><p>输入 <code>df -TH</code> 可以查看当前 <strong>分区格式</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/ab1e598cc8f747fcaf8c07729cb3c348.png" alt="格式化分区并挂载硬盘"></p><p>格式化改成 <strong>ext4</strong> 格式,输入 <code>mkfs.ext4 /dev/sdb1</code> 与 <code>mkfs.ext4 /dev/sdb2</code> 把这两个分区格式化一遍。</p><p>挂载分区，输入 <code>mkdir /sdb1</code> 与 <code>mkdir /sdb2</code>，再输入 <code>mount /dev/sdb1 /sdb1</code> 与 <code>mount /dev/sdb2 /sdb2</code> 将分区挂载到这两个目录。</p><h3 id="挂载光盘和永久挂载光盘">挂载光盘和永久挂载光盘</h3><p>📌<strong>挂载光盘</strong></p><p>1️⃣确认一下机器里面/dev文件夹下的CDROM文件是哪个：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ls -l /dev/ | grep -Fi cdrom</span></span><br><span class="line">lrwxrwxrwx. 1 root root           3 2月  18 22:46 cdrom -&gt; sr0</span><br><span class="line">crw-rw----. 1 root cdrom    21,   1 2月  18 22:46 sg1</span><br><span class="line">brw-rw----. 1 root cdrom    11,   0 2月  18 22:46 sr0</span><br></pre></td></tr></table></figure><p>我为了看起来直观用/dev/cdrom，其实用/dev/sr0也是一样的。</p><blockquote><p>sr0和sg0是什么?</p><p>Linux系统能够将大多数光学存储设备识别为SCSI设备，如<code>/dev/sr0</code>、<code>/dev/sr1</code>等。但是如果光驱使用的是老接口的话，可能会被识别为PATA设备。<code>/dev/sr*</code>设备是只读的，它们只用于从光盘上读取数据。可读写光盘驱动用<code>/dev/sg0</code>这样的设备文件表示，g代表“generic”。</p></blockquote><p>2️⃣挂载</p><p>准备一个文件夹。比如我看<code>/mnt</code>里面空的，就新建一个<code>/mnt/centos_cd</code>文件，然后挂载上去（复制下面的mount命令，用的时候改一下参数）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ls -a /mnt/</span></span><br><span class="line">.  ..  hgfs</span><br><span class="line">[root@docker01 ~]<span class="comment"># mkdir /mnt/centos_cd</span></span><br><span class="line">[root@docker01 ~]<span class="comment"># mount --read-only --verbose --source /dev/cdrom --target /mnt/centos_cd</span></span><br><span class="line">mount：/dev/sr0 已挂臷到 /mnt/centos_cd。</span><br></pre></td></tr></table></figure><blockquote><p>mount: 在 /dev/sr0 上找不到媒体找不到媒体，添加如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/da3e613cc2eb4ef28b730f5953f3bcb0.png" alt="找不到媒体"></p></blockquote><p>检查centos_cd文件夹下面，已经能看到光盘里面的文件了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># ls /mnt/centos_cd/</span></span><br><span class="line">CentOS_BuildTag  EFI  EULA  GPL  images  isolinux  LiveOS  Packages  repodata  RPM-GPG-KEY-CentOS-7  RPM-GPG-KEY-CentOS-Testing-7  TRANS.TBL</span><br></pre></td></tr></table></figure><p>采用这种方法挂载的光盘在重启电脑之后就不再挂载，需要再重新手动挂载一次到/mnt/centos_cd（文件夹centos_cd还存在，但是重启之后不会自动mount挂载的，文件夹内是空的）。</p><p>📌<strong>永久挂载光盘</strong></p><p>反正办法挺多的，自己写个脚本开机后mount命令执行一下也不是不行。下面我用/etc/fstab文件配置的方式让系统在开机加载文件系统的时候去挂载光盘。</p><p>修改前，默认的fstab文件是这样的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># cat /etc/fstab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Tue Feb 14 06:06:34 2023</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">UUID=8ab7355e-d84a-4617-ae25-1f091f31d69e /                       xfs     defaults        0 0</span><br><span class="line">UUID=0cf20099-e008-460e-868b-c351fe0c1351 /boot                   xfs     defaults        0 0</span><br><span class="line">UUID=7f08dacc-4765-4fbd-afcb-92cf37fce9c6 swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure><p>创建挂载的文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mnt/centos_cd</span><br></pre></td></tr></table></figure><p>备份一下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># cp /etc/fstab /etc/fstab_backup</span></span><br></pre></td></tr></table></figure><p>查下uuid</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@docker01 ~]<span class="comment"># blkid</span></span><br><span class="line">/dev/sda1: UUID=<span class="string">&quot;0cf20099-e008-460e-868b-c351fe0c1351&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> </span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;7f08dacc-4765-4fbd-afcb-92cf37fce9c6&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span> </span><br><span class="line">/dev/sda3: UUID=<span class="string">&quot;8ab7355e-d84a-4617-ae25-1f091f31d69e&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> </span><br><span class="line">/dev/sr0: UUID=<span class="string">&quot;2020-11-04-11-36-43-00&quot;</span> LABEL=<span class="string">&quot;CentOS 7 x86_64&quot;</span> TYPE=<span class="string">&quot;iso9660&quot;</span> PTTYPE=<span class="string">&quot;dos&quot;</span> </span><br></pre></td></tr></table></figure><p>于是在/etc/fstab中新增</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=2020-11-04-11-36-43-00  /mnt/centos_cd  iso9660  ro  0  0</span><br></pre></td></tr></table></figure><p>重启可以查看到</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># journalctl --no-pager --boot | grep -Fi mnt</span></span><br><span class="line">12月 15 13:45:09 localhost.localdomain systemd[1]: Mounting /mnt/centos_cd...</span><br><span class="line">12月 15 13:45:09 localhost.localdomain systemd[1]: Mounted /mnt/centos_cd.</span><br></pre></td></tr></table></figure><h3 id="虚拟内存和物理内存">虚拟内存和物理内存</h3><p>我们都知道，直接从内存读写数据要比从硬盘读写数据快得多，因此更希望所有数据的读取和写入都在内存中完成，然而内存是有限的，这样就引出了物理内存与虚拟内存的概念。</p><p>物理内存就是系统硬件提供的内存大小，是真正的内存。相对于物理内存，在 Linux 下还有一个虚拟内存的概念，虚拟内存是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间（又称 swap 空间）。</p><p>作为物理内存的扩展，Linux 会在物理内存不足时，使用交换分区的虚拟内存，更详细地说，就是内核会将暂时不用的内存块信息写到交换空间，这样一来，物理内存得到了释放，这块内存就可以用于其他目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。</p><p>Linux 的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p><p>要深入了解 Linux 内存运行机制，需要知道下面提到的几个方面：</p><ul><li>首先，Linux 系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux 也会交换出暂时不用的内存页面，因为这样可以大大节省等待交换所需的时间。</li><li>其次，Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，Linux 内核根据“最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到虚拟内存。</li></ul><p>有时我们会看到这么一个现象，Linux 物理内存还有很多，但是交换空间也使用了很多，其实这并不奇怪。例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动交换进物理内存（除非有这个必要），那么此时系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。</p><p>最后，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此一来，虚拟内存中可能没有足够的空间来存储这些交换页面，最终会导致 Linux 出现假死机、服务异常等问题。Linux 虽然可以在一段时间内自行恢复，但是恢复后的系统己经基本不可用了。</p><blockquote><p>因此，合理规划和设计 Linux 内存的使用是非常重要的，关于物理内存和交换空间的大小设置问题，取决于实际所用的硬盘大小，但大致遵循这样一个基本原则：</p><ol><li>如果内存较小（根据经验，物理内存小于 4GB），一般设置 swap 分区大小为内存的 2 倍；</li><li>如果物理内存大于 4GB，而小于 16GB，可以设置 swap 分区大小等于物理内存；</li><li>如果内存大小在 16GB 以上，可以设置 swap 为 0，但并不建议这么做，因为设置一定大小的 swap 分区是有一定作用的。</li></ol></blockquote><h3 id="swap分区">swap分区</h3><p>我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。</p><p>也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。</p><p>使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比 RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。相比较而言，Windows 不会为 swap 单独划分一个分区，而是使用分页文件实现相同的功能，在概念上，Windows 称其为虚拟内存，从某种意义上将，这个叫法更容易理解。因此，初学者将 swap 交换分区理解为虚拟内存是没有任何问题的。有时服务器的访问量确实很大，有可能出现 swap 分区不够用的情况，所以我们需要学习 swap 分区的构建方法。</p><p>📌<strong>du命令格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化swap文件系统</span></span><br><span class="line">mkswap [options] device [size]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动交换分区、观察交换分区信息-s等</span></span><br><span class="line">swapon [options] [specialfile...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#内存交换分区关闭使用</span></span><br><span class="line">swapon [options] [specialfile...]</span><br></pre></td></tr></table></figure><p>📌<strong>推荐分区大小</strong>：</p><table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody><tr><td style="background-color:#00c;text-align:center"><span style="color:#f3f3f4">内存大小</span></td><td style="background-color:#00c;text-align:center"><span style="color:#f3f3f4">swap大小</span></td></tr><tr><td style="text-align:center">&lt;4G</td><td style="text-align:center">2G</td></tr><tr><td style="text-align:center">4G~16G</td><td style="text-align:center">4G</td></tr><tr><td style="text-align:center">16G~64G</td><td style="text-align:center">8G</td></tr><tr><td style="text-align:center">64G~256G</td><td style="text-align:center">16G</td></tr><tr><td style="text-align:center">256G~512G</td><td style="text-align:center">32G</td></tr></tbody></table><p>oracle推荐的：</p><table border="1" cellpadding="1" cellspacing="1" style="width:500px"><tbody><tr><td style="background-color:#00c;text-align:center"><span style="color:#f3f3f4">物理内存大小</span></td><td style="background-color:#00c;text-align:center"><span style="color:#f3f3f4">swap大小</span></td></tr><tr><td style="text-align:center">1G~2G</td><td style="text-align:center">物理内存1.5倍</td></tr><tr><td style="text-align:center">2G~16G</td><td style="text-align:center">等于物理内存</td></tr><tr><td style="text-align:center">&gt;16G</td><td style="text-align:center">16G</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>1️⃣<strong>通过物理分区构建swap分区</strong>（推荐）</p><p>创建swap前提条件,需要有一块没有使用完的硬盘（就是一块物理硬盘需要有剩余空间未分配）。</p><p>首先<strong>查看磁盘</strong>的方式有很多，我这里用<code>lsblk</code>：(sdb物理硬盘，一共有10G，才用了不到7G，还有3G可以用)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda            8:0    0   10G  0 disk </span><br><span class="line">└─sda1         8:1    0   10G  0 part /</span><br><span class="line">sdb            8:16   0   10G  0 disk </span><br><span class="line">├─sdb1         8:17   0    5G  0 part </span><br><span class="line">│ └─vg0-lvm1 253:0    0  772M  0 lvm  </span><br><span class="line">└─sdb2         8:18   0  512M  0 part </span><br><span class="line">sr0           11:0    1 1024M  0 rom </span><br></pre></td></tr></table></figure><p><strong>查看现在的swap空间</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># free -lm</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           979        892         87         14          0        144</span><br><span class="line">Low:           979        892         87</span><br><span class="line">High:            0          0          0</span><br><span class="line">-/+ buffers/cache:        747        232</span><br><span class="line">Swap:            0          0          0 <span class="comment"># 可以看到现在是没有swap空间的</span></span><br></pre></td></tr></table></figure><p><strong>使用fdisk创建</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># fdisk /dev/sdb 【硬盘根据实际情况选择】</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p【打印】</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x229e658e</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n【创建分区】</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p【主分区】</span><br><span class="line">Partition number (2-4, default 2):  【直接回车即可】</span><br><span class="line">First sector (10487808-20971519, default 10487808): 【选择开始块，直接回车即可】</span><br><span class="line">Using default value 10487808</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10487808-20971519, default 20971519): +512M 【自定义大小】</span><br><span class="line">Partition 2 of <span class="built_in">type</span> Linux and of size 512 MiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t 【转换格式】</span><br><span class="line">Partition number (1,2, default 2): 2【选择硬盘<span class="built_in">id</span>】</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): L【查看所有序号】</span><br><span class="line"> 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        </span><br><span class="line"> 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-</span><br><span class="line"> 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-</span><br><span class="line"> 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-</span><br><span class="line"> 4  FAT16 &lt;32M      40  Venix 80286     85  Linux extended  c7  Syrinx         </span><br><span class="line"> 5  Extended        41  PPC PReP Boot   86  NTFS volume <span class="built_in">set</span> da  Non-FS data    </span><br><span class="line"> 6  FAT16           42  SFS             87  NTFS volume <span class="built_in">set</span> db  CP/M / CTOS / .</span><br><span class="line"> 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   </span><br><span class="line"> 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       <span class="built_in">df</span>  BootIt         </span><br><span class="line"> 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     </span><br><span class="line"> a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        </span><br><span class="line"> b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      </span><br><span class="line"> c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs        </span><br><span class="line"> e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            </span><br><span class="line"> f  W95 Ext<span class="string">&#x27;d (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/</span></span><br><span class="line"><span class="string">10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b</span></span><br><span class="line"><span class="string">11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      </span></span><br><span class="line"><span class="string">12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      </span></span><br><span class="line"><span class="string">14  Hidden FAT16 &lt;3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary  </span></span><br><span class="line"><span class="string">16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    </span></span><br><span class="line"><span class="string">17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE </span></span><br><span class="line"><span class="string">18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto</span></span><br><span class="line"><span class="string">1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep        </span></span><br><span class="line"><span class="string">1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT            </span></span><br><span class="line"><span class="string">1e  Hidden W95 FAT1 80  Old Minix      </span></span><br><span class="line"><span class="string">Hex code (type L to list all codes): 82 【直接输入序号回车（如82就是swap分区）</span></span><br><span class="line"><span class="string">Changed type of partition &#x27;</span>Linux<span class="string">&#x27; to &#x27;</span>Linux swap / Solaris<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): p【打印，看刚才修改的id磁盘是否变为linux swap】</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Disk /dev/sdb: 10.7 GB, 10737418240 bytes, 20971520 sectors</span></span><br><span class="line"><span class="string">Units = sectors of 1 * 512 = 512 bytes</span></span><br><span class="line"><span class="string">Sector size (logical/physical): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">I/O size (minimum/optimal): 512 bytes / 512 bytes</span></span><br><span class="line"><span class="string">Disk label type: dos</span></span><br><span class="line"><span class="string">Disk identifier: 0x229e658e</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Device Boot      Start         End      Blocks   Id  System</span></span><br><span class="line"><span class="string">/dev/sdb1            2048    10487807     5242880   8e  Linux LVM</span></span><br><span class="line"><span class="string">/dev/sdb2        10487808    11536383      524288   82  Linux swap / Solaris</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command (m for help): w 【保存】</span></span><br><span class="line"><span class="string">The partition table has been altered!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Calling ioctl() to re-read partition table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span></span><br><span class="line"><span class="string">The kernel still uses the old table. The new table will be used at</span></span><br><span class="line"><span class="string">the next reboot or after you run partprobe(8) or kpartx(8)</span></span><br><span class="line"><span class="string">Syncing disks.</span></span><br><span class="line"><span class="string">Command (m for help): w 【保存】</span></span><br><span class="line"><span class="string">The partition table has been altered!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Calling ioctl() to re-read partition table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span></span><br><span class="line"><span class="string">The kernel still uses the old table. The new table will be used at</span></span><br><span class="line"><span class="string">the next reboot or after you run partprobe(8) or kpartx(8)</span></span><br><span class="line"><span class="string">Syncing disks.</span></span><br><span class="line"><span class="string">[root@server0 ~]# </span></span><br><span class="line"><span class="string">[root@server0 ~]# partprobe /dev/sdb  #更新硬盘信息</span></span><br></pre></td></tr></table></figure><p><strong>格式化</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># lsblk   #fdisk –l 也可以看到分区信息</span></span><br><span class="line">NAME         MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda            8:0    0   10G  0 disk </span><br><span class="line">└─sda1         8:1    0   10G  0 part /</span><br><span class="line">sdb            8:16   0   10G  0 disk </span><br><span class="line">├─sdb1         8:17   0    5G  0 part </span><br><span class="line">│ └─vg0-lvm1 253:0    0  772M  0 lvm  </span><br><span class="line">└─sdb2         8:18   0  512M  0 part </span><br><span class="line">sr0           11:0    1 1024M  0 rom  </span><br><span class="line">[root@server0 ~]<span class="comment"># mkswap /dev/sdb2  #格式化为swap，注意分区别搞错了</span></span><br><span class="line">Setting up swapspace version 1, size = 524284 KiB</span><br><span class="line">no label, UUID=38f22d84-e4fb-4d6a-b157-48912f761bfe  <span class="comment">#无标签，uuid=…</span></span><br></pre></td></tr></table></figure><p><strong>永久挂载</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@station ~]<span class="comment"># blkid【查看swap对应的分区uuid并复制】 </span></span><br><span class="line">[root@server0 ~]<span class="comment"># vim /etc/fstab  # 最后一行添加下面内容</span></span><br><span class="line">[root@server0 ~]<span class="comment"># tail -n 1 /etc/fstab # 查询最后一行的内容</span></span><br><span class="line">UUID=74bb6046-bf04-49c6-a4a2-d4fb3aebc6b7    swap   swap   defaults 0 0  </span><br><span class="line">[root@server0 ~]<span class="comment">#</span></span><br><span class="line">[root@server0 ~]<span class="comment"># swapon -a #立即挂载</span></span><br></pre></td></tr></table></figure><p>swap属于特殊文件，<code>mount -a</code> 是不会自动挂载的，需要输入<code>swapon -a</code> 才会自动挂载。</p><p><strong>激活swap分区</strong><font style="color:red">（如果上面永久挂载中执行了<code>swapon -a</code>后，忽略该步骤！）</font></p><p>激活swap命令：<code>swapon /dev/sd*</code>,如果不激活的话，即使挂载了 swap 依然不会生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># free -l</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       1003456     927988      75468      15172        372     160828</span><br><span class="line">Low:       1003456     927988      75468</span><br><span class="line">High:            0          0          0</span><br><span class="line">-/+ buffers/cache:     766788     236668</span><br><span class="line">Swap:            0          0          0</span><br><span class="line"></span><br><span class="line">[root@server0 ~]<span class="comment">#</span></span><br><span class="line">[root@server0 ~]<span class="comment"># swapon /dev/sdb2 #激活swap</span></span><br><span class="line">[root@server0 ~]<span class="comment"># free –l #激活后swap 就有值了，这样 swap分区也全部完成</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       1003456     928344      75112      15172        376     160888</span><br><span class="line">Low:       1003456     928344      75112</span><br><span class="line">High:            0          0          0</span><br><span class="line">-/+ buffers/cache:     767080     236376</span><br><span class="line">Swap:       524284          0     524284</span><br></pre></td></tr></table></figure><p>2️⃣<strong>通过文件来构建swap分区</strong></p><p>上面的方法适合磁盘留有剩余空间没有使用。但如果磁盘空间全部分区完毕，那么该如何创建swap分区呢？我们可以通过制作一个大的文件来构建swap分区。虽然磁盘的空间已经全部分完了，但只要其中任意一个分区还有剩余空间，该方法就可以使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建swap目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /var/swap</span><br><span class="line"><span class="comment">#创建swap文件,这里表示创建一个swapfile文件，文件大小count为1G</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/var/swap/swapfile bs=1024 count=1000000</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换为swap文件</span></span><br><span class="line">mkswap /var/swap/swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载激活swap文件</span></span><br><span class="line">swapon /var/swap/swapfile</span><br><span class="line"><span class="comment">#附：卸载命令	</span></span><br><span class="line"><span class="comment">#swapoff /var/swap/swapfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置开机自启动</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/var/swap/swapfile   swap  swap  defaults  0  0&quot;</span> &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure><p>🔰修改内核 (优化，如果没有需求则不改)</p><p>vm.swappiness参数如果为0，表示关闭swap，即使配置了swap也不会生效，所以我们这里要配置下vm.swappiness的值。</p><p>centos7默认vm.swappiness为30，也就是说，你的物理内存使用到100-30=70%时，就开始使用swap，因为内存的速度要比磁盘的速度快的多，一旦使用到swap，会加大磁盘IO，造成大量页的换进换出，影响系统性能，所以正常情况下，我们应该尽可能的使用物理内存，减少对swap虚拟内存的使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/vm/swappiness</span><br><span class="line">或</span><br><span class="line">sysctl -a | grep swappiness</span><br></pre></td></tr></table></figure><p>我这里调整值为10</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure><p>保存后，执行以下命令，使其生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>此时就是说，当物理内存使用到100-10=90%时，开始使用swap。</p><hr><h1 id="软件安装">软件安装</h1><h2 id="软件包">软件包</h2><p>Linux下的软件包众多，且几乎都是经 GPL 授权、免费开源（无偿公开源代码）的。这意味着如果你具备修改软件源代码的能力，只要你愿意，可以随意修改。</p><blockquote><p>GPL，全称 General Public License，中文名称“通用性公开许可证”，简单理解 GPL 就是一个保护软件自由的一个协议，经 GPL 协议授权的软件必须开源。</p></blockquote><p>Linux下的软件包可细分为两种，分别是源码包和二进制包。</p><h3 id="Linux源码包">Linux源码包</h3><p>实际上，源码包就是一大堆源代码程序，是由程序员按照特定的格式和语法编写出来的。</p><p>我们都知道，计算机只能识别机器语言，也就是二进制语言，所以源码包的安装需要一名“翻译官”将“abcd”翻译成二进制语言，这名“翻译官”通常被称为编译器。</p><p>虽然源码包免费开源，但用户不会编程怎么办？一大堆源代码程序不会使用怎么办？源码包容易安装吗？等等这些都是使用源码包安装方式无法解答的问题。</p><p>另外，由于源码包的安装需要把源代码编译为二进制代码，因此安装时间较长。比如，大家应该都在 Windows下安装过 QQ，QQ 功能较多，程序相对较大（有 70 MB左右），但由于其并非是以源码包的形式发布，而是编译后才发布的，因此只需几分钟（经过简单的配置）即可安装成功。但如果我们以源码包安装的方式在 Linux 中安装一个 MySQL 数据库，即便此软件的压缩包仅有 23 MB左右，也需要 30 分钟左右的时间（根据硬件配置不同，略有差异）。</p><p>通过对比你会发现，源码包的编译是很费时间的，况且绝多大数用户并不熟悉程序语言，在安装过程中我们只能祈祷程序不要报错，否则初学者很难解决。</p><p>为了解决使用源码包安装方式的这些问题，Linux 软件包的安装出现了使用二进制包的安装方式。</p><h3 id="Linux二进制包">Linux二进制包</h3><p>二进制包，也就是源码包经过成功编译之后产生的包。由于二进制包在发布之前就已经完成了编译的工作，因此用户安装软件的速度较快（同 Windows下安装软件速度相当），且安装过程报错几率大大减小。</p><p>二进制包是 Linux 下默认的软件安装包，因此二进制包又被称为默认安装软件包。目前主要有以下 2 大主流的二进制包管理系统：</p><ul><li>RPM 包管理系统：功能强大，安装、升级、査询和卸载非常简单方便，因此很多 Linux 发行版都默认使用此机制作为软件安装的管理方式，例如 Fedora、CentOS、SuSE 等。</li><li>DPKG 包管理系统：由 Debian Linux 所开发的包管理机制，通过 DPKG 包，Debian Linux 就可以进行软件包管理，主要应用在 Debian 和 Ubuntu 中。</li></ul><h2 id="RPM包">RPM包</h2><h3 id="RPM包统一命名规则">RPM包统一命名规则</h3><p>RPM 二进制包的命名需遵守统一的命名规则，用户通过名称就可以直接获取这类包的版本、适用平台等信息。</p><p>RPM 二进制包命名的一般格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名-版本号-发布次数-发行商-Linux平台-适合的硬件平台-包扩展名</span><br></pre></td></tr></table></figure><p>例如，RPM 包的名称是<code>httpd-2.2.15-15.el6.centos.1.i686.rpm</code>，其中：</p><ul><li><p>httped：软件包名。这里需要注意，httped 是包名，而 httpd-2.2.15-15.el6.centos.1.i686.rpm 通常称为包全名，包名和包全名是不同的，在某些 Linux 命令中，有些命令（如包的安装和升级）使用的是包全名，而有些命令（包的查询和卸载）使用的是包名，一不小心就会弄错。</p></li><li><p>2.2.15：包的版本号，版本号的格式通常为<code>主版本号.次版本号.修正号</code>。</p></li><li><p>15：二进制包发布的次数，表示此 RPM 包是第几次编程生成的。</p></li><li><p>el*：软件发行商，el6 表示此包是由 Red Hat 公司发布，适合在 RHEL 6.x (Red Hat Enterprise Unux) 和 CentOS 6.x 上使用。</p></li><li><p>centos：表示此包适用于 CentOS 系统。</p></li><li><p>i686：表示此包使用的硬件平台，目前的 RPM 包支持的平台如表所示：</p><table><thead><tr><th>平台名称</th><th>适用平台信息</th></tr></thead><tbody><tr><td>i386</td><td>386 以上的计算机都可以安装</td></tr><tr><td>i586</td><td>686 以上的计算机都可以安装</td></tr><tr><td>i686</td><td>奔腾 II 以上的计算机都可以安装，目前所有的 CPU 是奔腾 II 以上的，所以这个软件版本居多</td></tr><tr><td>x86_64</td><td>64 位 CPU 可以安装</td></tr><tr><td>noarch</td><td>没有硬件限制</td></tr></tbody></table></li><li><p>rpm：RPM 包的扩展名，表明这是编译好的二进制包，可以使用 rpm 命令直接安装。此外，还有以 src.rpm 作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 rpm 格式的包，最后才能使用 rpm 命令进行安装。</p></li></ul><p>Linux 系统不靠扩展名分区文件类型，那为什么包全名中要包含 .rpm 扩展名呢？其实，这里的扩展名是为系统管理员准备的，如果我们不对 RPM 包标注扩展名，管理员很难知道这是一个 RPM 包，当然也就无法正确使用。</p><h3 id="RPM包安装、卸载和升级">RPM包安装、卸载和升级</h3><p>我们以安装 apache 程序为例。因为后续章节还会介绍使用源码包的方式安装 apache 程序，读者可以直观地感受到源码包和 RPM 包的区别。</p><p>📌<strong>RPM包默认安装路径</strong></p><p>通常情况下，RPM 包采用系统默认的安装路径，所有安装文件会按照类别分散安装到下表所示的目录中：</p><table><thead><tr><th>安装路径</th><th>含 义</th></tr></thead><tbody><tr><td>/etc/</td><td>配置文件安装目录</td></tr><tr><td>/usr/bin/</td><td>可执行的命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序所使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man/</td><td>帮助文件保存位置</td></tr></tbody></table><p>RPM 包的默认安装路径是可以通过命令查询的。</p><p>除此之外，RPM 包也支持手动指定安装路径，但此方式并不推荐。因为一旦手动指定安装路径，所有的安装文件会集中安装到指定位置，且系统中用来查询安装路径的命令也无法使用（需要进行手工配置才能被系统识别），得不偿失。</p><p>与 RPM 包不同，源码包的安装通常采用手动指定安装路径（习惯安装到 /usr/local/ 中）的方式。既然安装路径不同，同一 apache 程序的源码包和 RPM 包就可以安装到一台 Linux 服务器上（但同一时间只能开启一个，因为它们需要占用同一个 80 端口）。</p><p>实际情况中，一台服务器几乎不会同时包含两个 apache 程序，管理员不好管理，还会占用过多的服务器磁盘空间。</p><p>📌<strong>RPM命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm [-options] 包全名</span><br></pre></td></tr></table></figure><p>注意一定是包全名。涉及到包全名的命令，一定要注意路径，可能软件包在光盘中，因此需提前做好设备的挂载工作。</p><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>安装（install）</td></tr><tr><td>-v</td><td>显示更详细的信息（verbose）</td></tr><tr><td>-h</td><td>打印 #，显示安装进度（hash)</td></tr><tr><td>-e</td><td>卸载，也就是 erase 的首字母</td></tr><tr><td>-U</td><td>（大写）如果该软件没安装过则直接安装；若没安装则升级至最新版本</td></tr><tr><td>-F</td><td>（大写）如果该软件没有安装，则不会安装，必须安装有较低版本才能升级</td></tr><tr><td>–nodeps</td><td>不检测依赖性安装。软件安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。<br>如果不管依赖性，想强制安装，则可以使用这个选项。注意，这样不检测依赖性安装的软件基本上是不能使用的，所以不建议这样做</td></tr><tr><td>–replacefiles</td><td>替换文件安装。如果要安装软件包，但是包中的部分文件已经存在，那么在正常安装时会报&quot;某个文件已经存在&quot;的错误，<br>从而导致软件无法安装。使用这个选项可以忽略这个报错而覆盖安装</td></tr><tr><td>–replacepkgs</td><td>替换软件包安装。如果软件包已经安装，那么此选项可以把软件包重复安装一遍</td></tr><tr><td>–force</td><td>强制安装。不管是否已经安装，都重新安装。也就是 -replacefiles 和 -replacepkgs 的综合</td></tr><tr><td>–test</td><td>测试安装。不会实际安装，只是检测一下依赖性</td></tr><tr><td>–prefix</td><td>指定安装路径。为安装软件指定安装路径，而不使用默认安装路径</td></tr></tbody></table><table><thead><tr><th>常用选项</th><th>说明</th></tr></thead><tbody><tr><td>-ivh</td><td>安装显示安装进度–install–verbose–hash;</td></tr><tr><td>-Uvh</td><td>升级软件包–Update；</td></tr><tr><td>-qpl</td><td>列出RPM软件包内的文件信息[Query Package list]；</td></tr><tr><td>-qpi</td><td>列出RPM软件包的描述信息[Query Package install package(s)]；</td></tr><tr><td>-qf</td><td>查找指定文件属于哪个RPM软件包[Query File]；</td></tr><tr><td>-Va</td><td>校验所有的RPM软件包，查找丢失的文件[View Lost]；</td></tr><tr><td>-e</td><td>删除包</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><ol><li><p>使用此命令安装 apache 软件包，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -ivh \</span></span><br><span class="line">/mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br><span class="line">Preparing...</span><br><span class="line"><span class="comment">####################</span></span><br><span class="line">[100%]</span><br><span class="line">1:httpd</span><br><span class="line"><span class="comment">####################</span></span><br><span class="line">[100%]</span><br></pre></td></tr></table></figure><p>注意，直到出现两个 100% 才是真正的安装成功，第一个 100% 仅表示完成了安装准备工作。</p><p>此命令还可以一次性安装多个软件包，仅需将包全名用空格分开即可，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -ivh a.rpm b.rpm c.rpm</span></span><br></pre></td></tr></table></figure></li><li><p>使用如下命令即可实现 RPM 包的升级：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -Uvh 包全名	# -U（大写）选项的含义是：如果该软件没安装过则直接安装；若没安装则升级至最新版本。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rpm -Fvh 包全名	# -F（大写）选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。</span></span><br></pre></td></tr></table></figure></li><li><p>RPM包的卸载</p><p>RPM 软件包的卸载要考虑包之间的依赖性。例如，我们先安装的 httpd 软件包，后安装 httpd 的功能模块 mod_ssl 包，那么在卸载时，就必须先卸载 mod_ssl，然后卸载 httpd，否则会报错。（<em>软件包卸载和拆除大楼是一样的，本来先盖的 2 楼，后盖的 3 楼，那么拆楼时一定要先拆除 3 楼。</em>）</p><p>如果卸载 RPM 软件不考虑依赖性，执行卸载命令会包依赖性错误，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -e httpd</span></span><br><span class="line">error: Failed dependencies:</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_wsgi-3.2-1.el6.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) php-5.3.3-3.el6_2.8.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_ssl-1:2.2.15-15.el6.</span><br><span class="line">centos.1.i686</span><br><span class="line">httpd-mmn = 20051115 is needed by (installed) mod_perl-2.0.4-10.el6.i686</span><br><span class="line">httpd = 2.2.15-15.el6.centos.1 is needed by (installed) httpd-manual-2.2.</span><br><span class="line">15-15.el6.centos.1 .noarch</span><br><span class="line">httpd is needed by (installed) webalizer-2.21_02-3.3.el6.i686</span><br><span class="line">httpd is needed by (installed) mod_ssl-1:2.2.15-15.el6.centos.1.i686</span><br><span class="line">httpd=0:2.2.15-15.el6.centos.1 is needed by(installed)mod_ssl-1:2.2.15-15.el6.centos.1.i686</span><br></pre></td></tr></table></figure></li></ol><h2 id="yum-包管理工具">yum 包管理工具</h2><p>yum，全称“Yellow dog Updater, Modified”，是一个专门为了解决包的依赖关系而存在的软件包管理器。</p><p>可以这么说，yum 是改进型的 RPM 软件管理器，它很好的解决了 RPM 所面临的软件包依赖问题。yum 在服务器端存有所有的 RPM 包，并将各个包之间的依赖关系记录在文件中，当管理员使用 yum 安装 RPM 包时，yum 会先从服务器端下载包的依赖性文件，通过分析此文件从服务器端一次性下载所有相关的 RPM 包并进行安装。</p><p>📌<strong>查看 yum 是否已安装</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rpm -qa | grep yum</span></span><br><span class="line">yum-metadata-parser-1.1.2-16.el6.i686</span><br><span class="line">yum-3.2.29-30.el6.centos.noarch</span><br><span class="line">yum-utils-1.1.30-14.el6.noarch</span><br><span class="line">yum-plugin-fastestmirror-1.1.30-14.el6.noarch</span><br><span class="line">yum-plugin-security-1.1.30-14.el6.noarch</span><br></pre></td></tr></table></figure><p>可以看到，系统上已经安装了 yum 。如果未安装 yum 可查看《<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/e3c78d6483a02a3c4d85f578.html">Linux怎么安装yum</a>》。</p><p>📌<strong>网络 yum 源</strong>:</p><p>一般情况下，只要你的主机网络正常，可以直接使用网络 yum 源，不需要对配置文件做任何修改，这里对 yum 源配置文件做一下简单介绍。网络 yum 源配置文件位于 <code>/etc/yum.repos.d/</code> 目录下，文件扩展名为&quot;<em>.repo&quot;（只要扩展名为 &quot;</em>.repo&quot; 的文件都是 yum 源的配置文件）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls /etc/yum.repos.d/</span></span><br><span class="line">CentOS-Base.repo</span><br><span class="line">CentOS-Media.repo</span><br><span class="line">CentOS-Debuginfo.repo.bak</span><br><span class="line">CentOS-Vault.repo</span><br></pre></td></tr></table></figure><p>可以看到，该目录下有 4 个 yum 配置文件，通常情况下是 CentOS-Base.repo 文件生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]<span class="comment"># vim /etc/yum.repos.d/CentOS-Base.repo</span></span><br><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base</span><br><span class="line">mirrorlist=http://mirrorlist.centos.org/? release= <span class="variable">$releasever</span>&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=os</span><br><span class="line">baseurl=http://mirror.centos.org/centos/<span class="variable">$releasever</span>/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure><blockquote><p>此文件中含有 5 个 yum 源容器，这里只列出了 base 容器，其他容器和 base 容器类似。base 容器中各参数的含义分别为：</p><ul><li>[base]：容器名称，一定要放在[]中。</li><li>name：容器说明，可以自己随便写。</li><li>mirrorlist：镜像站点，这个可以注释掉。</li><li>baseurl：我们的 yum 源服务器的地址。默认是 CentOS 官方的 yum 源服务器，是可以使用的。如果你觉得慢，则可以改成你喜欢的 yum 源地址。</li><li>enabled：此容器是否生效，如果不写或写成 enabled 则表示此容器生效，写成 enable=0 则表示此容器不生效。</li><li>gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。</li><li>gpgkey：数字证书的公钥文件保存位置。不用修改。</li></ul></blockquote><p>📌<strong>本地 yum 源</strong></p><p>在无法联网的情况下，yum 可以考虑用本地光盘（或安装映像文件）作为 yum 源。</p><p>Linux 系统安装映像文件中就含有常用的 RPM 包，我们可以使用压缩文件打开映像文件（iso文件），进入其 Packages 子目录，如图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Z32P9423J01.gif" alt="安装映像文件的 Packages 子目录"></p><p>可以看到，该子目录下含有几乎所有常用的 RPM 包，因此使用系统安装映像作为本地 yum 源没有任何问题。</p><p>在 <code>/etc/yum.repos.d/</code> 目录下有一个 CentOS-Media.repo 文件，此文件就是以本地光盘作为 yum 源的模板文件，只需进行简单的修改即可，步骤如下：</p><ol><li><p>放入 CentOS 安装光盘，并挂载光盘到指定位置。命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/cdrom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建cdrom目录，作为光盘的挂载点</span></span><br><span class="line">[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/</span><br><span class="line">mount: block device/dev/srO is write-protected, mounting read-only</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">挂载光盘到/mnt/cdrom目录下</span></span><br></pre></td></tr></table></figure></li><li><p>修改其他几个 yum 源配置文件的扩展名，让它们失效，因为只有扩展名是&quot;*.repo&quot;的文件才能作为 yum 源配置文件。当也可以删除其他几个 yum 源配置文件，但是如果删除了，当又想用网络作为 yum 源时，就没有了参考文件，所以最好还是修改扩展名。 命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /etc/yum.repos.d/</span><br><span class="line">[root@localhost yum.repos.d]# mv CentOS-Base, repo CentOS-Base.repo.bak</span><br><span class="line">[root@localhost yum.repos.d]#mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak</span><br><span class="line">[root@localhost yum.repos.d]# mv CentOS-Vault.repo CentOS-Vault.repo.bak</span><br></pre></td></tr></table></figure></li><li><p>修改光盘 yum 源配置文件 CentOS-Media.repo，参照以下方修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# vim CentOS-Media.repo</span><br><span class="line">[c6-media]</span><br><span class="line">name=CentOS-$releasever - Media</span><br><span class="line">baseurl=file:///mnt/cdrom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">地址为你自己的光盘挂载地址</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">file:///media/cdrom/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">file:///media/cdrecorder/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注释这两个的不存在地址</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把enabled=0改为enabled=1, 让这个yum源配置文件生效</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure><p>如此，本地 yum 源就配置完成了。</p></li></ol><h3 id="更换国内-yum-源">更换国内 yum 源</h3><p>📌<strong>更换yum源</strong>：</p><p>首先备份/etc/yum.repos.d/CentOS-Base.repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p>执行替换：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">[root@localhost ~]<span class="comment"># wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mv CentOS6-Base-163.repo CentOS-Base.repo</span></span><br></pre></td></tr></table></figure><p>运行以下命令生成缓存：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum clean all</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum makecache</span></span><br></pre></td></tr></table></figure><p>📌<strong>国内yum源</strong>：</p><ol><li>网易（163）yum 源: <a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/centos.html">http://mirrors.163.com/.help/centos.html</a><ul><li>CentOS5 ：<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a></li><li>CentOS6 ：<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li><li>CentOS7 ：<a target="_blank" rel="noopener" href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></li></ul></li><li>中科大的 yum 源，安装方法查看：<a target="_blank" rel="noopener" href="https://lug.ustc.edu.cn/wiki/mirrors/help/centos">https://lug.ustc.edu.cn/wiki/mirrors/help/centos</a></li><li>清华大学的 yum 源安装方法查看: <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/centos/">https://mirrors.tuna.tsinghua.edu.cn/help/centos/</a></li><li>aliyun 的 yum 源安装方法查看: <a target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/centos">https://developer.aliyun.com/mirror/centos</a></li></ol><h3 id="yum-命令">yum 命令</h3><p>📌<strong>yum命令的格式</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [-options] [<span class="built_in">command</span>] [package ...]</span><br></pre></td></tr></table></figure><p>📌<strong>常用命令</strong>：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>check-update</td><td>列出所有可更新的软件清单命令</td></tr><tr><td>update</td><td>更新所有软件命令</td></tr><tr><td>install &lt;package_name&gt;</td><td>仅安装指定的软件命令</td></tr><tr><td>update &lt;package_name&gt;</td><td>仅更新指定的软件命令</td></tr><tr><td>remove &lt;package_name&gt;</td><td>删除软件包命令</td></tr><tr><td>list [package_name]</td><td>查询所有已安装和可安装的软件包<br>[package_name] 查询执行软件包的安装情况</td></tr><tr><td>search<keyword></keyword></td><td>查找软件包命令</td></tr><tr><td>info &lt;package_name&gt;</td><td>查询执行软件包的详细信息</td></tr><tr><td>clean packages</td><td>清除缓存目录下的软件包</td></tr><tr><td>clean header</td><td>清除缓存目录下的 headers</td></tr><tr><td>clean oldheaders</td><td>清除缓存目录下旧的 headers</td></tr><tr><td>clean 或 clean all (= yum clean packages; yum clean oldheaders)</td><td>清除缓存目录下的软件包及旧的 headers</td></tr></tbody></table><p>📌<strong>选项</strong>：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-y</code></td><td>当安装过程提示选择全部为 “yes”</td></tr><tr><td><code>-q</code></td><td>不显示安装的过程</td></tr></tbody></table><p>📌<strong>示例说明</strong>：</p><p>查看支持的所有可安装版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">已安装的软件包</span><br><span class="line">可安装的软件包</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line">docker-ce.x86_64            3:23.0.1-1.el7                     docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:23.0.1-1.el7                     @docker-ce-stable</span><br><span class="line">docker-ce.x86_64            3:23.0.0-1.el7                     docker-ce-stable </span><br><span class="line">docker-ce.x86_64            3:20.10.9-3.el7                    docker-ce-stable </span><br><span class="line">...省略部分数据...</span><br><span class="line"><span class="comment"># @号为当前安装版本</span></span><br></pre></td></tr></table></figure><h2 id="dnf-包管理工具">dnf 包管理工具</h2><hr><h1 id="Seliunx">Seliunx</h1><p>Linux被认为是当今最安全的操作系统之一，这是因为它杰出的安全特性，如SELinux(安全增强的Linux)。</p><p>对于初学者，SELinux被描述为在内核中执行的强制访问控制(MAC)安全结构。SELinux提供了一种强制执行某些安全策略的方法，否则系统管理员将无法有效地实现这些策略。当您安装RHEL/CentOS或其他衍生工具时，SELinux服务是默认启用的，因此您系统上的一些应用程序可能不支持这种安全机制。因此，要使此类应用程序正常运行，必须禁用或关闭SELinux。</p><p><strong>SELinux一共有3种状态，分别是Enforcing，Permissive和Disabled状态</strong>。第一种是默认状态，表示强制启用，第二种是宽容的意思，即大部分规则都放行。第三种是禁用，即不设置任何规则。只能通过setenforce命令来设置前面两种状态，而如果想修改为disable状态，需要修改配置文件，同时重启系统。</p><p>📌<strong>查询</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sestatus</span><br><span class="line">getenforce</span><br></pre></td></tr></table></figure><p>📌<strong>临时禁用</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /selinux/enforce</span><br><span class="line">setenforce 0</span><br><span class="line">setenforce Permissive</span><br></pre></td></tr></table></figure><p>📌<strong>永久禁用</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line"></span><br><span class="line"><span class="comment">#将配置SELinux=enforcing改为SELinux=disabled</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>保存退出后使配置生效，需要重新启动系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getenforce</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><hr><h1 id="系统备份">系统备份</h1><h2 id="1-备份的重要性">1.备份的重要性</h2><p>虽然 Linux 系统难免会因内部环境、底层硬件、外来黑客等因素的影响出现问题，但作为一名系统管理人员，自身的职责并不是要保证系统永远不出问题（事实上也是不可能做到的），而是要在系统出现故障或者崩溃时，能以最快的速度，用最短时间恢复系统的运行，保证数据的安全，从而将故障带来的损失降到最低。</p><p>要实现这样的目标，就要求系统管理人员对系统和业务应用有一个合理的备份恢复策略，完美的备份策略可以保证业务的 0 宕机时间和数据的完全恢复。有人说，既然数据备份非常重要，那我把重要数据在硬盘中保存一份，在移动硬盘中也保存一份，再刻录一张光盘，这样数据应该非常安全了吧？</p><p>对个人用户来讲，这样保存数据已经足够了；但是对企业用户来讲，还是有安全隐患的，因为这些数据还是放在同一个地方的。还记得美国的“9·11”事件吗？像美国纽约世贸中心那样的庞然大物也轰然倒塌。当然，相比这样的灾难来讲，数据的损失已经是微不足道的了，不过这仍然说明异地备份的重要性。所以，我们在备份数据的时候，不仅要把数据保存在多个存储介质中，还要考虑把重要数据异地保存。</p><h2 id="2-备份策略">2.备份策略</h2><p>常用的备份策略有完全备份和增量备份，而增量备份有可细分为累计增量备份和差异增量备份。下面来分别讲述不同备份策略以及之间的区别。</p><ul><li><p><strong>完全备份</strong></p><p>完全备份是指把所有需要备份的数据全部备份。当然，完全备份可以备份整块硬盘、整个分区或某个具体的目录。对于 Linux 操作系统来说，完全备份指的就是将根目录下的所有文件进行备份。</p><p>完全备份的好处是，所有数据都进行了备份，系统中任何数据丢失都能恢复，且恢复效率较高。如果完全备份备份的是整块硬盘，那么甚至不需要数据恢复，只要把备份硬盘安装上，服务器就会恢复正常。</p><p>完全备份的缺点也很明显，那就是需要备份的数据量较大，备份时间较长，备份了很多无用数据，占用的空间较大，所以完全备份不可能每天执行。</p><p>我们一般会对关键服务器进行整盘完全备份，如果出现问题，则可以很快地使用备份硬盘进行替换，从而减少损失。我们甚至会对关键服务器搭设一台一模一样的服务器，这样只要远程几个命令（或使用 Shell 脚本自动检测，自动进行服务器替换），备份服务器就会接替原本的服务器，使故障响应时间大大缩短。</p></li><li><p><strong>累计增量备份</strong></p><p>在一个数据量很大的业务应用中，每天对 Linux 系统进行完全备份是不现实的，这就需要用到增量备份策略。</p><p>累计增量备份是指先进行一次完全备份，服务器运行一段时间之后，比较当前系统和完全备份的备份数据之间的差异，只备份有差异的数据。服务器继续运行，再经过一段时间，进行第二次增量备份。在进行第二次增量备份时，当前系统和第一次增量备份的数据进行比较，也是只备份有差异的数据。第三次增量备份是和第二次增量备份的数据进行比较，以此类推。</p><p>因此，累计增量备份就是只备份每天增加或者变化的数据，而不备份系统中没有变动的数据。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Q0291641164c.jpg" alt="累计增量备份"></p><p>假设我们在第一天进行一次完全备份。第二天增量备份时，只会备份第二天和第一天之间的差异数据，但是第二天的总备份数据是完全备份加第一次增量备份的数据。第三天增量备份时，只会备份第三天和第二天之间的差异数据，但是第三天的总备份数据是完全备份加第一次增量备份的数据，再加第二次增量备份的数据。当然，第四天增量备份时，只会备份第四天和第三天的差异数据，但是第四天的总备份数据是完全备份加第一次增量备份的数据，加第二次增量备份的数据，再加第三次增量备份的数据。</p><p>采用累计增量备份的好处是，每次备份需要备份的数据较少，耗时较短，占用的空间较小；坏处是数据恢复比较麻烦，如果图上的例子，那么当进行数据恢复时，就要先恢复完全备份的数据，再依次恢复第一次增量备份的数据、第二次增量备份的数据和第三次增量备份的数据，最终才能恢复所有的数据。</p></li><li><p><strong>差异增量备份</strong></p><p>差异增量备份（后续简称差异备份）也要先进行一次完全备份，但是和累计增量备份不同的是，每次差异备份都备份和原始的完全备份不同的数据。也就是说，差异备份每次备份的参照物都是原始的完全备份，而不是上一次的差异备份。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/aceniu/images/raw/master/article_images/typora_images/2-1Q02916415T37.jpg" alt="差异增量备份"></p><p>假设我们在第一天也进行一次完全备份。第二天差异备份时，会备份第二天和第一天之间的差异数据，而第二天的备份数据是完全备份加第一次差异备份的数据。第三天进行差异备份时，仍和第一天的原始数据进行对比，把第二天和第三天所有的数据都备份在第二次差异备份中，第三天的备份数据是完全备份加第二次差异备份的数据。第四天进行差异备份时，仍和第一天的原始数据进行对比，把第二天、第三天和第四天所有的不同数据都备份到第三次差异备份中，第四天的备份数据是完全备份加第三次差异备份的数据。</p><p>相比较而言，差异备份既不像完全备份一样把所有数据都进行备份，也不像增量备份在进行数据恢复时那么麻烦，只要先恢复完全备份的数据，再恢复差异备份的数据即可。不过，随着时间的增加，和完全备份相比，变动的数据越来越多，那么差异备份也可能会变得数据量庞大、备份速度缓慢、占用空间较大。</p></li></ul><h2 id="3-tar命令备份数据">3.tar命令备份数据</h2><p>下面通过 tar 命令做的一个 Web 服务器的备份脚本，详细了解 tar 命令作为备份工具时的具体用法。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">BAKDATE=`<span class="built_in">date</span> +%y%m%d`</span><br><span class="line">DATA3=`<span class="built_in">date</span> -d <span class="string">&quot;3 days ago&quot;</span> +%y%m%d`</span><br><span class="line">osdata=/disk1</span><br><span class="line">userdata=/disk2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;backup OS data starting&quot;</span></span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/etc.data/etc_<span class="variable">$BAKDATE</span>.tar.gz /etc</span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/boot.data/boot_<span class="variable">$BAKDATE</span>.tar.gz /boot</span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/home.data/home_<span class="variable">$BAKDATE</span>.tar.gz /home</span><br><span class="line">tar -zcvf /<span class="variable">$osdata</span>/root.data/root_<span class="variable">$BAKDATE</span>.tar.gz /root</span><br><span class="line">tar -zcvf /<span class="variable">$userdata</span>/usr_data/usrlocal_<span class="variable">$BAKDATE</span>.tar.gz /usr/local</span><br><span class="line">tar -zcvf /<span class="variable">$userdata</span>/var_www/www_<span class="variable">$BAKDATE</span>.tar.gz /var/www</span><br><span class="line"><span class="built_in">cp</span> -r /<span class="variable">$osdata</span>/* /<span class="variable">$userdata</span></span><br><span class="line"><span class="built_in">cp</span> -r /<span class="variable">$userdata</span>/* /<span class="variable">$osdata</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Backup OS data complete!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;delete OS data 3 days ago&quot;</span></span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/etc.data/etc_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/boot.data/boot_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/home.data/home_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/root.data/root_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/usr_data/usrlocal_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$osdata</span>/var_www/www_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/etc.data/etc_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/boot.data/boot_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/home.data/home_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/root.data/root_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/usr_data/usrlocal_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">rm</span> -rf /<span class="variable">$userdata</span>/var_www/www_<span class="variable">$DATA3</span>.tar.gz</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;delete cws ok!&quot;</span></span><br></pre></td></tr></table></figure><p>上面这段脚本完成的工作是，将系统和用户的备份数据分别保存在两个不同的本地磁盘 disk1 和 disk2 中，并且保留最近 3 天的数据，3 天前的数据自动删除。主要备份的数据有 /etc 目录、/boot 目录、/home 目录、/root 目录、/usr/local 目录和 /var/www 目录。当然这里只是举个例子，凡是存放数据的重要目录，都需要进行备份。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.halfsummer.xyz">aceniu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.halfsummer.xyz/posts/52702296.html">https://blog.halfsummer.xyz/posts/52702296.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.halfsummer.xyz" target="_blank">艾斯牛 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B/">编程</a><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://img01.anzhiy.cn/useruploads/0/2023/02/19/63f10532e1556.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/3c3cdb74.html" title="Git 学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/22/f5f38e2449505.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git 学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c1031b26.html" title="Zabbix 6.0 学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/fe6dad0521ce2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">Zabbix 6.0 学习笔记</div></div></a></div><div><a href="/posts/1763fb9d.html" title="WMware 虚拟机安装 Linux"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/029c30b1525aa.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-13</div><div class="title">WMware 虚拟机安装 Linux</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/47ef438e7fff6.jpeg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">aceniu</div><div class="author-info__description">Love 33 & Yilia</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aceniu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/aceniu" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-icon_github-circle"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=123354319@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-Rss"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/289493392" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=123354319&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-icon_qq-circle"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">操作系统的发展史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unix"><span class="toc-text">Unix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minix"><span class="toc-text">Minix</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-text">操作系统的发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minix%E6%B2%A1%E6%9C%89%E7%81%AB%E8%B5%B7%E6%9D%A5%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">Minix没有火起来的原因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E4%BB%8B%E7%BB%8D"><span class="toc-text">Linux介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8-%E5%8F%91%E8%A1%8C%E7%89%88"><span class="toc-text">Linux内核&amp;发行版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC"><span class="toc-text">Linux内核版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC"><span class="toc-text">Linux发行版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">类Unix系统目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">Linux目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%9B%AE%E5%BD%95"><span class="toc-text">用户目录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">命令行基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">命令使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-text">查看帮助文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#help-%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="toc-text">help 内置命令的帮助信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#man-manual-%E8%8E%B7%E5%BE%97%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="toc-text">man(manual) 获得帮助信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tab%E9%94%AE-%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="toc-text">tab键 自动补全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clear-%E6%B8%85%E5%B1%8F"><span class="toc-text">clear 清屏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8E%86%E5%8F%B2"><span class="toc-text">history 命令行历史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%95history%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96"><span class="toc-text">📕history生产环境优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-text">命令行中的快捷键</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%91%BD%E4%BB%A4"><span class="toc-text">Linux命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-text">权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#r%E3%80%81-w%E3%80%81-x-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">(-r、-w、-x) 文件访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chmod-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-text">chmod 修改文件或目录的权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chown-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E8%80%85%E5%92%8C%E6%89%80%E5%B1%9E%E7%BB%84"><span class="toc-text">chown 修改文件和目录的所有者和所属组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chgrp-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E5%B1%9E%E7%BB%84"><span class="toc-text">chgrp 修改文件和目录的所属组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chattr-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%83%E9%99%90%E5%B1%9E%E6%80%A7"><span class="toc-text">chattr 修改文件系统的权限属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsattr-%E6%9F%A5%E7%9C%8B%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="toc-text">lsattr 查看特殊权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sudo-%E4%BB%A5%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-text">sudo 以其他用户身份执行命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-text">文件和目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cd-%E5%88%87%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">cd 切换工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pwd-%E6%98%BE%E7%A4%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">pwd 显示绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ls-%E5%88%97%E5%87%BA%E7%9B%AE%E5%BD%95%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">ls 列出目录的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stat-%E6%98%BE%E7%A4%BAinode%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">stat 显示inode的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-text">mkdir 创建一个新的目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rmdir-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-text">rmdir 删除一个空的目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rm-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">rm 删除文件或目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#touch-%E5%88%9B%E5%BB%BA%E7%A9%BA%E6%96%87%E4%BB%B6"><span class="toc-text">touch 创建空文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mv-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E3%80%81%E7%9B%AE%E5%BD%95%E6%88%96%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-text">mv 移动文件、目录或重命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cp-%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95"><span class="toc-text">cp 复制文件或目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ln-%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-text">ln 建立一个同步的链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%9B%AE%E5%BD%95"><span class="toc-text">find 查找文件或者目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#locate-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="toc-text">locate 快速定位文件路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#which-%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E4%BD%8D%E7%BD%AE"><span class="toc-text">which 查看命令位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scp-%E5%AE%89%E5%85%A8%E6%8B%B7%E8%B4%9D"><span class="toc-text">scp 安全拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#source-%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">source 执行脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-text">文本处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#echo-%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">echo 输出内容到控制台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#printf-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">printf 格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cat-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">cat 查看文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tac-%E5%80%92%E5%BA%8F%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">tac 倒序查看文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nl-%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E7%9A%84%E8%A1%8C%E5%8F%B7"><span class="toc-text">nl 计算文件的行号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#more-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%88%86%E5%B1%8F%E6%9F%A5%E7%9C%8B%E5%99%A8"><span class="toc-text">more 文件内容分屏查看器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#less-%E5%88%86%E5%B1%8F%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">less 分屏显示文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#head-%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E5%86%85%E5%AE%B9"><span class="toc-text">head 输出文件头部内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tail-%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8%E5%86%85%E5%AE%B9"><span class="toc-text">tail 输出文件尾部内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wc-%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-text">wc 字数统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-%E6%8E%92%E5%BA%8F"><span class="toc-text">sort 排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniq-%E5%8E%BB%E9%87%8D"><span class="toc-text">uniq 去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tee-%E5%B0%86%E6%95%B0%E6%8D%AE%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-text">tee 将数据重定向到文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join-%E6%96%87%E4%BB%B6%E6%8C%89%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="toc-text">join 文件按行连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#paste-%E5%B0%86%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%AF%B9%E5%BA%94%E8%A1%8C%E9%93%BE%E6%8E%A5%E5%9C%A8%E4%B8%80%E8%B5%B7"><span class="toc-text">paste 将多个文件对应行链接在一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split-%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2"><span class="toc-text">split 文件切割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cut-%E9%80%89%E5%8F%96%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9"><span class="toc-text">cut 选取部分内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tr-%E5%AF%B9%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E5%81%9A%E6%9B%BF%E6%8D%A2"><span class="toc-text">tr 对标准输入内容做替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">&gt; 输出重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E6%8C%87%E5%AE%9A%E8%A1%8C%E5%8C%BA%E9%97%B4-%E7%AE%A1%E9%81%93%E7%AC%A6"><span class="toc-text">| 用文本模式指定行区间 管道符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xargs-%E5%8F%82%E6%95%B0%E4%BB%A3%E6%8D%A2"><span class="toc-text">xargs 参数代换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep-%E8%A1%8C%E9%80%89%E5%8F%96%E5%91%BD%E4%BB%A4"><span class="toc-text">grep 行选取命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#egrep-%E6%96%87%E4%BB%B6%E9%80%89%E5%8F%96%E5%91%BD%E4%BB%A4"><span class="toc-text">egrep 文件选取命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sed"><span class="toc-text">sed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk"><span class="toc-text">awk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-gunzip-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="toc-text">gzip&#x2F;gunzip 压缩&#x2F;解压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zip-unzip-%E5%8E%8B%E7%BC%A9-%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="toc-text">zip&#x2F;unzip 压缩&#x2F;解压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar-%E6%89%93%E5%8C%85"><span class="toc-text">tar 打包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86"><span class="toc-text">用户和用户组管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%82-etc-passwd-%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">📂&#x2F;etc&#x2F;passwd 用户配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%82-etc-shadow-%E5%BD%B1%E5%AD%90%E6%96%87%E4%BB%B6"><span class="toc-text">📂&#x2F;etc&#x2F;shadow 影子文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%82-etc-group-%E7%94%A8%E6%88%B7%E7%BB%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">📂&#x2F;etc&#x2F;group 用户组配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%82-etc-gshadow-%E5%AE%89%E5%85%A8%E7%BB%84%E8%B4%A6%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">📂&#x2F;etc&#x2F;gshadow 安全组账户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%82-etc-login-defs-Shadow%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-text">📂&#x2F;etc&#x2F;login.defs Shadow密码套件配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%82-etc-skel-%E6%96%B0%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">📂&#x2F;etc&#x2F;skel 新用户配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#w-who-whoami-who-am-i-%E6%9F%A5%E7%9C%8B%E7%99%BB%E9%99%86%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">w who whoami who am i 查看登陆用户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit-%E9%80%80%E5%87%BA%E7%99%BB%E5%85%A5%E8%B4%A6%E6%88%B7"><span class="toc-text">exit 退出登入账户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useradd-%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7"><span class="toc-text">useradd 添加新用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#passwd-%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="toc-text">passwd 设置用户密码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usermod-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">usermod 修改用户信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#userdel-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7"><span class="toc-text">userdel 删除用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id-%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7%E7%9A%84UID%E5%92%8CGID"><span class="toc-text">id 查看用户的UID和GID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#su-%E7%94%A8%E6%88%B7%E9%97%B4%E5%88%87%E6%8D%A2"><span class="toc-text">su 用户间切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#groupadd-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-text">groupadd 添加用户组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#groupmod-%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-text">groupmod 修改用户组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpasswd-%E6%8A%8A%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E8%BF%9B%E7%BB%84%E6%88%96%E4%BB%8E%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4"><span class="toc-text">gpasswd 把用户添加进组或从组中删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newgrp-%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E7%9A%84%E6%9C%89%E6%95%88%E7%BB%84"><span class="toc-text">newgrp 切换用户的有效组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ps-%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-text">ps 查看正在运行的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#top-%E6%8C%81%E7%BB%AD%E7%9B%91%E5%90%AC%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-text">top 持续监听进程运行状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsof-%E5%88%97%E5%87%BA%E8%BF%9B%E7%A8%8B%E8%B0%83%E7%94%A8%E6%88%96%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-text">lsof 列出进程调用或打开的文件信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pstree-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E6%A0%91"><span class="toc-text">pstree 查看进程树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kill-%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-text">kill 终止进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#killall-%E7%BB%88%E6%AD%A2%E7%89%B9%E5%AE%9A%E7%9A%84%E4%B8%80%E7%B1%BB%E8%BF%9B%E7%A8%8B"><span class="toc-text">killall 终止特定的一类进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#crontab-%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">crontab 循环执行定时任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81"><span class="toc-text">free 查看内存使用状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cal-%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%8E%86"><span class="toc-text">cal 查看日历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#date-%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4"><span class="toc-text">date 日期与时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-text">网络配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ss-%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E5%B7%A5%E5%85%B7"><span class="toc-text">ss 网络状态工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#netstat-%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81"><span class="toc-text">netstat 查看网络状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping-%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E7%9A%84%E8%BF%9E%E9%80%9A%E4%BF%A1"><span class="toc-text">ping 测试网络的连通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#traceroute-%E8%BF%BD%E8%B8%AA%E8%B7%AF%E7%94%B1"><span class="toc-text">traceroute 追踪路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ifconfig-%E6%98%BE%E7%A4%BA%E6%88%96%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="toc-text">ifconfig 显示或配置网络设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ip-addr-%E6%9F%A5%E7%9C%8BIP%E5%9C%B0%E5%9D%80"><span class="toc-text">ip addr 查看IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-halt-poweroff-reboot-init-%E5%85%B3%E6%9C%BA%E5%92%8C%E9%87%8D%E5%90%AF"><span class="toc-text">shutdown halt poweroff reboot init 关机和重启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB"><span class="toc-text">服务运行级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#service-OS6"><span class="toc-text">service (OS6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chkconfig-OS6"><span class="toc-text">chkconfig (OS6)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systemctl-OS7"><span class="toc-text">systemctl (OS7)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iptables%EF%BC%88OS6%EF%BC%89"><span class="toc-text">iptables（OS6）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#span-id-firewall-firewall-span-%EF%BC%880S7%EF%BC%89"><span class="toc-text">firewall（0S7）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#journalctl"><span class="toc-text">journalctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#homenamectl-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-text">homenamectl 配置主机名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-text">文件系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#df-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A1%AC%E7%9B%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">df 查看文件系统硬盘使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#du-%E7%BB%9F%E8%AE%A1%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%E6%89%80%E5%8D%A0%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-text">du 统计目录或文件所占磁盘空间大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lsblk-%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E6%8C%82%E8%BD%BD%E6%83%85%E5%86%B5"><span class="toc-text">lsblk 查看设备挂载情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mount-umount-%E6%8C%82%E8%BD%BD-%E5%8D%B8%E8%BD%BD"><span class="toc-text">mount&#x2F;umount 挂载&#x2F;卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#etc-fatab-%E9%85%8D%E7%BD%AE-%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87"><span class="toc-text">&#x2F;etc&#x2F;fatab 配置-开机自动挂载硬件设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fdisk-%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-text">fdisk 磁盘分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parted-%E5%A4%A7%E5%AE%B9%E9%87%8F%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-text">parted 大容量磁盘分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkfs-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%88%86%E5%8C%BA"><span class="toc-text">mkfs 格式化分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mke2fs-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%88%86%E5%8C%BA"><span class="toc-text">mke2fs 格式化分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fsck-%E7%A3%81%E7%9B%98%E6%A3%80%E9%AA%8C"><span class="toc-text">fsck 磁盘检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA%E6%8C%82%E8%BD%BD"><span class="toc-text">添加磁盘及分区挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98%E5%92%8C%E6%B0%B8%E4%B9%85%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98"><span class="toc-text">挂载光盘和永久挂载光盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%92%8C%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98"><span class="toc-text">虚拟内存和物理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap%E5%88%86%E5%8C%BA"><span class="toc-text">swap分区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-text">软件安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8C%85"><span class="toc-text">软件包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%BA%90%E7%A0%81%E5%8C%85"><span class="toc-text">Linux源码包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85"><span class="toc-text">Linux二进制包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPM%E5%8C%85"><span class="toc-text">RPM包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RPM%E5%8C%85%E7%BB%9F%E4%B8%80%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">RPM包统一命名规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPM%E5%8C%85%E5%AE%89%E8%A3%85%E3%80%81%E5%8D%B8%E8%BD%BD%E5%92%8C%E5%8D%87%E7%BA%A7"><span class="toc-text">RPM包安装、卸载和升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yum-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-text">yum 包管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85-yum-%E6%BA%90"><span class="toc-text">更换国内 yum 源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yum-%E5%91%BD%E4%BB%A4"><span class="toc-text">yum 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dnf-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-text">dnf 包管理工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Seliunx"><span class="toc-text">Seliunx</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD"><span class="toc-text">系统备份</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%87%E4%BB%BD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-text">1.备份的重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5"><span class="toc-text">2.备份策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-tar%E5%91%BD%E4%BB%A4%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="toc-text">3.tar命令备份数据</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f815fa0.html" title="Docker Compose 部署 Nginx +Acme.sh + Lsky Pro + MariaDB"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/4a6210419bd5c.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Docker Compose 部署 Nginx +Acme.sh + Lsky Pro + MariaDB"></a><div class="content"><a class="title" href="/posts/f815fa0.html" title="Docker Compose 部署 Nginx +Acme.sh + Lsky Pro + MariaDB">Docker Compose 部署 Nginx +Acme.sh + Lsky Pro + MariaDB</a><time datetime="2023-02-23T11:22:23.000Z" title="发表于 2023-02-23 11:22:23">2023-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9fc1e5d1.html" title="Hexo 中使用 emoji 表情"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/8a2eecb582675.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Hexo 中使用 emoji 表情"></a><div class="content"><a class="title" href="/posts/9fc1e5d1.html" title="Hexo 中使用 emoji 表情">Hexo 中使用 emoji 表情</a><time datetime="2023-02-15T00:05:54.000Z" title="发表于 2023-02-15 00:05:54">2023-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1763fb9d.html" title="WMware 虚拟机安装 Linux"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/029c30b1525aa.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="WMware 虚拟机安装 Linux"></a><div class="content"><a class="title" href="/posts/1763fb9d.html" title="WMware 虚拟机安装 Linux">WMware 虚拟机安装 Linux</a><time datetime="2023-02-13T17:55:37.000Z" title="发表于 2023-02-13 17:55:37">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ba31607c.html" title="VMware网络配置，只此一篇就够了！"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/e794ed4b2079f.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="VMware网络配置，只此一篇就够了！"></a><div class="content"><a class="title" href="/posts/ba31607c.html" title="VMware网络配置，只此一篇就够了！">VMware网络配置，只此一篇就够了！</a><time datetime="2023-02-13T12:23:06.000Z" title="发表于 2023-02-13 12:23:06">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1031b26.html" title="Zabbix 6.0 学习笔记"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://images.halfsummer.xyz/2023/02/23/fe6dad0521ce2.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Zabbix 6.0 学习笔记"></a><div class="content"><a class="title" href="/posts/c1031b26.html" title="Zabbix 6.0 学习笔记">Zabbix 6.0 学习笔记</a><time datetime="2023-02-12T00:44:21.000Z" title="发表于 2023-02-12 00:44:21">2023-02-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By aceniu</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://hexo-twikoo.halfsummer.xyz/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://hexo-twikoo.halfsummer.xyz/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>